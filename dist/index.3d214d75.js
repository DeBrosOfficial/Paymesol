// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles

(function (modules, entry, mainEntry, parcelRequireName, globalName) {
  /* eslint-disable no-undef */
  var globalObject =
    typeof globalThis !== 'undefined'
      ? globalThis
      : typeof self !== 'undefined'
      ? self
      : typeof window !== 'undefined'
      ? window
      : typeof global !== 'undefined'
      ? global
      : {};
  /* eslint-enable no-undef */

  // Save the require from previous bundle to this closure if any
  var previousRequire =
    typeof globalObject[parcelRequireName] === 'function' &&
    globalObject[parcelRequireName];

  var cache = previousRequire.cache || {};
  // Do not use `require` to prevent Webpack from trying to bundle this call
  var nodeRequire =
    typeof module !== 'undefined' &&
    typeof module.require === 'function' &&
    module.require.bind(module);

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire =
          typeof globalObject[parcelRequireName] === 'function' &&
          globalObject[parcelRequireName];
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error("Cannot find module '" + name + "'");
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = (cache[name] = new newRequire.Module(name));

      modules[name][0].call(
        module.exports,
        localRequire,
        module,
        module.exports,
        this
      );
    }

    return cache[name].exports;

    function localRequire(x) {
      var res = localRequire.resolve(x);
      return res === false ? {} : newRequire(res);
    }

    function resolve(x) {
      var id = modules[name][1][x];
      return id != null ? id : x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [
      function (require, module) {
        module.exports = exports;
      },
      {},
    ];
  };

  Object.defineProperty(newRequire, 'root', {
    get: function () {
      return globalObject[parcelRequireName];
    },
  });

  globalObject[parcelRequireName] = newRequire;

  for (var i = 0; i < entry.length; i++) {
    newRequire(entry[i]);
  }

  if (mainEntry) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(mainEntry);

    // CommonJS
    if (typeof exports === 'object' && typeof module !== 'undefined') {
      module.exports = mainExports;

      // RequireJS
    } else if (typeof define === 'function' && define.amd) {
      define(function () {
        return mainExports;
      });

      // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }
})({"km5uZ":[function(require,module,exports) {
var global = arguments[3];
var HMR_HOST = null;
var HMR_PORT = null;
var HMR_SECURE = false;
var HMR_ENV_HASH = "d6ea1d42532a7575";
var HMR_USE_SSE = false;
module.bundle.HMR_BUNDLE_ID = "0a8ecb283d214d75";
"use strict";
/* global HMR_HOST, HMR_PORT, HMR_ENV_HASH, HMR_SECURE, HMR_USE_SSE, chrome, browser, __parcel__import__, __parcel__importScripts__, ServiceWorkerGlobalScope */ /*::
import type {
  HMRAsset,
  HMRMessage,
} from '@parcel/reporter-dev-server/src/HMRServer.js';
interface ParcelRequire {
  (string): mixed;
  cache: {|[string]: ParcelModule|};
  hotData: {|[string]: mixed|};
  Module: any;
  parent: ?ParcelRequire;
  isParcelRequire: true;
  modules: {|[string]: [Function, {|[string]: string|}]|};
  HMR_BUNDLE_ID: string;
  root: ParcelRequire;
}
interface ParcelModule {
  hot: {|
    data: mixed,
    accept(cb: (Function) => void): void,
    dispose(cb: (mixed) => void): void,
    // accept(deps: Array<string> | string, cb: (Function) => void): void,
    // decline(): void,
    _acceptCallbacks: Array<(Function) => void>,
    _disposeCallbacks: Array<(mixed) => void>,
  |};
}
interface ExtensionContext {
  runtime: {|
    reload(): void,
    getURL(url: string): string;
    getManifest(): {manifest_version: number, ...};
  |};
}
declare var module: {bundle: ParcelRequire, ...};
declare var HMR_HOST: string;
declare var HMR_PORT: string;
declare var HMR_ENV_HASH: string;
declare var HMR_SECURE: boolean;
declare var HMR_USE_SSE: boolean;
declare var chrome: ExtensionContext;
declare var browser: ExtensionContext;
declare var __parcel__import__: (string) => Promise<void>;
declare var __parcel__importScripts__: (string) => Promise<void>;
declare var globalThis: typeof self;
declare var ServiceWorkerGlobalScope: Object;
*/ var OVERLAY_ID = "__parcel__error__overlay__";
var OldModule = module.bundle.Module;
function Module(moduleName) {
    OldModule.call(this, moduleName);
    this.hot = {
        data: module.bundle.hotData[moduleName],
        _acceptCallbacks: [],
        _disposeCallbacks: [],
        accept: function(fn) {
            this._acceptCallbacks.push(fn || function() {});
        },
        dispose: function(fn) {
            this._disposeCallbacks.push(fn);
        }
    };
    module.bundle.hotData[moduleName] = undefined;
}
module.bundle.Module = Module;
module.bundle.hotData = {};
var checkedAssets /*: {|[string]: boolean|} */ , assetsToDispose /*: Array<[ParcelRequire, string]> */ , assetsToAccept /*: Array<[ParcelRequire, string]> */ ;
function getHostname() {
    return HMR_HOST || (location.protocol.indexOf("http") === 0 ? location.hostname : "localhost");
}
function getPort() {
    return HMR_PORT || location.port;
}
// eslint-disable-next-line no-redeclare
var parent = module.bundle.parent;
if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== "undefined") {
    var hostname = getHostname();
    var port = getPort();
    var protocol = HMR_SECURE || location.protocol == "https:" && ![
        "localhost",
        "127.0.0.1",
        "0.0.0.0"
    ].includes(hostname) ? "wss" : "ws";
    var ws;
    if (HMR_USE_SSE) ws = new EventSource("/__parcel_hmr");
    else try {
        ws = new WebSocket(protocol + "://" + hostname + (port ? ":" + port : "") + "/");
    } catch (err) {
        if (err.message) console.error(err.message);
        ws = {};
    }
    // Web extension context
    var extCtx = typeof browser === "undefined" ? typeof chrome === "undefined" ? null : chrome : browser;
    // Safari doesn't support sourceURL in error stacks.
    // eval may also be disabled via CSP, so do a quick check.
    var supportsSourceURL = false;
    try {
        (0, eval)('throw new Error("test"); //# sourceURL=test.js');
    } catch (err) {
        supportsSourceURL = err.stack.includes("test.js");
    }
    // $FlowFixMe
    ws.onmessage = async function(event /*: {data: string, ...} */ ) {
        checkedAssets = {} /*: {|[string]: boolean|} */ ;
        assetsToAccept = [];
        assetsToDispose = [];
        var data /*: HMRMessage */  = JSON.parse(event.data);
        if (data.type === "update") {
            // Remove error overlay if there is one
            if (typeof document !== "undefined") removeErrorOverlay();
            let assets = data.assets.filter((asset)=>asset.envHash === HMR_ENV_HASH);
            // Handle HMR Update
            let handled = assets.every((asset)=>{
                return asset.type === "css" || asset.type === "js" && hmrAcceptCheck(module.bundle.root, asset.id, asset.depsByBundle);
            });
            if (handled) {
                console.clear();
                // Dispatch custom event so other runtimes (e.g React Refresh) are aware.
                if (typeof window !== "undefined" && typeof CustomEvent !== "undefined") window.dispatchEvent(new CustomEvent("parcelhmraccept"));
                await hmrApplyUpdates(assets);
                // Dispose all old assets.
                let processedAssets = {} /*: {|[string]: boolean|} */ ;
                for(let i = 0; i < assetsToDispose.length; i++){
                    let id = assetsToDispose[i][1];
                    if (!processedAssets[id]) {
                        hmrDispose(assetsToDispose[i][0], id);
                        processedAssets[id] = true;
                    }
                }
                // Run accept callbacks. This will also re-execute other disposed assets in topological order.
                processedAssets = {};
                for(let i = 0; i < assetsToAccept.length; i++){
                    let id = assetsToAccept[i][1];
                    if (!processedAssets[id]) {
                        hmrAccept(assetsToAccept[i][0], id);
                        processedAssets[id] = true;
                    }
                }
            } else fullReload();
        }
        if (data.type === "error") {
            // Log parcel errors to console
            for (let ansiDiagnostic of data.diagnostics.ansi){
                let stack = ansiDiagnostic.codeframe ? ansiDiagnostic.codeframe : ansiDiagnostic.stack;
                console.error("\uD83D\uDEA8 [parcel]: " + ansiDiagnostic.message + "\n" + stack + "\n\n" + ansiDiagnostic.hints.join("\n"));
            }
            if (typeof document !== "undefined") {
                // Render the fancy html overlay
                removeErrorOverlay();
                var overlay = createErrorOverlay(data.diagnostics.html);
                // $FlowFixMe
                document.body.appendChild(overlay);
            }
        }
    };
    if (ws instanceof WebSocket) {
        ws.onerror = function(e) {
            if (e.message) console.error(e.message);
        };
        ws.onclose = function() {
            console.warn("[parcel] \uD83D\uDEA8 Connection to the HMR server was lost");
        };
    }
}
function removeErrorOverlay() {
    var overlay = document.getElementById(OVERLAY_ID);
    if (overlay) {
        overlay.remove();
        console.log("[parcel] \u2728 Error resolved");
    }
}
function createErrorOverlay(diagnostics) {
    var overlay = document.createElement("div");
    overlay.id = OVERLAY_ID;
    let errorHTML = '<div style="background: black; opacity: 0.85; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; font-family: Menlo, Consolas, monospace; z-index: 9999;">';
    for (let diagnostic of diagnostics){
        let stack = diagnostic.frames.length ? diagnostic.frames.reduce((p, frame)=>{
            return `${p}
<a href="/__parcel_launch_editor?file=${encodeURIComponent(frame.location)}" style="text-decoration: underline; color: #888" onclick="fetch(this.href); return false">${frame.location}</a>
${frame.code}`;
        }, "") : diagnostic.stack;
        errorHTML += `
      <div>
        <div style="font-size: 18px; font-weight: bold; margin-top: 20px;">
          \u{1F6A8} ${diagnostic.message}
        </div>
        <pre>${stack}</pre>
        <div>
          ${diagnostic.hints.map((hint)=>"<div>\uD83D\uDCA1 " + hint + "</div>").join("")}
        </div>
        ${diagnostic.documentation ? `<div>\u{1F4DD} <a style="color: violet" href="${diagnostic.documentation}" target="_blank">Learn more</a></div>` : ""}
      </div>
    `;
    }
    errorHTML += "</div>";
    overlay.innerHTML = errorHTML;
    return overlay;
}
function fullReload() {
    if ("reload" in location) location.reload();
    else if (extCtx && extCtx.runtime && extCtx.runtime.reload) extCtx.runtime.reload();
}
function getParents(bundle, id) /*: Array<[ParcelRequire, string]> */ {
    var modules = bundle.modules;
    if (!modules) return [];
    var parents = [];
    var k, d, dep;
    for(k in modules)for(d in modules[k][1]){
        dep = modules[k][1][d];
        if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) parents.push([
            bundle,
            k
        ]);
    }
    if (bundle.parent) parents = parents.concat(getParents(bundle.parent, id));
    return parents;
}
function updateLink(link) {
    var href = link.getAttribute("href");
    if (!href) return;
    var newLink = link.cloneNode();
    newLink.onload = function() {
        if (link.parentNode !== null) // $FlowFixMe
        link.parentNode.removeChild(link);
    };
    newLink.setAttribute("href", // $FlowFixMe
    href.split("?")[0] + "?" + Date.now());
    // $FlowFixMe
    link.parentNode.insertBefore(newLink, link.nextSibling);
}
var cssTimeout = null;
function reloadCSS() {
    if (cssTimeout) return;
    cssTimeout = setTimeout(function() {
        var links = document.querySelectorAll('link[rel="stylesheet"]');
        for(var i = 0; i < links.length; i++){
            // $FlowFixMe[incompatible-type]
            var href /*: string */  = links[i].getAttribute("href");
            var hostname = getHostname();
            var servedFromHMRServer = hostname === "localhost" ? new RegExp("^(https?:\\/\\/(0.0.0.0|127.0.0.1)|localhost):" + getPort()).test(href) : href.indexOf(hostname + ":" + getPort());
            var absolute = /^https?:\/\//i.test(href) && href.indexOf(location.origin) !== 0 && !servedFromHMRServer;
            if (!absolute) updateLink(links[i]);
        }
        cssTimeout = null;
    }, 50);
}
function hmrDownload(asset) {
    if (asset.type === "js") {
        if (typeof document !== "undefined") {
            let script = document.createElement("script");
            script.src = asset.url + "?t=" + Date.now();
            if (asset.outputFormat === "esmodule") script.type = "module";
            return new Promise((resolve, reject)=>{
                var _document$head;
                script.onload = ()=>resolve(script);
                script.onerror = reject;
                (_document$head = document.head) === null || _document$head === void 0 || _document$head.appendChild(script);
            });
        } else if (typeof importScripts === "function") {
            // Worker scripts
            if (asset.outputFormat === "esmodule") return import(asset.url + "?t=" + Date.now());
            else return new Promise((resolve, reject)=>{
                try {
                    importScripts(asset.url + "?t=" + Date.now());
                    resolve();
                } catch (err) {
                    reject(err);
                }
            });
        }
    }
}
async function hmrApplyUpdates(assets) {
    global.parcelHotUpdate = Object.create(null);
    let scriptsToRemove;
    try {
        // If sourceURL comments aren't supported in eval, we need to load
        // the update from the dev server over HTTP so that stack traces
        // are correct in errors/logs. This is much slower than eval, so
        // we only do it if needed (currently just Safari).
        // https://bugs.webkit.org/show_bug.cgi?id=137297
        // This path is also taken if a CSP disallows eval.
        if (!supportsSourceURL) {
            let promises = assets.map((asset)=>{
                var _hmrDownload;
                return (_hmrDownload = hmrDownload(asset)) === null || _hmrDownload === void 0 ? void 0 : _hmrDownload.catch((err)=>{
                    // Web extension fix
                    if (extCtx && extCtx.runtime && extCtx.runtime.getManifest().manifest_version == 3 && typeof ServiceWorkerGlobalScope != "undefined" && global instanceof ServiceWorkerGlobalScope) {
                        extCtx.runtime.reload();
                        return;
                    }
                    throw err;
                });
            });
            scriptsToRemove = await Promise.all(promises);
        }
        assets.forEach(function(asset) {
            hmrApply(module.bundle.root, asset);
        });
    } finally{
        delete global.parcelHotUpdate;
        if (scriptsToRemove) scriptsToRemove.forEach((script)=>{
            if (script) {
                var _document$head2;
                (_document$head2 = document.head) === null || _document$head2 === void 0 || _document$head2.removeChild(script);
            }
        });
    }
}
function hmrApply(bundle /*: ParcelRequire */ , asset /*:  HMRAsset */ ) {
    var modules = bundle.modules;
    if (!modules) return;
    if (asset.type === "css") reloadCSS();
    else if (asset.type === "js") {
        let deps = asset.depsByBundle[bundle.HMR_BUNDLE_ID];
        if (deps) {
            if (modules[asset.id]) {
                // Remove dependencies that are removed and will become orphaned.
                // This is necessary so that if the asset is added back again, the cache is gone, and we prevent a full page reload.
                let oldDeps = modules[asset.id][1];
                for(let dep in oldDeps)if (!deps[dep] || deps[dep] !== oldDeps[dep]) {
                    let id = oldDeps[dep];
                    let parents = getParents(module.bundle.root, id);
                    if (parents.length === 1) hmrDelete(module.bundle.root, id);
                }
            }
            if (supportsSourceURL) // Global eval. We would use `new Function` here but browser
            // support for source maps is better with eval.
            (0, eval)(asset.output);
            // $FlowFixMe
            let fn = global.parcelHotUpdate[asset.id];
            modules[asset.id] = [
                fn,
                deps
            ];
        } else if (bundle.parent) hmrApply(bundle.parent, asset);
    }
}
function hmrDelete(bundle, id) {
    let modules = bundle.modules;
    if (!modules) return;
    if (modules[id]) {
        // Collect dependencies that will become orphaned when this module is deleted.
        let deps = modules[id][1];
        let orphans = [];
        for(let dep in deps){
            let parents = getParents(module.bundle.root, deps[dep]);
            if (parents.length === 1) orphans.push(deps[dep]);
        }
        // Delete the module. This must be done before deleting dependencies in case of circular dependencies.
        delete modules[id];
        delete bundle.cache[id];
        // Now delete the orphans.
        orphans.forEach((id)=>{
            hmrDelete(module.bundle.root, id);
        });
    } else if (bundle.parent) hmrDelete(bundle.parent, id);
}
function hmrAcceptCheck(bundle /*: ParcelRequire */ , id /*: string */ , depsByBundle /*: ?{ [string]: { [string]: string } }*/ ) {
    if (hmrAcceptCheckOne(bundle, id, depsByBundle)) return true;
    // Traverse parents breadth first. All possible ancestries must accept the HMR update, or we'll reload.
    let parents = getParents(module.bundle.root, id);
    let accepted = false;
    while(parents.length > 0){
        let v = parents.shift();
        let a = hmrAcceptCheckOne(v[0], v[1], null);
        if (a) // If this parent accepts, stop traversing upward, but still consider siblings.
        accepted = true;
        else {
            // Otherwise, queue the parents in the next level upward.
            let p = getParents(module.bundle.root, v[1]);
            if (p.length === 0) {
                // If there are no parents, then we've reached an entry without accepting. Reload.
                accepted = false;
                break;
            }
            parents.push(...p);
        }
    }
    return accepted;
}
function hmrAcceptCheckOne(bundle /*: ParcelRequire */ , id /*: string */ , depsByBundle /*: ?{ [string]: { [string]: string } }*/ ) {
    var modules = bundle.modules;
    if (!modules) return;
    if (depsByBundle && !depsByBundle[bundle.HMR_BUNDLE_ID]) {
        // If we reached the root bundle without finding where the asset should go,
        // there's nothing to do. Mark as "accepted" so we don't reload the page.
        if (!bundle.parent) return true;
        return hmrAcceptCheck(bundle.parent, id, depsByBundle);
    }
    if (checkedAssets[id]) return true;
    checkedAssets[id] = true;
    var cached = bundle.cache[id];
    assetsToDispose.push([
        bundle,
        id
    ]);
    if (!cached || cached.hot && cached.hot._acceptCallbacks.length) {
        assetsToAccept.push([
            bundle,
            id
        ]);
        return true;
    }
}
function hmrDispose(bundle /*: ParcelRequire */ , id /*: string */ ) {
    var cached = bundle.cache[id];
    bundle.hotData[id] = {};
    if (cached && cached.hot) cached.hot.data = bundle.hotData[id];
    if (cached && cached.hot && cached.hot._disposeCallbacks.length) cached.hot._disposeCallbacks.forEach(function(cb) {
        cb(bundle.hotData[id]);
    });
    delete bundle.cache[id];
}
function hmrAccept(bundle /*: ParcelRequire */ , id /*: string */ ) {
    // Execute the module.
    bundle(id);
    // Run the accept callbacks in the new version of the module.
    var cached = bundle.cache[id];
    if (cached && cached.hot && cached.hot._acceptCallbacks.length) cached.hot._acceptCallbacks.forEach(function(cb) {
        var assetsToAlsoAccept = cb(function() {
            return getParents(module.bundle.root, id);
        });
        if (assetsToAlsoAccept && assetsToAccept.length) {
            assetsToAlsoAccept.forEach(function(a) {
                hmrDispose(a[0], a[1]);
            });
            // $FlowFixMe[method-unbinding]
            assetsToAccept.push.apply(assetsToAccept, assetsToAlsoAccept);
        }
    });
}

},{}],"bB7Pu":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
var _pay = require("@solana/pay");
var _web3Js = require("@solana/web3.js");
var _qrcode = require("qrcode");
var _qrcodeDefault = parcelHelpers.interopDefault(_qrcode);
var _bignumberJs = require("bignumber.js");
var _bignumberJsDefault = parcelHelpers.interopDefault(_bignumberJs);
// Token mint addresses for EURC, USDC, and null for SOL (native SOL)
const tokenMints = {
    EURC: new (0, _web3Js.PublicKey)("HzwqbKZw8HxMN6bF2yFZNrht3c2iXXzpKcFu7uBEDKtr"),
    USDC: new (0, _web3Js.PublicKey)("EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v"),
    SOL: null // SOL is the native token and does not require an SPL token address
};
// CoinGecko API URL
const COINGECKO_API_URL = "https://api.coingecko.com/api/v3/simple/price";
// Function to connect to Phantom Wallet
async function connectWallet() {
    if (window.solana && window.solana.isPhantom) try {
        const response = await window.solana.connect();
        const walletAddress = response.publicKey.toString();
        console.log("Connected with public key:", walletAddress);
        // Shorten the wallet address for display
        const shortAddress = `${walletAddress.slice(0, 4)}...${walletAddress.slice(-4)}`;
        document.getElementById("connect-wallet").innerHTML = `<i class="fas fa-wallet"></i> <span style="color: green; font-weight: bold;">${shortAddress}</span>`;
        return walletAddress;
    } catch (err) {
        console.error("Wallet connection failed:", err);
        return null;
    }
    else {
        alert("Phantom wallet is not installed.");
        return null;
    }
}
function clearCanvas() {
    const canvas = document.getElementById("qr-canvas");
    const context = canvas.getContext("2d");
    context.clearRect(0, 0, canvas.width, canvas.height);
    // Reset the EUR amount input field
    document.getElementById("eur-amount").value = "";
    // Reset the converted amount field
    document.getElementById("converted-amount").value = "";
}
// Function to get the selected token from a custom dropdown or radio buttons
function getSelectedToken() {
    const selectedOption = document.querySelector('input[name="token"]:checked') || document.querySelector(".selected-option");
    if (selectedOption) return selectedOption.getAttribute("data-value") || selectedOption.value;
    return null;
}
// Fetch conversion rate from CoinGecko API
async function fetchConversionRate(cryptoId) {
    const url = `${COINGECKO_API_URL}?ids=${cryptoId}&vs_currencies=eur`;
    const response = await fetch(url);
    if (!response.ok) {
        console.error("Failed to fetch conversion rate");
        return null;
    }
    const data = await response.json();
    const conversionRate = data[cryptoId].eur;
    return conversionRate;
}
// Update the converted amount in the selected token
async function updateConvertedAmount() {
    const eurAmount = document.getElementById("eur-amount").value;
    const selectedToken = getSelectedToken();
    if (!eurAmount || !selectedToken) return;
    const cryptoIdMap = {
        EURC: "euro-coin",
        USDC: "usd-coin",
        SOL: "solana"
    };
    const cryptoId = cryptoIdMap[selectedToken];
    const conversionRate = await fetchConversionRate(cryptoId);
    if (conversionRate !== null) {
        const convertedAmount = eurAmount / conversionRate;
        document.getElementById("converted-amount").value = convertedAmount.toFixed(4);
    } else document.getElementById("converted-amount").value = "Conversion failed";
}
// Generate the payment URL using the converted amount
async function generatePaymentURL(recipientAddress) {
    const recipient = new (0, _web3Js.PublicKey)(recipientAddress);
    const convertedAmountInput = document.getElementById("converted-amount").value;
    // Check if the converted amount is available and valid
    if (!convertedAmountInput || isNaN(convertedAmountInput)) {
        alert("Please enter a valid EUR amount to convert before generating the QR code.");
        return null;
    }
    const amount = new (0, _bignumberJsDefault.default)(convertedAmountInput);
    const selectedToken = getSelectedToken();
    const tokenMint = tokenMints[selectedToken];
    if (!tokenMint && selectedToken !== "SOL") {
        alert("Invalid token selected!");
        return null;
    }
    const url = (0, _pay.encodeURL)({
        recipient,
        amount,
        splToken: tokenMint,
        label: "DeBros Payment",
        message: "Thank you for your payment!"
    });
    return url;
}
// Display the QR code
async function displayQRCode() {
    const recipientAddress = await connectWallet();
    if (!recipientAddress) return;
    const paymentURL = await generatePaymentURL(recipientAddress);
    if (!paymentURL) return;
    (0, _qrcodeDefault.default).toCanvas(document.getElementById("qr-canvas"), paymentURL, function(error) {
        if (error) console.error(error);
        console.log("QR code generated!");
    });
}
// Event listeners for updating the converted amount
document.getElementById("eur-amount").addEventListener("input", updateConvertedAmount);
document.querySelectorAll('input[name="token"]').forEach((tokenOption)=>{
    tokenOption.addEventListener("change", updateConvertedAmount);
});
// Attach functions to window for button click
window.connectWallet = connectWallet;
window.displayQRCode = displayQRCode;
window.clearCanvas = clearCanvas;

},{"@solana/pay":"gdsX8","@solana/web3.js":"5JBKN","qrcode":"lB7MY","bignumber.js":"57qkX","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gdsX8":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _constantsMjs = require("./constants.mjs");
parcelHelpers.exportAll(_constantsMjs, exports);
var _createQRMjs = require("./createQR.mjs");
parcelHelpers.exportAll(_createQRMjs, exports);
var _createTransactionMjs = require("./createTransaction.mjs");
parcelHelpers.exportAll(_createTransactionMjs, exports);
var _encodeURLMjs = require("./encodeURL.mjs");
parcelHelpers.exportAll(_encodeURLMjs, exports);
var _findTransactionSignatureMjs = require("./findTransactionSignature.mjs");
parcelHelpers.exportAll(_findTransactionSignatureMjs, exports);
var _parseURLMjs = require("./parseURL.mjs");
parcelHelpers.exportAll(_parseURLMjs, exports);
var _validateTransactionSignatureMjs = require("./validateTransactionSignature.mjs");
parcelHelpers.exportAll(_validateTransactionSignatureMjs, exports);

},{"./constants.mjs":"6sOvE","./createQR.mjs":"fc4Em","./createTransaction.mjs":"4AJJw","./encodeURL.mjs":"7bkwb","./findTransactionSignature.mjs":"4PUc9","./parseURL.mjs":"goAqI","./validateTransactionSignature.mjs":"djp50","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6sOvE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "URL_PROTOCOL", ()=>URL_PROTOCOL);
parcelHelpers.export(exports, "MEMO_PROGRAM_ID", ()=>MEMO_PROGRAM_ID);
parcelHelpers.export(exports, "SOL_DECIMALS", ()=>SOL_DECIMALS);
parcelHelpers.export(exports, "TEN", ()=>TEN);
var _web3Js = require("@solana/web3.js");
var _bignumberJs = require("bignumber.js");
var _bignumberJsDefault = parcelHelpers.interopDefault(_bignumberJs);
const URL_PROTOCOL = "solana:";
const MEMO_PROGRAM_ID = new (0, _web3Js.PublicKey)("MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr");
const SOL_DECIMALS = 9;
const TEN = new (0, _bignumberJsDefault.default)(10);

},{"@solana/web3.js":"5JBKN","bignumber.js":"57qkX","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5JBKN":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Account", ()=>Account);
parcelHelpers.export(exports, "AddressLookupTableAccount", ()=>AddressLookupTableAccount);
parcelHelpers.export(exports, "AddressLookupTableInstruction", ()=>AddressLookupTableInstruction);
parcelHelpers.export(exports, "AddressLookupTableProgram", ()=>AddressLookupTableProgram);
parcelHelpers.export(exports, "Authorized", ()=>Authorized);
parcelHelpers.export(exports, "BLOCKHASH_CACHE_TIMEOUT_MS", ()=>BLOCKHASH_CACHE_TIMEOUT_MS);
parcelHelpers.export(exports, "BPF_LOADER_DEPRECATED_PROGRAM_ID", ()=>BPF_LOADER_DEPRECATED_PROGRAM_ID);
parcelHelpers.export(exports, "BPF_LOADER_PROGRAM_ID", ()=>BPF_LOADER_PROGRAM_ID);
parcelHelpers.export(exports, "BpfLoader", ()=>BpfLoader);
parcelHelpers.export(exports, "COMPUTE_BUDGET_INSTRUCTION_LAYOUTS", ()=>COMPUTE_BUDGET_INSTRUCTION_LAYOUTS);
parcelHelpers.export(exports, "ComputeBudgetInstruction", ()=>ComputeBudgetInstruction);
parcelHelpers.export(exports, "ComputeBudgetProgram", ()=>ComputeBudgetProgram);
parcelHelpers.export(exports, "Connection", ()=>Connection);
parcelHelpers.export(exports, "Ed25519Program", ()=>Ed25519Program);
parcelHelpers.export(exports, "Enum", ()=>Enum);
parcelHelpers.export(exports, "EpochSchedule", ()=>EpochSchedule);
parcelHelpers.export(exports, "FeeCalculatorLayout", ()=>FeeCalculatorLayout);
parcelHelpers.export(exports, "Keypair", ()=>Keypair);
parcelHelpers.export(exports, "LAMPORTS_PER_SOL", ()=>LAMPORTS_PER_SOL);
parcelHelpers.export(exports, "LOOKUP_TABLE_INSTRUCTION_LAYOUTS", ()=>LOOKUP_TABLE_INSTRUCTION_LAYOUTS);
parcelHelpers.export(exports, "Loader", ()=>Loader);
parcelHelpers.export(exports, "Lockup", ()=>Lockup);
parcelHelpers.export(exports, "MAX_SEED_LENGTH", ()=>MAX_SEED_LENGTH);
parcelHelpers.export(exports, "Message", ()=>Message);
parcelHelpers.export(exports, "MessageAccountKeys", ()=>MessageAccountKeys);
parcelHelpers.export(exports, "MessageV0", ()=>MessageV0);
parcelHelpers.export(exports, "NONCE_ACCOUNT_LENGTH", ()=>NONCE_ACCOUNT_LENGTH);
parcelHelpers.export(exports, "NonceAccount", ()=>NonceAccount);
parcelHelpers.export(exports, "PACKET_DATA_SIZE", ()=>PACKET_DATA_SIZE);
parcelHelpers.export(exports, "PUBLIC_KEY_LENGTH", ()=>PUBLIC_KEY_LENGTH);
parcelHelpers.export(exports, "PublicKey", ()=>PublicKey);
parcelHelpers.export(exports, "SIGNATURE_LENGTH_IN_BYTES", ()=>SIGNATURE_LENGTH_IN_BYTES);
parcelHelpers.export(exports, "SOLANA_SCHEMA", ()=>SOLANA_SCHEMA);
parcelHelpers.export(exports, "STAKE_CONFIG_ID", ()=>STAKE_CONFIG_ID);
parcelHelpers.export(exports, "STAKE_INSTRUCTION_LAYOUTS", ()=>STAKE_INSTRUCTION_LAYOUTS);
parcelHelpers.export(exports, "SYSTEM_INSTRUCTION_LAYOUTS", ()=>SYSTEM_INSTRUCTION_LAYOUTS);
parcelHelpers.export(exports, "SYSVAR_CLOCK_PUBKEY", ()=>SYSVAR_CLOCK_PUBKEY);
parcelHelpers.export(exports, "SYSVAR_EPOCH_SCHEDULE_PUBKEY", ()=>SYSVAR_EPOCH_SCHEDULE_PUBKEY);
parcelHelpers.export(exports, "SYSVAR_INSTRUCTIONS_PUBKEY", ()=>SYSVAR_INSTRUCTIONS_PUBKEY);
parcelHelpers.export(exports, "SYSVAR_RECENT_BLOCKHASHES_PUBKEY", ()=>SYSVAR_RECENT_BLOCKHASHES_PUBKEY);
parcelHelpers.export(exports, "SYSVAR_RENT_PUBKEY", ()=>SYSVAR_RENT_PUBKEY);
parcelHelpers.export(exports, "SYSVAR_REWARDS_PUBKEY", ()=>SYSVAR_REWARDS_PUBKEY);
parcelHelpers.export(exports, "SYSVAR_SLOT_HASHES_PUBKEY", ()=>SYSVAR_SLOT_HASHES_PUBKEY);
parcelHelpers.export(exports, "SYSVAR_SLOT_HISTORY_PUBKEY", ()=>SYSVAR_SLOT_HISTORY_PUBKEY);
parcelHelpers.export(exports, "SYSVAR_STAKE_HISTORY_PUBKEY", ()=>SYSVAR_STAKE_HISTORY_PUBKEY);
parcelHelpers.export(exports, "Secp256k1Program", ()=>Secp256k1Program);
parcelHelpers.export(exports, "SendTransactionError", ()=>SendTransactionError);
parcelHelpers.export(exports, "SolanaJSONRPCError", ()=>SolanaJSONRPCError);
parcelHelpers.export(exports, "SolanaJSONRPCErrorCode", ()=>SolanaJSONRPCErrorCode);
parcelHelpers.export(exports, "StakeAuthorizationLayout", ()=>StakeAuthorizationLayout);
parcelHelpers.export(exports, "StakeInstruction", ()=>StakeInstruction);
parcelHelpers.export(exports, "StakeProgram", ()=>StakeProgram);
parcelHelpers.export(exports, "Struct", ()=>Struct);
parcelHelpers.export(exports, "SystemInstruction", ()=>SystemInstruction);
parcelHelpers.export(exports, "SystemProgram", ()=>SystemProgram);
parcelHelpers.export(exports, "Transaction", ()=>Transaction);
parcelHelpers.export(exports, "TransactionExpiredBlockheightExceededError", ()=>TransactionExpiredBlockheightExceededError);
parcelHelpers.export(exports, "TransactionExpiredNonceInvalidError", ()=>TransactionExpiredNonceInvalidError);
parcelHelpers.export(exports, "TransactionExpiredTimeoutError", ()=>TransactionExpiredTimeoutError);
parcelHelpers.export(exports, "TransactionInstruction", ()=>TransactionInstruction);
parcelHelpers.export(exports, "TransactionMessage", ()=>TransactionMessage);
parcelHelpers.export(exports, "TransactionStatus", ()=>TransactionStatus);
parcelHelpers.export(exports, "VALIDATOR_INFO_KEY", ()=>VALIDATOR_INFO_KEY);
parcelHelpers.export(exports, "VERSION_PREFIX_MASK", ()=>VERSION_PREFIX_MASK);
parcelHelpers.export(exports, "VOTE_PROGRAM_ID", ()=>VOTE_PROGRAM_ID);
parcelHelpers.export(exports, "ValidatorInfo", ()=>ValidatorInfo);
parcelHelpers.export(exports, "VersionedMessage", ()=>VersionedMessage);
parcelHelpers.export(exports, "VersionedTransaction", ()=>VersionedTransaction);
parcelHelpers.export(exports, "VoteAccount", ()=>VoteAccount);
parcelHelpers.export(exports, "VoteAuthorizationLayout", ()=>VoteAuthorizationLayout);
parcelHelpers.export(exports, "VoteInit", ()=>VoteInit);
parcelHelpers.export(exports, "VoteInstruction", ()=>VoteInstruction);
parcelHelpers.export(exports, "VoteProgram", ()=>VoteProgram);
parcelHelpers.export(exports, "clusterApiUrl", ()=>clusterApiUrl);
parcelHelpers.export(exports, "sendAndConfirmRawTransaction", ()=>sendAndConfirmRawTransaction);
parcelHelpers.export(exports, "sendAndConfirmTransaction", ()=>sendAndConfirmTransaction);
var _buffer = require("buffer");
var _ed25519 = require("@noble/curves/ed25519");
var _bnJs = require("bn.js");
var _bnJsDefault = parcelHelpers.interopDefault(_bnJs);
var _bs58 = require("bs58");
var _bs58Default = parcelHelpers.interopDefault(_bs58);
var _sha256 = require("@noble/hashes/sha256");
var _borsh = require("borsh");
var _bufferLayout = require("@solana/buffer-layout");
var _bigintBuffer = require("bigint-buffer");
var _superstruct = require("superstruct");
var _browser = require("jayson/lib/client/browser");
var _browserDefault = parcelHelpers.interopDefault(_browser);
var _rpcWebsockets = require("rpc-websockets");
var _sha3 = require("@noble/hashes/sha3");
var _secp256K1 = require("@noble/curves/secp256k1");
/**
 * A 64 byte secret key, the first 32 bytes of which is the
 * private scalar and the last 32 bytes is the public key.
 * Read more: https://blog.mozilla.org/warner/2011/11/29/ed25519-keys/
 */ /**
 * Ed25519 Keypair
 */ const generatePrivateKey = (0, _ed25519.ed25519).utils.randomPrivateKey;
const generateKeypair = ()=>{
    const privateScalar = (0, _ed25519.ed25519).utils.randomPrivateKey();
    const publicKey = getPublicKey(privateScalar);
    const secretKey = new Uint8Array(64);
    secretKey.set(privateScalar);
    secretKey.set(publicKey, 32);
    return {
        publicKey,
        secretKey
    };
};
const getPublicKey = (0, _ed25519.ed25519).getPublicKey;
function isOnCurve(publicKey) {
    try {
        (0, _ed25519.ed25519).ExtendedPoint.fromHex(publicKey);
        return true;
    } catch  {
        return false;
    }
}
const sign = (message, secretKey)=>(0, _ed25519.ed25519).sign(message, secretKey.slice(0, 32));
const verify = (0, _ed25519.ed25519).verify;
const toBuffer = (arr)=>{
    if ((0, _buffer.Buffer).isBuffer(arr)) return arr;
    else if (arr instanceof Uint8Array) return (0, _buffer.Buffer).from(arr.buffer, arr.byteOffset, arr.byteLength);
    else return (0, _buffer.Buffer).from(arr);
};
// Class wrapping a plain object
class Struct {
    constructor(properties){
        Object.assign(this, properties);
    }
    encode() {
        return (0, _buffer.Buffer).from((0, _borsh.serialize)(SOLANA_SCHEMA, this));
    }
    static decode(data) {
        return (0, _borsh.deserialize)(SOLANA_SCHEMA, this, data);
    }
    static decodeUnchecked(data) {
        return (0, _borsh.deserializeUnchecked)(SOLANA_SCHEMA, this, data);
    }
}
// Class representing a Rust-compatible enum, since enums are only strings or
// numbers in pure JS
class Enum extends Struct {
    constructor(properties){
        super(properties);
        this.enum = "";
        if (Object.keys(properties).length !== 1) throw new Error("Enum can only take single value");
        Object.keys(properties).map((key)=>{
            this.enum = key;
        });
    }
}
const SOLANA_SCHEMA = new Map();
var _PublicKey;
/**
 * Maximum length of derived pubkey seed
 */ const MAX_SEED_LENGTH = 32;
/**
 * Size of public key in bytes
 */ const PUBLIC_KEY_LENGTH = 32;
/**
 * Value to be converted into public key
 */ /**
 * JSON object representation of PublicKey class
 */ function isPublicKeyData(value) {
    return value._bn !== undefined;
}
// local counter used by PublicKey.unique()
let uniquePublicKeyCounter = 1;
/**
 * A public key
 */ class PublicKey extends Struct {
    /**
   * Create a new PublicKey object
   * @param value ed25519 public key as buffer or base-58 encoded string
   */ constructor(value){
        super({});
        /** @internal */ this._bn = void 0;
        if (isPublicKeyData(value)) this._bn = value._bn;
        else {
            if (typeof value === "string") {
                // assume base 58 encoding by default
                const decoded = (0, _bs58Default.default).decode(value);
                if (decoded.length != PUBLIC_KEY_LENGTH) throw new Error(`Invalid public key input`);
                this._bn = new (0, _bnJsDefault.default)(decoded);
            } else this._bn = new (0, _bnJsDefault.default)(value);
            if (this._bn.byteLength() > PUBLIC_KEY_LENGTH) throw new Error(`Invalid public key input`);
        }
    }
    /**
   * Returns a unique PublicKey for tests and benchmarks using a counter
   */ static unique() {
        const key = new PublicKey(uniquePublicKeyCounter);
        uniquePublicKeyCounter += 1;
        return new PublicKey(key.toBuffer());
    }
    /**
   * Default public key value. The base58-encoded string representation is all ones (as seen below)
   * The underlying BN number is 32 bytes that are all zeros
   */ /**
   * Checks if two publicKeys are equal
   */ equals(publicKey) {
        return this._bn.eq(publicKey._bn);
    }
    /**
   * Return the base-58 representation of the public key
   */ toBase58() {
        return (0, _bs58Default.default).encode(this.toBytes());
    }
    toJSON() {
        return this.toBase58();
    }
    /**
   * Return the byte array representation of the public key in big endian
   */ toBytes() {
        const buf = this.toBuffer();
        return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);
    }
    /**
   * Return the Buffer representation of the public key in big endian
   */ toBuffer() {
        const b = this._bn.toArrayLike((0, _buffer.Buffer));
        if (b.length === PUBLIC_KEY_LENGTH) return b;
        const zeroPad = (0, _buffer.Buffer).alloc(32);
        b.copy(zeroPad, 32 - b.length);
        return zeroPad;
    }
    get [Symbol.toStringTag]() {
        return `PublicKey(${this.toString()})`;
    }
    /**
   * Return the base-58 representation of the public key
   */ toString() {
        return this.toBase58();
    }
    /**
   * Derive a public key from another key, a seed, and a program ID.
   * The program ID will also serve as the owner of the public key, giving
   * it permission to write data to the account.
   */ /* eslint-disable require-await */ static async createWithSeed(fromPublicKey, seed, programId) {
        const buffer = (0, _buffer.Buffer).concat([
            fromPublicKey.toBuffer(),
            (0, _buffer.Buffer).from(seed),
            programId.toBuffer()
        ]);
        const publicKeyBytes = (0, _sha256.sha256)(buffer);
        return new PublicKey(publicKeyBytes);
    }
    /**
   * Derive a program address from seeds and a program ID.
   */ /* eslint-disable require-await */ static createProgramAddressSync(seeds, programId) {
        let buffer = (0, _buffer.Buffer).alloc(0);
        seeds.forEach(function(seed) {
            if (seed.length > MAX_SEED_LENGTH) throw new TypeError(`Max seed length exceeded`);
            buffer = (0, _buffer.Buffer).concat([
                buffer,
                toBuffer(seed)
            ]);
        });
        buffer = (0, _buffer.Buffer).concat([
            buffer,
            programId.toBuffer(),
            (0, _buffer.Buffer).from("ProgramDerivedAddress")
        ]);
        const publicKeyBytes = (0, _sha256.sha256)(buffer);
        if (isOnCurve(publicKeyBytes)) throw new Error(`Invalid seeds, address must fall off the curve`);
        return new PublicKey(publicKeyBytes);
    }
    /**
   * Async version of createProgramAddressSync
   * For backwards compatibility
   *
   * @deprecated Use {@link createProgramAddressSync} instead
   */ /* eslint-disable require-await */ static async createProgramAddress(seeds, programId) {
        return this.createProgramAddressSync(seeds, programId);
    }
    /**
   * Find a valid program address
   *
   * Valid program addresses must fall off the ed25519 curve.  This function
   * iterates a nonce until it finds one that when combined with the seeds
   * results in a valid program address.
   */ static findProgramAddressSync(seeds, programId) {
        let nonce = 255;
        let address;
        while(nonce != 0){
            try {
                const seedsWithNonce = seeds.concat((0, _buffer.Buffer).from([
                    nonce
                ]));
                address = this.createProgramAddressSync(seedsWithNonce, programId);
            } catch (err) {
                if (err instanceof TypeError) throw err;
                nonce--;
                continue;
            }
            return [
                address,
                nonce
            ];
        }
        throw new Error(`Unable to find a viable program address nonce`);
    }
    /**
   * Async version of findProgramAddressSync
   * For backwards compatibility
   *
   * @deprecated Use {@link findProgramAddressSync} instead
   */ static async findProgramAddress(seeds, programId) {
        return this.findProgramAddressSync(seeds, programId);
    }
    /**
   * Check that a pubkey is on the ed25519 curve.
   */ static isOnCurve(pubkeyData) {
        const pubkey = new PublicKey(pubkeyData);
        return isOnCurve(pubkey.toBytes());
    }
}
_PublicKey = PublicKey;
PublicKey.default = new _PublicKey("11111111111111111111111111111111");
SOLANA_SCHEMA.set(PublicKey, {
    kind: "struct",
    fields: [
        [
            "_bn",
            "u256"
        ]
    ]
});
/**
 * An account key pair (public and secret keys).
 *
 * @deprecated since v1.10.0, please use {@link Keypair} instead.
 */ class Account {
    /**
   * Create a new Account object
   *
   * If the secretKey parameter is not provided a new key pair is randomly
   * created for the account
   *
   * @param secretKey Secret key for the account
   */ constructor(secretKey){
        /** @internal */ this._publicKey = void 0;
        /** @internal */ this._secretKey = void 0;
        if (secretKey) {
            const secretKeyBuffer = toBuffer(secretKey);
            if (secretKey.length !== 64) throw new Error("bad secret key size");
            this._publicKey = secretKeyBuffer.slice(32, 64);
            this._secretKey = secretKeyBuffer.slice(0, 32);
        } else {
            this._secretKey = toBuffer(generatePrivateKey());
            this._publicKey = toBuffer(getPublicKey(this._secretKey));
        }
    }
    /**
   * The public key for this account
   */ get publicKey() {
        return new PublicKey(this._publicKey);
    }
    /**
   * The **unencrypted** secret key for this account. The first 32 bytes
   * is the private scalar and the last 32 bytes is the public key.
   * Read more: https://blog.mozilla.org/warner/2011/11/29/ed25519-keys/
   */ get secretKey() {
        return (0, _buffer.Buffer).concat([
            this._secretKey,
            this._publicKey
        ], 64);
    }
}
const BPF_LOADER_DEPRECATED_PROGRAM_ID = new PublicKey("BPFLoader1111111111111111111111111111111111");
/**
 * Maximum over-the-wire size of a Transaction
 *
 * 1280 is IPv6 minimum MTU
 * 40 bytes is the size of the IPv6 header
 * 8 bytes is the size of the fragment header
 */ const PACKET_DATA_SIZE = 1232;
const VERSION_PREFIX_MASK = 0x7f;
const SIGNATURE_LENGTH_IN_BYTES = 64;
class TransactionExpiredBlockheightExceededError extends Error {
    constructor(signature){
        super(`Signature ${signature} has expired: block height exceeded.`);
        this.signature = void 0;
        this.signature = signature;
    }
}
Object.defineProperty(TransactionExpiredBlockheightExceededError.prototype, "name", {
    value: "TransactionExpiredBlockheightExceededError"
});
class TransactionExpiredTimeoutError extends Error {
    constructor(signature, timeoutSeconds){
        super(`Transaction was not confirmed in ${timeoutSeconds.toFixed(2)} seconds. It is ` + "unknown if it succeeded or failed. Check signature " + `${signature} using the Solana Explorer or CLI tools.`);
        this.signature = void 0;
        this.signature = signature;
    }
}
Object.defineProperty(TransactionExpiredTimeoutError.prototype, "name", {
    value: "TransactionExpiredTimeoutError"
});
class TransactionExpiredNonceInvalidError extends Error {
    constructor(signature){
        super(`Signature ${signature} has expired: the nonce is no longer valid.`);
        this.signature = void 0;
        this.signature = signature;
    }
}
Object.defineProperty(TransactionExpiredNonceInvalidError.prototype, "name", {
    value: "TransactionExpiredNonceInvalidError"
});
class MessageAccountKeys {
    constructor(staticAccountKeys, accountKeysFromLookups){
        this.staticAccountKeys = void 0;
        this.accountKeysFromLookups = void 0;
        this.staticAccountKeys = staticAccountKeys;
        this.accountKeysFromLookups = accountKeysFromLookups;
    }
    keySegments() {
        const keySegments = [
            this.staticAccountKeys
        ];
        if (this.accountKeysFromLookups) {
            keySegments.push(this.accountKeysFromLookups.writable);
            keySegments.push(this.accountKeysFromLookups.readonly);
        }
        return keySegments;
    }
    get(index) {
        for (const keySegment of this.keySegments()){
            if (index < keySegment.length) return keySegment[index];
            else index -= keySegment.length;
        }
        return;
    }
    get length() {
        return this.keySegments().flat().length;
    }
    compileInstructions(instructions) {
        // Bail early if any account indexes would overflow a u8
        const U8_MAX = 255;
        if (this.length > U8_MAX + 1) throw new Error("Account index overflow encountered during compilation");
        const keyIndexMap = new Map();
        this.keySegments().flat().forEach((key, index)=>{
            keyIndexMap.set(key.toBase58(), index);
        });
        const findKeyIndex = (key)=>{
            const keyIndex = keyIndexMap.get(key.toBase58());
            if (keyIndex === undefined) throw new Error("Encountered an unknown instruction account key during compilation");
            return keyIndex;
        };
        return instructions.map((instruction)=>{
            return {
                programIdIndex: findKeyIndex(instruction.programId),
                accountKeyIndexes: instruction.keys.map((meta)=>findKeyIndex(meta.pubkey)),
                data: instruction.data
            };
        });
    }
}
/**
 * Layout for a public key
 */ const publicKey = (property = "publicKey")=>{
    return _bufferLayout.blob(32, property);
};
/**
 * Layout for a signature
 */ const signature = (property = "signature")=>{
    return _bufferLayout.blob(64, property);
};
/**
 * Layout for a Rust String type
 */ const rustString = (property = "string")=>{
    const rsl = _bufferLayout.struct([
        _bufferLayout.u32("length"),
        _bufferLayout.u32("lengthPadding"),
        _bufferLayout.blob(_bufferLayout.offset(_bufferLayout.u32(), -8), "chars")
    ], property);
    const _decode = rsl.decode.bind(rsl);
    const _encode = rsl.encode.bind(rsl);
    const rslShim = rsl;
    rslShim.decode = (b, offset)=>{
        const data = _decode(b, offset);
        return data["chars"].toString();
    };
    rslShim.encode = (str, b, offset)=>{
        const data = {
            chars: (0, _buffer.Buffer).from(str, "utf8")
        };
        return _encode(data, b, offset);
    };
    rslShim.alloc = (str)=>{
        return _bufferLayout.u32().span + _bufferLayout.u32().span + (0, _buffer.Buffer).from(str, "utf8").length;
    };
    return rslShim;
};
/**
 * Layout for an Authorized object
 */ const authorized = (property = "authorized")=>{
    return _bufferLayout.struct([
        publicKey("staker"),
        publicKey("withdrawer")
    ], property);
};
/**
 * Layout for a Lockup object
 */ const lockup = (property = "lockup")=>{
    return _bufferLayout.struct([
        _bufferLayout.ns64("unixTimestamp"),
        _bufferLayout.ns64("epoch"),
        publicKey("custodian")
    ], property);
};
/**
 *  Layout for a VoteInit object
 */ const voteInit = (property = "voteInit")=>{
    return _bufferLayout.struct([
        publicKey("nodePubkey"),
        publicKey("authorizedVoter"),
        publicKey("authorizedWithdrawer"),
        _bufferLayout.u8("commission")
    ], property);
};
/**
 *  Layout for a VoteAuthorizeWithSeedArgs object
 */ const voteAuthorizeWithSeedArgs = (property = "voteAuthorizeWithSeedArgs")=>{
    return _bufferLayout.struct([
        _bufferLayout.u32("voteAuthorizationType"),
        publicKey("currentAuthorityDerivedKeyOwnerPubkey"),
        rustString("currentAuthorityDerivedKeySeed"),
        publicKey("newAuthorized")
    ], property);
};
function getAlloc(type, fields) {
    const getItemAlloc = (item)=>{
        if (item.span >= 0) return item.span;
        else if (typeof item.alloc === "function") return item.alloc(fields[item.property]);
        else if ("count" in item && "elementLayout" in item) {
            const field = fields[item.property];
            if (Array.isArray(field)) return field.length * getItemAlloc(item.elementLayout);
        } else if ("fields" in item) // This is a `Structure` whose size needs to be recursively measured.
        return getAlloc({
            layout: item
        }, fields[item.property]);
        // Couldn't determine allocated size of layout
        return 0;
    };
    let alloc = 0;
    type.layout.fields.forEach((item)=>{
        alloc += getItemAlloc(item);
    });
    return alloc;
}
function decodeLength(bytes) {
    let len = 0;
    let size = 0;
    for(;;){
        let elem = bytes.shift();
        len |= (elem & 0x7f) << size * 7;
        size += 1;
        if ((elem & 0x80) === 0) break;
    }
    return len;
}
function encodeLength(bytes, len) {
    let rem_len = len;
    for(;;){
        let elem = rem_len & 0x7f;
        rem_len >>= 7;
        if (rem_len == 0) {
            bytes.push(elem);
            break;
        } else {
            elem |= 0x80;
            bytes.push(elem);
        }
    }
}
function assert(condition, message) {
    if (!condition) throw new Error(message || "Assertion failed");
}
class CompiledKeys {
    constructor(payer, keyMetaMap){
        this.payer = void 0;
        this.keyMetaMap = void 0;
        this.payer = payer;
        this.keyMetaMap = keyMetaMap;
    }
    static compile(instructions, payer) {
        const keyMetaMap = new Map();
        const getOrInsertDefault = (pubkey)=>{
            const address = pubkey.toBase58();
            let keyMeta = keyMetaMap.get(address);
            if (keyMeta === undefined) {
                keyMeta = {
                    isSigner: false,
                    isWritable: false,
                    isInvoked: false
                };
                keyMetaMap.set(address, keyMeta);
            }
            return keyMeta;
        };
        const payerKeyMeta = getOrInsertDefault(payer);
        payerKeyMeta.isSigner = true;
        payerKeyMeta.isWritable = true;
        for (const ix of instructions){
            getOrInsertDefault(ix.programId).isInvoked = true;
            for (const accountMeta of ix.keys){
                const keyMeta = getOrInsertDefault(accountMeta.pubkey);
                keyMeta.isSigner ||= accountMeta.isSigner;
                keyMeta.isWritable ||= accountMeta.isWritable;
            }
        }
        return new CompiledKeys(payer, keyMetaMap);
    }
    getMessageComponents() {
        const mapEntries = [
            ...this.keyMetaMap.entries()
        ];
        assert(mapEntries.length <= 256, "Max static account keys length exceeded");
        const writableSigners = mapEntries.filter(([, meta])=>meta.isSigner && meta.isWritable);
        const readonlySigners = mapEntries.filter(([, meta])=>meta.isSigner && !meta.isWritable);
        const writableNonSigners = mapEntries.filter(([, meta])=>!meta.isSigner && meta.isWritable);
        const readonlyNonSigners = mapEntries.filter(([, meta])=>!meta.isSigner && !meta.isWritable);
        const header = {
            numRequiredSignatures: writableSigners.length + readonlySigners.length,
            numReadonlySignedAccounts: readonlySigners.length,
            numReadonlyUnsignedAccounts: readonlyNonSigners.length
        };
        // sanity checks
        {
            assert(writableSigners.length > 0, "Expected at least one writable signer key");
            const [payerAddress] = writableSigners[0];
            assert(payerAddress === this.payer.toBase58(), "Expected first writable signer key to be the fee payer");
        }
        const staticAccountKeys = [
            ...writableSigners.map(([address])=>new PublicKey(address)),
            ...readonlySigners.map(([address])=>new PublicKey(address)),
            ...writableNonSigners.map(([address])=>new PublicKey(address)),
            ...readonlyNonSigners.map(([address])=>new PublicKey(address))
        ];
        return [
            header,
            staticAccountKeys
        ];
    }
    extractTableLookup(lookupTable) {
        const [writableIndexes, drainedWritableKeys] = this.drainKeysFoundInLookupTable(lookupTable.state.addresses, (keyMeta)=>!keyMeta.isSigner && !keyMeta.isInvoked && keyMeta.isWritable);
        const [readonlyIndexes, drainedReadonlyKeys] = this.drainKeysFoundInLookupTable(lookupTable.state.addresses, (keyMeta)=>!keyMeta.isSigner && !keyMeta.isInvoked && !keyMeta.isWritable);
        // Don't extract lookup if no keys were found
        if (writableIndexes.length === 0 && readonlyIndexes.length === 0) return;
        return [
            {
                accountKey: lookupTable.key,
                writableIndexes,
                readonlyIndexes
            },
            {
                writable: drainedWritableKeys,
                readonly: drainedReadonlyKeys
            }
        ];
    }
    /** @internal */ drainKeysFoundInLookupTable(lookupTableEntries, keyMetaFilter) {
        const lookupTableIndexes = new Array();
        const drainedKeys = new Array();
        for (const [address, keyMeta] of this.keyMetaMap.entries())if (keyMetaFilter(keyMeta)) {
            const key = new PublicKey(address);
            const lookupTableIndex = lookupTableEntries.findIndex((entry)=>entry.equals(key));
            if (lookupTableIndex >= 0) {
                assert(lookupTableIndex < 256, "Max lookup table index exceeded");
                lookupTableIndexes.push(lookupTableIndex);
                drainedKeys.push(key);
                this.keyMetaMap.delete(address);
            }
        }
        return [
            lookupTableIndexes,
            drainedKeys
        ];
    }
}
const END_OF_BUFFER_ERROR_MESSAGE = "Reached end of buffer unexpectedly";
/**
 * Delegates to `Array#shift`, but throws if the array is zero-length.
 */ function guardedShift(byteArray) {
    if (byteArray.length === 0) throw new Error(END_OF_BUFFER_ERROR_MESSAGE);
    return byteArray.shift();
}
/**
 * Delegates to `Array#splice`, but throws if the section being spliced out extends past the end of
 * the array.
 */ function guardedSplice(byteArray, ...args) {
    const [start] = args;
    if (args.length === 2 // Implies that `deleteCount` was supplied
     ? start + (args[1] ?? 0) > byteArray.length : start >= byteArray.length) throw new Error(END_OF_BUFFER_ERROR_MESSAGE);
    return byteArray.splice(...args);
}
/**
 * An instruction to execute by a program
 *
 * @property {number} programIdIndex
 * @property {number[]} accounts
 * @property {string} data
 */ /**
 * Message constructor arguments
 */ /**
 * List of instructions to be processed atomically
 */ class Message {
    constructor(args){
        this.header = void 0;
        this.accountKeys = void 0;
        this.recentBlockhash = void 0;
        this.instructions = void 0;
        this.indexToProgramIds = new Map();
        this.header = args.header;
        this.accountKeys = args.accountKeys.map((account)=>new PublicKey(account));
        this.recentBlockhash = args.recentBlockhash;
        this.instructions = args.instructions;
        this.instructions.forEach((ix)=>this.indexToProgramIds.set(ix.programIdIndex, this.accountKeys[ix.programIdIndex]));
    }
    get version() {
        return "legacy";
    }
    get staticAccountKeys() {
        return this.accountKeys;
    }
    get compiledInstructions() {
        return this.instructions.map((ix)=>({
                programIdIndex: ix.programIdIndex,
                accountKeyIndexes: ix.accounts,
                data: (0, _bs58Default.default).decode(ix.data)
            }));
    }
    get addressTableLookups() {
        return [];
    }
    getAccountKeys() {
        return new MessageAccountKeys(this.staticAccountKeys);
    }
    static compile(args) {
        const compiledKeys = CompiledKeys.compile(args.instructions, args.payerKey);
        const [header, staticAccountKeys] = compiledKeys.getMessageComponents();
        const accountKeys = new MessageAccountKeys(staticAccountKeys);
        const instructions = accountKeys.compileInstructions(args.instructions).map((ix)=>({
                programIdIndex: ix.programIdIndex,
                accounts: ix.accountKeyIndexes,
                data: (0, _bs58Default.default).encode(ix.data)
            }));
        return new Message({
            header,
            accountKeys: staticAccountKeys,
            recentBlockhash: args.recentBlockhash,
            instructions
        });
    }
    isAccountSigner(index) {
        return index < this.header.numRequiredSignatures;
    }
    isAccountWritable(index) {
        const numSignedAccounts = this.header.numRequiredSignatures;
        if (index >= this.header.numRequiredSignatures) {
            const unsignedAccountIndex = index - numSignedAccounts;
            const numUnsignedAccounts = this.accountKeys.length - numSignedAccounts;
            const numWritableUnsignedAccounts = numUnsignedAccounts - this.header.numReadonlyUnsignedAccounts;
            return unsignedAccountIndex < numWritableUnsignedAccounts;
        } else {
            const numWritableSignedAccounts = numSignedAccounts - this.header.numReadonlySignedAccounts;
            return index < numWritableSignedAccounts;
        }
    }
    isProgramId(index) {
        return this.indexToProgramIds.has(index);
    }
    programIds() {
        return [
            ...this.indexToProgramIds.values()
        ];
    }
    nonProgramIds() {
        return this.accountKeys.filter((_, index)=>!this.isProgramId(index));
    }
    serialize() {
        const numKeys = this.accountKeys.length;
        let keyCount = [];
        encodeLength(keyCount, numKeys);
        const instructions = this.instructions.map((instruction)=>{
            const { accounts, programIdIndex } = instruction;
            const data = Array.from((0, _bs58Default.default).decode(instruction.data));
            let keyIndicesCount = [];
            encodeLength(keyIndicesCount, accounts.length);
            let dataCount = [];
            encodeLength(dataCount, data.length);
            return {
                programIdIndex,
                keyIndicesCount: (0, _buffer.Buffer).from(keyIndicesCount),
                keyIndices: accounts,
                dataLength: (0, _buffer.Buffer).from(dataCount),
                data
            };
        });
        let instructionCount = [];
        encodeLength(instructionCount, instructions.length);
        let instructionBuffer = (0, _buffer.Buffer).alloc(PACKET_DATA_SIZE);
        (0, _buffer.Buffer).from(instructionCount).copy(instructionBuffer);
        let instructionBufferLength = instructionCount.length;
        instructions.forEach((instruction)=>{
            const instructionLayout = _bufferLayout.struct([
                _bufferLayout.u8("programIdIndex"),
                _bufferLayout.blob(instruction.keyIndicesCount.length, "keyIndicesCount"),
                _bufferLayout.seq(_bufferLayout.u8("keyIndex"), instruction.keyIndices.length, "keyIndices"),
                _bufferLayout.blob(instruction.dataLength.length, "dataLength"),
                _bufferLayout.seq(_bufferLayout.u8("userdatum"), instruction.data.length, "data")
            ]);
            const length = instructionLayout.encode(instruction, instructionBuffer, instructionBufferLength);
            instructionBufferLength += length;
        });
        instructionBuffer = instructionBuffer.slice(0, instructionBufferLength);
        const signDataLayout = _bufferLayout.struct([
            _bufferLayout.blob(1, "numRequiredSignatures"),
            _bufferLayout.blob(1, "numReadonlySignedAccounts"),
            _bufferLayout.blob(1, "numReadonlyUnsignedAccounts"),
            _bufferLayout.blob(keyCount.length, "keyCount"),
            _bufferLayout.seq(publicKey("key"), numKeys, "keys"),
            publicKey("recentBlockhash")
        ]);
        const transaction = {
            numRequiredSignatures: (0, _buffer.Buffer).from([
                this.header.numRequiredSignatures
            ]),
            numReadonlySignedAccounts: (0, _buffer.Buffer).from([
                this.header.numReadonlySignedAccounts
            ]),
            numReadonlyUnsignedAccounts: (0, _buffer.Buffer).from([
                this.header.numReadonlyUnsignedAccounts
            ]),
            keyCount: (0, _buffer.Buffer).from(keyCount),
            keys: this.accountKeys.map((key)=>toBuffer(key.toBytes())),
            recentBlockhash: (0, _bs58Default.default).decode(this.recentBlockhash)
        };
        let signData = (0, _buffer.Buffer).alloc(2048);
        const length = signDataLayout.encode(transaction, signData);
        instructionBuffer.copy(signData, length);
        return signData.slice(0, length + instructionBuffer.length);
    }
    /**
   * Decode a compiled message into a Message object.
   */ static from(buffer) {
        // Slice up wire data
        let byteArray = [
            ...buffer
        ];
        const numRequiredSignatures = guardedShift(byteArray);
        if (numRequiredSignatures !== (numRequiredSignatures & VERSION_PREFIX_MASK)) throw new Error("Versioned messages must be deserialized with VersionedMessage.deserialize()");
        const numReadonlySignedAccounts = guardedShift(byteArray);
        const numReadonlyUnsignedAccounts = guardedShift(byteArray);
        const accountCount = decodeLength(byteArray);
        let accountKeys = [];
        for(let i = 0; i < accountCount; i++){
            const account = guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH);
            accountKeys.push(new PublicKey((0, _buffer.Buffer).from(account)));
        }
        const recentBlockhash = guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH);
        const instructionCount = decodeLength(byteArray);
        let instructions = [];
        for(let i = 0; i < instructionCount; i++){
            const programIdIndex = guardedShift(byteArray);
            const accountCount = decodeLength(byteArray);
            const accounts = guardedSplice(byteArray, 0, accountCount);
            const dataLength = decodeLength(byteArray);
            const dataSlice = guardedSplice(byteArray, 0, dataLength);
            const data = (0, _bs58Default.default).encode((0, _buffer.Buffer).from(dataSlice));
            instructions.push({
                programIdIndex,
                accounts,
                data
            });
        }
        const messageArgs = {
            header: {
                numRequiredSignatures,
                numReadonlySignedAccounts,
                numReadonlyUnsignedAccounts
            },
            recentBlockhash: (0, _bs58Default.default).encode((0, _buffer.Buffer).from(recentBlockhash)),
            accountKeys,
            instructions
        };
        return new Message(messageArgs);
    }
}
/**
 * Message constructor arguments
 */ class MessageV0 {
    constructor(args){
        this.header = void 0;
        this.staticAccountKeys = void 0;
        this.recentBlockhash = void 0;
        this.compiledInstructions = void 0;
        this.addressTableLookups = void 0;
        this.header = args.header;
        this.staticAccountKeys = args.staticAccountKeys;
        this.recentBlockhash = args.recentBlockhash;
        this.compiledInstructions = args.compiledInstructions;
        this.addressTableLookups = args.addressTableLookups;
    }
    get version() {
        return 0;
    }
    get numAccountKeysFromLookups() {
        let count = 0;
        for (const lookup of this.addressTableLookups)count += lookup.readonlyIndexes.length + lookup.writableIndexes.length;
        return count;
    }
    getAccountKeys(args) {
        let accountKeysFromLookups;
        if (args && "accountKeysFromLookups" in args && args.accountKeysFromLookups) {
            if (this.numAccountKeysFromLookups != args.accountKeysFromLookups.writable.length + args.accountKeysFromLookups.readonly.length) throw new Error("Failed to get account keys because of a mismatch in the number of account keys from lookups");
            accountKeysFromLookups = args.accountKeysFromLookups;
        } else if (args && "addressLookupTableAccounts" in args && args.addressLookupTableAccounts) accountKeysFromLookups = this.resolveAddressTableLookups(args.addressLookupTableAccounts);
        else if (this.addressTableLookups.length > 0) throw new Error("Failed to get account keys because address table lookups were not resolved");
        return new MessageAccountKeys(this.staticAccountKeys, accountKeysFromLookups);
    }
    isAccountSigner(index) {
        return index < this.header.numRequiredSignatures;
    }
    isAccountWritable(index) {
        const numSignedAccounts = this.header.numRequiredSignatures;
        const numStaticAccountKeys = this.staticAccountKeys.length;
        if (index >= numStaticAccountKeys) {
            const lookupAccountKeysIndex = index - numStaticAccountKeys;
            const numWritableLookupAccountKeys = this.addressTableLookups.reduce((count, lookup)=>count + lookup.writableIndexes.length, 0);
            return lookupAccountKeysIndex < numWritableLookupAccountKeys;
        } else if (index >= this.header.numRequiredSignatures) {
            const unsignedAccountIndex = index - numSignedAccounts;
            const numUnsignedAccounts = numStaticAccountKeys - numSignedAccounts;
            const numWritableUnsignedAccounts = numUnsignedAccounts - this.header.numReadonlyUnsignedAccounts;
            return unsignedAccountIndex < numWritableUnsignedAccounts;
        } else {
            const numWritableSignedAccounts = numSignedAccounts - this.header.numReadonlySignedAccounts;
            return index < numWritableSignedAccounts;
        }
    }
    resolveAddressTableLookups(addressLookupTableAccounts) {
        const accountKeysFromLookups = {
            writable: [],
            readonly: []
        };
        for (const tableLookup of this.addressTableLookups){
            const tableAccount = addressLookupTableAccounts.find((account)=>account.key.equals(tableLookup.accountKey));
            if (!tableAccount) throw new Error(`Failed to find address lookup table account for table key ${tableLookup.accountKey.toBase58()}`);
            for (const index of tableLookup.writableIndexes){
                if (index < tableAccount.state.addresses.length) accountKeysFromLookups.writable.push(tableAccount.state.addresses[index]);
                else throw new Error(`Failed to find address for index ${index} in address lookup table ${tableLookup.accountKey.toBase58()}`);
            }
            for (const index of tableLookup.readonlyIndexes){
                if (index < tableAccount.state.addresses.length) accountKeysFromLookups.readonly.push(tableAccount.state.addresses[index]);
                else throw new Error(`Failed to find address for index ${index} in address lookup table ${tableLookup.accountKey.toBase58()}`);
            }
        }
        return accountKeysFromLookups;
    }
    static compile(args) {
        const compiledKeys = CompiledKeys.compile(args.instructions, args.payerKey);
        const addressTableLookups = new Array();
        const accountKeysFromLookups = {
            writable: new Array(),
            readonly: new Array()
        };
        const lookupTableAccounts = args.addressLookupTableAccounts || [];
        for (const lookupTable of lookupTableAccounts){
            const extractResult = compiledKeys.extractTableLookup(lookupTable);
            if (extractResult !== undefined) {
                const [addressTableLookup, { writable, readonly }] = extractResult;
                addressTableLookups.push(addressTableLookup);
                accountKeysFromLookups.writable.push(...writable);
                accountKeysFromLookups.readonly.push(...readonly);
            }
        }
        const [header, staticAccountKeys] = compiledKeys.getMessageComponents();
        const accountKeys = new MessageAccountKeys(staticAccountKeys, accountKeysFromLookups);
        const compiledInstructions = accountKeys.compileInstructions(args.instructions);
        return new MessageV0({
            header,
            staticAccountKeys,
            recentBlockhash: args.recentBlockhash,
            compiledInstructions,
            addressTableLookups
        });
    }
    serialize() {
        const encodedStaticAccountKeysLength = Array();
        encodeLength(encodedStaticAccountKeysLength, this.staticAccountKeys.length);
        const serializedInstructions = this.serializeInstructions();
        const encodedInstructionsLength = Array();
        encodeLength(encodedInstructionsLength, this.compiledInstructions.length);
        const serializedAddressTableLookups = this.serializeAddressTableLookups();
        const encodedAddressTableLookupsLength = Array();
        encodeLength(encodedAddressTableLookupsLength, this.addressTableLookups.length);
        const messageLayout = _bufferLayout.struct([
            _bufferLayout.u8("prefix"),
            _bufferLayout.struct([
                _bufferLayout.u8("numRequiredSignatures"),
                _bufferLayout.u8("numReadonlySignedAccounts"),
                _bufferLayout.u8("numReadonlyUnsignedAccounts")
            ], "header"),
            _bufferLayout.blob(encodedStaticAccountKeysLength.length, "staticAccountKeysLength"),
            _bufferLayout.seq(publicKey(), this.staticAccountKeys.length, "staticAccountKeys"),
            publicKey("recentBlockhash"),
            _bufferLayout.blob(encodedInstructionsLength.length, "instructionsLength"),
            _bufferLayout.blob(serializedInstructions.length, "serializedInstructions"),
            _bufferLayout.blob(encodedAddressTableLookupsLength.length, "addressTableLookupsLength"),
            _bufferLayout.blob(serializedAddressTableLookups.length, "serializedAddressTableLookups")
        ]);
        const serializedMessage = new Uint8Array(PACKET_DATA_SIZE);
        const MESSAGE_VERSION_0_PREFIX = 128;
        const serializedMessageLength = messageLayout.encode({
            prefix: MESSAGE_VERSION_0_PREFIX,
            header: this.header,
            staticAccountKeysLength: new Uint8Array(encodedStaticAccountKeysLength),
            staticAccountKeys: this.staticAccountKeys.map((key)=>key.toBytes()),
            recentBlockhash: (0, _bs58Default.default).decode(this.recentBlockhash),
            instructionsLength: new Uint8Array(encodedInstructionsLength),
            serializedInstructions,
            addressTableLookupsLength: new Uint8Array(encodedAddressTableLookupsLength),
            serializedAddressTableLookups
        }, serializedMessage);
        return serializedMessage.slice(0, serializedMessageLength);
    }
    serializeInstructions() {
        let serializedLength = 0;
        const serializedInstructions = new Uint8Array(PACKET_DATA_SIZE);
        for (const instruction of this.compiledInstructions){
            const encodedAccountKeyIndexesLength = Array();
            encodeLength(encodedAccountKeyIndexesLength, instruction.accountKeyIndexes.length);
            const encodedDataLength = Array();
            encodeLength(encodedDataLength, instruction.data.length);
            const instructionLayout = _bufferLayout.struct([
                _bufferLayout.u8("programIdIndex"),
                _bufferLayout.blob(encodedAccountKeyIndexesLength.length, "encodedAccountKeyIndexesLength"),
                _bufferLayout.seq(_bufferLayout.u8(), instruction.accountKeyIndexes.length, "accountKeyIndexes"),
                _bufferLayout.blob(encodedDataLength.length, "encodedDataLength"),
                _bufferLayout.blob(instruction.data.length, "data")
            ]);
            serializedLength += instructionLayout.encode({
                programIdIndex: instruction.programIdIndex,
                encodedAccountKeyIndexesLength: new Uint8Array(encodedAccountKeyIndexesLength),
                accountKeyIndexes: instruction.accountKeyIndexes,
                encodedDataLength: new Uint8Array(encodedDataLength),
                data: instruction.data
            }, serializedInstructions, serializedLength);
        }
        return serializedInstructions.slice(0, serializedLength);
    }
    serializeAddressTableLookups() {
        let serializedLength = 0;
        const serializedAddressTableLookups = new Uint8Array(PACKET_DATA_SIZE);
        for (const lookup of this.addressTableLookups){
            const encodedWritableIndexesLength = Array();
            encodeLength(encodedWritableIndexesLength, lookup.writableIndexes.length);
            const encodedReadonlyIndexesLength = Array();
            encodeLength(encodedReadonlyIndexesLength, lookup.readonlyIndexes.length);
            const addressTableLookupLayout = _bufferLayout.struct([
                publicKey("accountKey"),
                _bufferLayout.blob(encodedWritableIndexesLength.length, "encodedWritableIndexesLength"),
                _bufferLayout.seq(_bufferLayout.u8(), lookup.writableIndexes.length, "writableIndexes"),
                _bufferLayout.blob(encodedReadonlyIndexesLength.length, "encodedReadonlyIndexesLength"),
                _bufferLayout.seq(_bufferLayout.u8(), lookup.readonlyIndexes.length, "readonlyIndexes")
            ]);
            serializedLength += addressTableLookupLayout.encode({
                accountKey: lookup.accountKey.toBytes(),
                encodedWritableIndexesLength: new Uint8Array(encodedWritableIndexesLength),
                writableIndexes: lookup.writableIndexes,
                encodedReadonlyIndexesLength: new Uint8Array(encodedReadonlyIndexesLength),
                readonlyIndexes: lookup.readonlyIndexes
            }, serializedAddressTableLookups, serializedLength);
        }
        return serializedAddressTableLookups.slice(0, serializedLength);
    }
    static deserialize(serializedMessage) {
        let byteArray = [
            ...serializedMessage
        ];
        const prefix = guardedShift(byteArray);
        const maskedPrefix = prefix & VERSION_PREFIX_MASK;
        assert(prefix !== maskedPrefix, `Expected versioned message but received legacy message`);
        const version = maskedPrefix;
        assert(version === 0, `Expected versioned message with version 0 but found version ${version}`);
        const header = {
            numRequiredSignatures: guardedShift(byteArray),
            numReadonlySignedAccounts: guardedShift(byteArray),
            numReadonlyUnsignedAccounts: guardedShift(byteArray)
        };
        const staticAccountKeys = [];
        const staticAccountKeysLength = decodeLength(byteArray);
        for(let i = 0; i < staticAccountKeysLength; i++)staticAccountKeys.push(new PublicKey(guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH)));
        const recentBlockhash = (0, _bs58Default.default).encode(guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH));
        const instructionCount = decodeLength(byteArray);
        const compiledInstructions = [];
        for(let i = 0; i < instructionCount; i++){
            const programIdIndex = guardedShift(byteArray);
            const accountKeyIndexesLength = decodeLength(byteArray);
            const accountKeyIndexes = guardedSplice(byteArray, 0, accountKeyIndexesLength);
            const dataLength = decodeLength(byteArray);
            const data = new Uint8Array(guardedSplice(byteArray, 0, dataLength));
            compiledInstructions.push({
                programIdIndex,
                accountKeyIndexes,
                data
            });
        }
        const addressTableLookupsCount = decodeLength(byteArray);
        const addressTableLookups = [];
        for(let i = 0; i < addressTableLookupsCount; i++){
            const accountKey = new PublicKey(guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH));
            const writableIndexesLength = decodeLength(byteArray);
            const writableIndexes = guardedSplice(byteArray, 0, writableIndexesLength);
            const readonlyIndexesLength = decodeLength(byteArray);
            const readonlyIndexes = guardedSplice(byteArray, 0, readonlyIndexesLength);
            addressTableLookups.push({
                accountKey,
                writableIndexes,
                readonlyIndexes
            });
        }
        return new MessageV0({
            header,
            staticAccountKeys,
            recentBlockhash,
            compiledInstructions,
            addressTableLookups
        });
    }
}
// eslint-disable-next-line no-redeclare
const VersionedMessage = {
    deserializeMessageVersion (serializedMessage) {
        const prefix = serializedMessage[0];
        const maskedPrefix = prefix & VERSION_PREFIX_MASK;
        // if the highest bit of the prefix is not set, the message is not versioned
        if (maskedPrefix === prefix) return "legacy";
        // the lower 7 bits of the prefix indicate the message version
        return maskedPrefix;
    },
    deserialize: (serializedMessage)=>{
        const version = VersionedMessage.deserializeMessageVersion(serializedMessage);
        if (version === "legacy") return Message.from(serializedMessage);
        if (version === 0) return MessageV0.deserialize(serializedMessage);
        else throw new Error(`Transaction message version ${version} deserialization is not supported`);
    }
};
/** @internal */ /**
 * Transaction signature as base-58 encoded string
 */ let TransactionStatus = /*#__PURE__*/ function(TransactionStatus) {
    TransactionStatus[TransactionStatus["BLOCKHEIGHT_EXCEEDED"] = 0] = "BLOCKHEIGHT_EXCEEDED";
    TransactionStatus[TransactionStatus["PROCESSED"] = 1] = "PROCESSED";
    TransactionStatus[TransactionStatus["TIMED_OUT"] = 2] = "TIMED_OUT";
    TransactionStatus[TransactionStatus["NONCE_INVALID"] = 3] = "NONCE_INVALID";
    return TransactionStatus;
}({});
/**
 * Default (empty) signature
 */ const DEFAULT_SIGNATURE = (0, _buffer.Buffer).alloc(SIGNATURE_LENGTH_IN_BYTES).fill(0);
/**
 * Account metadata used to define instructions
 */ /**
 * List of TransactionInstruction object fields that may be initialized at construction
 */ /**
 * Configuration object for Transaction.serialize()
 */ /**
 * @internal
 */ /**
 * Transaction Instruction class
 */ class TransactionInstruction {
    constructor(opts){
        /**
     * Public keys to include in this transaction
     * Boolean represents whether this pubkey needs to sign the transaction
     */ this.keys = void 0;
        /**
     * Program Id to execute
     */ this.programId = void 0;
        /**
     * Program input
     */ this.data = (0, _buffer.Buffer).alloc(0);
        this.programId = opts.programId;
        this.keys = opts.keys;
        if (opts.data) this.data = opts.data;
    }
    /**
   * @internal
   */ toJSON() {
        return {
            keys: this.keys.map(({ pubkey, isSigner, isWritable })=>({
                    pubkey: pubkey.toJSON(),
                    isSigner,
                    isWritable
                })),
            programId: this.programId.toJSON(),
            data: [
                ...this.data
            ]
        };
    }
}
/**
 * Pair of signature and corresponding public key
 */ /**
 * List of Transaction object fields that may be initialized at construction
 */ // For backward compatibility; an unfortunate consequence of being
// forced to over-export types by the documentation generator.
// See https://github.com/solana-labs/solana/pull/25820
/**
 * Blockhash-based transactions have a lifetime that are defined by
 * the blockhash they include. Any transaction whose blockhash is
 * too old will be rejected.
 */ /**
 * Use these options to construct a durable nonce transaction.
 */ /**
 * Nonce information to be used to build an offline Transaction.
 */ /**
 * @internal
 */ /**
 * Transaction class
 */ class Transaction {
    /**
   * The first (payer) Transaction signature
   *
   * @returns {Buffer | null} Buffer of payer's signature
   */ get signature() {
        if (this.signatures.length > 0) return this.signatures[0].signature;
        return null;
    }
    /**
   * The transaction fee payer
   */ // Construct a transaction with a blockhash and lastValidBlockHeight
    // Construct a transaction using a durable nonce
    /**
   * @deprecated `TransactionCtorFields` has been deprecated and will be removed in a future version.
   * Please supply a `TransactionBlockhashCtor` instead.
   */ /**
   * Construct an empty Transaction
   */ constructor(opts){
        /**
     * Signatures for the transaction.  Typically created by invoking the
     * `sign()` method
     */ this.signatures = [];
        this.feePayer = void 0;
        /**
     * The instructions to atomically execute
     */ this.instructions = [];
        /**
     * A recent transaction id. Must be populated by the caller
     */ this.recentBlockhash = void 0;
        /**
     * the last block chain can advance to before tx is declared expired
     * */ this.lastValidBlockHeight = void 0;
        /**
     * Optional Nonce information. If populated, transaction will use a durable
     * Nonce hash instead of a recentBlockhash. Must be populated by the caller
     */ this.nonceInfo = void 0;
        /**
     * If this is a nonce transaction this represents the minimum slot from which
     * to evaluate if the nonce has advanced when attempting to confirm the
     * transaction. This protects against a case where the transaction confirmation
     * logic loads the nonce account from an old slot and assumes the mismatch in
     * nonce value implies that the nonce has been advanced.
     */ this.minNonceContextSlot = void 0;
        /**
     * @internal
     */ this._message = void 0;
        /**
     * @internal
     */ this._json = void 0;
        if (!opts) return;
        if (opts.feePayer) this.feePayer = opts.feePayer;
        if (opts.signatures) this.signatures = opts.signatures;
        if (Object.prototype.hasOwnProperty.call(opts, "nonceInfo")) {
            const { minContextSlot, nonceInfo } = opts;
            this.minNonceContextSlot = minContextSlot;
            this.nonceInfo = nonceInfo;
        } else if (Object.prototype.hasOwnProperty.call(opts, "lastValidBlockHeight")) {
            const { blockhash, lastValidBlockHeight } = opts;
            this.recentBlockhash = blockhash;
            this.lastValidBlockHeight = lastValidBlockHeight;
        } else {
            const { recentBlockhash, nonceInfo } = opts;
            if (nonceInfo) this.nonceInfo = nonceInfo;
            this.recentBlockhash = recentBlockhash;
        }
    }
    /**
   * @internal
   */ toJSON() {
        return {
            recentBlockhash: this.recentBlockhash || null,
            feePayer: this.feePayer ? this.feePayer.toJSON() : null,
            nonceInfo: this.nonceInfo ? {
                nonce: this.nonceInfo.nonce,
                nonceInstruction: this.nonceInfo.nonceInstruction.toJSON()
            } : null,
            instructions: this.instructions.map((instruction)=>instruction.toJSON()),
            signers: this.signatures.map(({ publicKey })=>{
                return publicKey.toJSON();
            })
        };
    }
    /**
   * Add one or more instructions to this Transaction
   *
   * @param {Array< Transaction | TransactionInstruction | TransactionInstructionCtorFields >} items - Instructions to add to the Transaction
   */ add(...items) {
        if (items.length === 0) throw new Error("No instructions");
        items.forEach((item)=>{
            if ("instructions" in item) this.instructions = this.instructions.concat(item.instructions);
            else if ("data" in item && "programId" in item && "keys" in item) this.instructions.push(item);
            else this.instructions.push(new TransactionInstruction(item));
        });
        return this;
    }
    /**
   * Compile transaction data
   */ compileMessage() {
        if (this._message && JSON.stringify(this.toJSON()) === JSON.stringify(this._json)) return this._message;
        let recentBlockhash;
        let instructions;
        if (this.nonceInfo) {
            recentBlockhash = this.nonceInfo.nonce;
            if (this.instructions[0] != this.nonceInfo.nonceInstruction) instructions = [
                this.nonceInfo.nonceInstruction,
                ...this.instructions
            ];
            else instructions = this.instructions;
        } else {
            recentBlockhash = this.recentBlockhash;
            instructions = this.instructions;
        }
        if (!recentBlockhash) throw new Error("Transaction recentBlockhash required");
        if (instructions.length < 1) console.warn("No instructions provided");
        let feePayer;
        if (this.feePayer) feePayer = this.feePayer;
        else if (this.signatures.length > 0 && this.signatures[0].publicKey) // Use implicit fee payer
        feePayer = this.signatures[0].publicKey;
        else throw new Error("Transaction fee payer required");
        for(let i = 0; i < instructions.length; i++){
            if (instructions[i].programId === undefined) throw new Error(`Transaction instruction index ${i} has undefined program id`);
        }
        const programIds = [];
        const accountMetas = [];
        instructions.forEach((instruction)=>{
            instruction.keys.forEach((accountMeta)=>{
                accountMetas.push({
                    ...accountMeta
                });
            });
            const programId = instruction.programId.toString();
            if (!programIds.includes(programId)) programIds.push(programId);
        });
        // Append programID account metas
        programIds.forEach((programId)=>{
            accountMetas.push({
                pubkey: new PublicKey(programId),
                isSigner: false,
                isWritable: false
            });
        });
        // Cull duplicate account metas
        const uniqueMetas = [];
        accountMetas.forEach((accountMeta)=>{
            const pubkeyString = accountMeta.pubkey.toString();
            const uniqueIndex = uniqueMetas.findIndex((x)=>{
                return x.pubkey.toString() === pubkeyString;
            });
            if (uniqueIndex > -1) {
                uniqueMetas[uniqueIndex].isWritable = uniqueMetas[uniqueIndex].isWritable || accountMeta.isWritable;
                uniqueMetas[uniqueIndex].isSigner = uniqueMetas[uniqueIndex].isSigner || accountMeta.isSigner;
            } else uniqueMetas.push(accountMeta);
        });
        // Sort. Prioritizing first by signer, then by writable
        uniqueMetas.sort(function(x, y) {
            if (x.isSigner !== y.isSigner) // Signers always come before non-signers
            return x.isSigner ? -1 : 1;
            if (x.isWritable !== y.isWritable) // Writable accounts always come before read-only accounts
            return x.isWritable ? -1 : 1;
            // Otherwise, sort by pubkey, stringwise.
            const options = {
                localeMatcher: "best fit",
                usage: "sort",
                sensitivity: "variant",
                ignorePunctuation: false,
                numeric: false,
                caseFirst: "lower"
            };
            return x.pubkey.toBase58().localeCompare(y.pubkey.toBase58(), "en", options);
        });
        // Move fee payer to the front
        const feePayerIndex = uniqueMetas.findIndex((x)=>{
            return x.pubkey.equals(feePayer);
        });
        if (feePayerIndex > -1) {
            const [payerMeta] = uniqueMetas.splice(feePayerIndex, 1);
            payerMeta.isSigner = true;
            payerMeta.isWritable = true;
            uniqueMetas.unshift(payerMeta);
        } else uniqueMetas.unshift({
            pubkey: feePayer,
            isSigner: true,
            isWritable: true
        });
        // Disallow unknown signers
        for (const signature of this.signatures){
            const uniqueIndex = uniqueMetas.findIndex((x)=>{
                return x.pubkey.equals(signature.publicKey);
            });
            if (uniqueIndex > -1) {
                if (!uniqueMetas[uniqueIndex].isSigner) {
                    uniqueMetas[uniqueIndex].isSigner = true;
                    console.warn("Transaction references a signature that is unnecessary, only the fee payer and instruction signer accounts should sign a transaction. This behavior is deprecated and will throw an error in the next major version release.");
                }
            } else throw new Error(`unknown signer: ${signature.publicKey.toString()}`);
        }
        let numRequiredSignatures = 0;
        let numReadonlySignedAccounts = 0;
        let numReadonlyUnsignedAccounts = 0;
        // Split out signing from non-signing keys and count header values
        const signedKeys = [];
        const unsignedKeys = [];
        uniqueMetas.forEach(({ pubkey, isSigner, isWritable })=>{
            if (isSigner) {
                signedKeys.push(pubkey.toString());
                numRequiredSignatures += 1;
                if (!isWritable) numReadonlySignedAccounts += 1;
            } else {
                unsignedKeys.push(pubkey.toString());
                if (!isWritable) numReadonlyUnsignedAccounts += 1;
            }
        });
        const accountKeys = signedKeys.concat(unsignedKeys);
        const compiledInstructions = instructions.map((instruction)=>{
            const { data, programId } = instruction;
            return {
                programIdIndex: accountKeys.indexOf(programId.toString()),
                accounts: instruction.keys.map((meta)=>accountKeys.indexOf(meta.pubkey.toString())),
                data: (0, _bs58Default.default).encode(data)
            };
        });
        compiledInstructions.forEach((instruction)=>{
            assert(instruction.programIdIndex >= 0);
            instruction.accounts.forEach((keyIndex)=>assert(keyIndex >= 0));
        });
        return new Message({
            header: {
                numRequiredSignatures,
                numReadonlySignedAccounts,
                numReadonlyUnsignedAccounts
            },
            accountKeys,
            recentBlockhash,
            instructions: compiledInstructions
        });
    }
    /**
   * @internal
   */ _compile() {
        const message = this.compileMessage();
        const signedKeys = message.accountKeys.slice(0, message.header.numRequiredSignatures);
        if (this.signatures.length === signedKeys.length) {
            const valid = this.signatures.every((pair, index)=>{
                return signedKeys[index].equals(pair.publicKey);
            });
            if (valid) return message;
        }
        this.signatures = signedKeys.map((publicKey)=>({
                signature: null,
                publicKey
            }));
        return message;
    }
    /**
   * Get a buffer of the Transaction data that need to be covered by signatures
   */ serializeMessage() {
        return this._compile().serialize();
    }
    /**
   * Get the estimated fee associated with a transaction
   *
   * @param {Connection} connection Connection to RPC Endpoint.
   *
   * @returns {Promise<number | null>} The estimated fee for the transaction
   */ async getEstimatedFee(connection) {
        return (await connection.getFeeForMessage(this.compileMessage())).value;
    }
    /**
   * Specify the public keys which will be used to sign the Transaction.
   * The first signer will be used as the transaction fee payer account.
   *
   * Signatures can be added with either `partialSign` or `addSignature`
   *
   * @deprecated Deprecated since v0.84.0. Only the fee payer needs to be
   * specified and it can be set in the Transaction constructor or with the
   * `feePayer` property.
   */ setSigners(...signers) {
        if (signers.length === 0) throw new Error("No signers");
        const seen = new Set();
        this.signatures = signers.filter((publicKey)=>{
            const key = publicKey.toString();
            if (seen.has(key)) return false;
            else {
                seen.add(key);
                return true;
            }
        }).map((publicKey)=>({
                signature: null,
                publicKey
            }));
    }
    /**
   * Sign the Transaction with the specified signers. Multiple signatures may
   * be applied to a Transaction. The first signature is considered "primary"
   * and is used identify and confirm transactions.
   *
   * If the Transaction `feePayer` is not set, the first signer will be used
   * as the transaction fee payer account.
   *
   * Transaction fields should not be modified after the first call to `sign`,
   * as doing so may invalidate the signature and cause the Transaction to be
   * rejected.
   *
   * The Transaction must be assigned a valid `recentBlockhash` before invoking this method
   *
   * @param {Array<Signer>} signers Array of signers that will sign the transaction
   */ sign(...signers) {
        if (signers.length === 0) throw new Error("No signers");
        // Dedupe signers
        const seen = new Set();
        const uniqueSigners = [];
        for (const signer of signers){
            const key = signer.publicKey.toString();
            if (seen.has(key)) continue;
            else {
                seen.add(key);
                uniqueSigners.push(signer);
            }
        }
        this.signatures = uniqueSigners.map((signer)=>({
                signature: null,
                publicKey: signer.publicKey
            }));
        const message = this._compile();
        this._partialSign(message, ...uniqueSigners);
    }
    /**
   * Partially sign a transaction with the specified accounts. All accounts must
   * correspond to either the fee payer or a signer account in the transaction
   * instructions.
   *
   * All the caveats from the `sign` method apply to `partialSign`
   *
   * @param {Array<Signer>} signers Array of signers that will sign the transaction
   */ partialSign(...signers) {
        if (signers.length === 0) throw new Error("No signers");
        // Dedupe signers
        const seen = new Set();
        const uniqueSigners = [];
        for (const signer of signers){
            const key = signer.publicKey.toString();
            if (seen.has(key)) continue;
            else {
                seen.add(key);
                uniqueSigners.push(signer);
            }
        }
        const message = this._compile();
        this._partialSign(message, ...uniqueSigners);
    }
    /**
   * @internal
   */ _partialSign(message, ...signers) {
        const signData = message.serialize();
        signers.forEach((signer)=>{
            const signature = sign(signData, signer.secretKey);
            this._addSignature(signer.publicKey, toBuffer(signature));
        });
    }
    /**
   * Add an externally created signature to a transaction. The public key
   * must correspond to either the fee payer or a signer account in the transaction
   * instructions.
   *
   * @param {PublicKey} pubkey Public key that will be added to the transaction.
   * @param {Buffer} signature An externally created signature to add to the transaction.
   */ addSignature(pubkey, signature) {
        this._compile(); // Ensure signatures array is populated
        this._addSignature(pubkey, signature);
    }
    /**
   * @internal
   */ _addSignature(pubkey, signature) {
        assert(signature.length === 64);
        const index = this.signatures.findIndex((sigpair)=>pubkey.equals(sigpair.publicKey));
        if (index < 0) throw new Error(`unknown signer: ${pubkey.toString()}`);
        this.signatures[index].signature = (0, _buffer.Buffer).from(signature);
    }
    /**
   * Verify signatures of a Transaction
   * Optional parameter specifies if we're expecting a fully signed Transaction or a partially signed one.
   * If no boolean is provided, we expect a fully signed Transaction by default.
   *
   * @param {boolean} [requireAllSignatures=true] Require a fully signed Transaction
   */ verifySignatures(requireAllSignatures = true) {
        const signatureErrors = this._getMessageSignednessErrors(this.serializeMessage(), requireAllSignatures);
        return !signatureErrors;
    }
    /**
   * @internal
   */ _getMessageSignednessErrors(message, requireAllSignatures) {
        const errors = {};
        for (const { signature, publicKey } of this.signatures){
            if (signature === null) {
                if (requireAllSignatures) (errors.missing ||= []).push(publicKey);
            } else if (!verify(signature, message, publicKey.toBytes())) (errors.invalid ||= []).push(publicKey);
        }
        return errors.invalid || errors.missing ? errors : undefined;
    }
    /**
   * Serialize the Transaction in the wire format.
   *
   * @param {Buffer} [config] Config of transaction.
   *
   * @returns {Buffer} Signature of transaction in wire format.
   */ serialize(config) {
        const { requireAllSignatures, verifySignatures } = Object.assign({
            requireAllSignatures: true,
            verifySignatures: true
        }, config);
        const signData = this.serializeMessage();
        if (verifySignatures) {
            const sigErrors = this._getMessageSignednessErrors(signData, requireAllSignatures);
            if (sigErrors) {
                let errorMessage = "Signature verification failed.";
                if (sigErrors.invalid) errorMessage += `\nInvalid signature for public key${sigErrors.invalid.length === 1 ? "" : "(s)"} [\`${sigErrors.invalid.map((p)=>p.toBase58()).join("`, `")}\`].`;
                if (sigErrors.missing) errorMessage += `\nMissing signature for public key${sigErrors.missing.length === 1 ? "" : "(s)"} [\`${sigErrors.missing.map((p)=>p.toBase58()).join("`, `")}\`].`;
                throw new Error(errorMessage);
            }
        }
        return this._serialize(signData);
    }
    /**
   * @internal
   */ _serialize(signData) {
        const { signatures } = this;
        const signatureCount = [];
        encodeLength(signatureCount, signatures.length);
        const transactionLength = signatureCount.length + signatures.length * 64 + signData.length;
        const wireTransaction = (0, _buffer.Buffer).alloc(transactionLength);
        assert(signatures.length < 256);
        (0, _buffer.Buffer).from(signatureCount).copy(wireTransaction, 0);
        signatures.forEach(({ signature }, index)=>{
            if (signature !== null) {
                assert(signature.length === 64, `signature has invalid length`);
                (0, _buffer.Buffer).from(signature).copy(wireTransaction, signatureCount.length + index * 64);
            }
        });
        signData.copy(wireTransaction, signatureCount.length + signatures.length * 64);
        assert(wireTransaction.length <= PACKET_DATA_SIZE, `Transaction too large: ${wireTransaction.length} > ${PACKET_DATA_SIZE}`);
        return wireTransaction;
    }
    /**
   * Deprecated method
   * @internal
   */ get keys() {
        assert(this.instructions.length === 1);
        return this.instructions[0].keys.map((keyObj)=>keyObj.pubkey);
    }
    /**
   * Deprecated method
   * @internal
   */ get programId() {
        assert(this.instructions.length === 1);
        return this.instructions[0].programId;
    }
    /**
   * Deprecated method
   * @internal
   */ get data() {
        assert(this.instructions.length === 1);
        return this.instructions[0].data;
    }
    /**
   * Parse a wire transaction into a Transaction object.
   *
   * @param {Buffer | Uint8Array | Array<number>} buffer Signature of wire Transaction
   *
   * @returns {Transaction} Transaction associated with the signature
   */ static from(buffer) {
        // Slice up wire data
        let byteArray = [
            ...buffer
        ];
        const signatureCount = decodeLength(byteArray);
        let signatures = [];
        for(let i = 0; i < signatureCount; i++){
            const signature = guardedSplice(byteArray, 0, SIGNATURE_LENGTH_IN_BYTES);
            signatures.push((0, _bs58Default.default).encode((0, _buffer.Buffer).from(signature)));
        }
        return Transaction.populate(Message.from(byteArray), signatures);
    }
    /**
   * Populate Transaction object from message and signatures
   *
   * @param {Message} message Message of transaction
   * @param {Array<string>} signatures List of signatures to assign to the transaction
   *
   * @returns {Transaction} The populated Transaction
   */ static populate(message, signatures = []) {
        const transaction = new Transaction();
        transaction.recentBlockhash = message.recentBlockhash;
        if (message.header.numRequiredSignatures > 0) transaction.feePayer = message.accountKeys[0];
        signatures.forEach((signature, index)=>{
            const sigPubkeyPair = {
                signature: signature == (0, _bs58Default.default).encode(DEFAULT_SIGNATURE) ? null : (0, _bs58Default.default).decode(signature),
                publicKey: message.accountKeys[index]
            };
            transaction.signatures.push(sigPubkeyPair);
        });
        message.instructions.forEach((instruction)=>{
            const keys = instruction.accounts.map((account)=>{
                const pubkey = message.accountKeys[account];
                return {
                    pubkey,
                    isSigner: transaction.signatures.some((keyObj)=>keyObj.publicKey.toString() === pubkey.toString()) || message.isAccountSigner(account),
                    isWritable: message.isAccountWritable(account)
                };
            });
            transaction.instructions.push(new TransactionInstruction({
                keys,
                programId: message.accountKeys[instruction.programIdIndex],
                data: (0, _bs58Default.default).decode(instruction.data)
            }));
        });
        transaction._message = message;
        transaction._json = transaction.toJSON();
        return transaction;
    }
}
class TransactionMessage {
    constructor(args){
        this.payerKey = void 0;
        this.instructions = void 0;
        this.recentBlockhash = void 0;
        this.payerKey = args.payerKey;
        this.instructions = args.instructions;
        this.recentBlockhash = args.recentBlockhash;
    }
    static decompile(message, args) {
        const { header, compiledInstructions, recentBlockhash } = message;
        const { numRequiredSignatures, numReadonlySignedAccounts, numReadonlyUnsignedAccounts } = header;
        const numWritableSignedAccounts = numRequiredSignatures - numReadonlySignedAccounts;
        assert(numWritableSignedAccounts > 0, "Message header is invalid");
        const numWritableUnsignedAccounts = message.staticAccountKeys.length - numRequiredSignatures - numReadonlyUnsignedAccounts;
        assert(numWritableUnsignedAccounts >= 0, "Message header is invalid");
        const accountKeys = message.getAccountKeys(args);
        const payerKey = accountKeys.get(0);
        if (payerKey === undefined) throw new Error("Failed to decompile message because no account keys were found");
        const instructions = [];
        for (const compiledIx of compiledInstructions){
            const keys = [];
            for (const keyIndex of compiledIx.accountKeyIndexes){
                const pubkey = accountKeys.get(keyIndex);
                if (pubkey === undefined) throw new Error(`Failed to find key for account key index ${keyIndex}`);
                const isSigner = keyIndex < numRequiredSignatures;
                let isWritable;
                if (isSigner) isWritable = keyIndex < numWritableSignedAccounts;
                else if (keyIndex < accountKeys.staticAccountKeys.length) isWritable = keyIndex - numRequiredSignatures < numWritableUnsignedAccounts;
                else isWritable = keyIndex - accountKeys.staticAccountKeys.length < // accountKeysFromLookups cannot be undefined because we already found a pubkey for this index above
                accountKeys.accountKeysFromLookups.writable.length;
                keys.push({
                    pubkey,
                    isSigner: keyIndex < header.numRequiredSignatures,
                    isWritable
                });
            }
            const programId = accountKeys.get(compiledIx.programIdIndex);
            if (programId === undefined) throw new Error(`Failed to find program id for program id index ${compiledIx.programIdIndex}`);
            instructions.push(new TransactionInstruction({
                programId,
                data: toBuffer(compiledIx.data),
                keys
            }));
        }
        return new TransactionMessage({
            payerKey,
            instructions,
            recentBlockhash
        });
    }
    compileToLegacyMessage() {
        return Message.compile({
            payerKey: this.payerKey,
            recentBlockhash: this.recentBlockhash,
            instructions: this.instructions
        });
    }
    compileToV0Message(addressLookupTableAccounts) {
        return MessageV0.compile({
            payerKey: this.payerKey,
            recentBlockhash: this.recentBlockhash,
            instructions: this.instructions,
            addressLookupTableAccounts
        });
    }
}
/**
 * Versioned transaction class
 */ class VersionedTransaction {
    get version() {
        return this.message.version;
    }
    constructor(message, signatures){
        this.signatures = void 0;
        this.message = void 0;
        if (signatures !== undefined) {
            assert(signatures.length === message.header.numRequiredSignatures, "Expected signatures length to be equal to the number of required signatures");
            this.signatures = signatures;
        } else {
            const defaultSignatures = [];
            for(let i = 0; i < message.header.numRequiredSignatures; i++)defaultSignatures.push(new Uint8Array(SIGNATURE_LENGTH_IN_BYTES));
            this.signatures = defaultSignatures;
        }
        this.message = message;
    }
    serialize() {
        const serializedMessage = this.message.serialize();
        const encodedSignaturesLength = Array();
        encodeLength(encodedSignaturesLength, this.signatures.length);
        const transactionLayout = _bufferLayout.struct([
            _bufferLayout.blob(encodedSignaturesLength.length, "encodedSignaturesLength"),
            _bufferLayout.seq(signature(), this.signatures.length, "signatures"),
            _bufferLayout.blob(serializedMessage.length, "serializedMessage")
        ]);
        const serializedTransaction = new Uint8Array(2048);
        const serializedTransactionLength = transactionLayout.encode({
            encodedSignaturesLength: new Uint8Array(encodedSignaturesLength),
            signatures: this.signatures,
            serializedMessage
        }, serializedTransaction);
        return serializedTransaction.slice(0, serializedTransactionLength);
    }
    static deserialize(serializedTransaction) {
        let byteArray = [
            ...serializedTransaction
        ];
        const signatures = [];
        const signaturesLength = decodeLength(byteArray);
        for(let i = 0; i < signaturesLength; i++)signatures.push(new Uint8Array(guardedSplice(byteArray, 0, SIGNATURE_LENGTH_IN_BYTES)));
        const message = VersionedMessage.deserialize(new Uint8Array(byteArray));
        return new VersionedTransaction(message, signatures);
    }
    sign(signers) {
        const messageData = this.message.serialize();
        const signerPubkeys = this.message.staticAccountKeys.slice(0, this.message.header.numRequiredSignatures);
        for (const signer of signers){
            const signerIndex = signerPubkeys.findIndex((pubkey)=>pubkey.equals(signer.publicKey));
            assert(signerIndex >= 0, `Cannot sign with non signer key ${signer.publicKey.toBase58()}`);
            this.signatures[signerIndex] = sign(messageData, signer.secretKey);
        }
    }
    addSignature(publicKey, signature) {
        assert(signature.byteLength === 64, "Signature must be 64 bytes long");
        const signerPubkeys = this.message.staticAccountKeys.slice(0, this.message.header.numRequiredSignatures);
        const signerIndex = signerPubkeys.findIndex((pubkey)=>pubkey.equals(publicKey));
        assert(signerIndex >= 0, `Can not add signature; \`${publicKey.toBase58()}\` is not required to sign this transaction`);
        this.signatures[signerIndex] = signature;
    }
}
// TODO: These constants should be removed in favor of reading them out of a
// Syscall account
/**
 * @internal
 */ const NUM_TICKS_PER_SECOND = 160;
/**
 * @internal
 */ const DEFAULT_TICKS_PER_SLOT = 64;
/**
 * @internal
 */ const NUM_SLOTS_PER_SECOND = NUM_TICKS_PER_SECOND / DEFAULT_TICKS_PER_SLOT;
/**
 * @internal
 */ const MS_PER_SLOT = 1000 / NUM_SLOTS_PER_SECOND;
const SYSVAR_CLOCK_PUBKEY = new PublicKey("SysvarC1ock11111111111111111111111111111111");
const SYSVAR_EPOCH_SCHEDULE_PUBKEY = new PublicKey("SysvarEpochSchedu1e111111111111111111111111");
const SYSVAR_INSTRUCTIONS_PUBKEY = new PublicKey("Sysvar1nstructions1111111111111111111111111");
const SYSVAR_RECENT_BLOCKHASHES_PUBKEY = new PublicKey("SysvarRecentB1ockHashes11111111111111111111");
const SYSVAR_RENT_PUBKEY = new PublicKey("SysvarRent111111111111111111111111111111111");
const SYSVAR_REWARDS_PUBKEY = new PublicKey("SysvarRewards111111111111111111111111111111");
const SYSVAR_SLOT_HASHES_PUBKEY = new PublicKey("SysvarS1otHashes111111111111111111111111111");
const SYSVAR_SLOT_HISTORY_PUBKEY = new PublicKey("SysvarS1otHistory11111111111111111111111111");
const SYSVAR_STAKE_HISTORY_PUBKEY = new PublicKey("SysvarStakeHistory1111111111111111111111111");
class SendTransactionError extends Error {
    constructor({ action, signature, transactionMessage, logs }){
        const maybeLogsOutput = logs ? `Logs: \n${JSON.stringify(logs.slice(-10), null, 2)}. ` : "";
        const guideText = "\nCatch the `SendTransactionError` and call `getLogs()` on it for full details.";
        let message;
        switch(action){
            case "send":
                message = `Transaction ${signature} resulted in an error. \n` + `${transactionMessage}. ` + maybeLogsOutput + guideText;
                break;
            case "simulate":
                message = `Simulation failed. \nMessage: ${transactionMessage}. \n` + maybeLogsOutput + guideText;
                break;
            default:
                message = `Unknown action '${((a)=>a)(action)}'`;
        }
        super(message);
        this.signature = void 0;
        this.transactionMessage = void 0;
        this.transactionLogs = void 0;
        this.signature = signature;
        this.transactionMessage = transactionMessage;
        this.transactionLogs = logs ? logs : undefined;
    }
    get transactionError() {
        return {
            message: this.transactionMessage,
            logs: Array.isArray(this.transactionLogs) ? this.transactionLogs : undefined
        };
    }
    /* @deprecated Use `await getLogs()` instead */ get logs() {
        const cachedLogs = this.transactionLogs;
        if (cachedLogs != null && typeof cachedLogs === "object" && "then" in cachedLogs) return undefined;
        return cachedLogs;
    }
    async getLogs(connection) {
        if (!Array.isArray(this.transactionLogs)) this.transactionLogs = new Promise((resolve, reject)=>{
            connection.getTransaction(this.signature).then((tx)=>{
                if (tx && tx.meta && tx.meta.logMessages) {
                    const logs = tx.meta.logMessages;
                    this.transactionLogs = logs;
                    resolve(logs);
                } else reject(new Error("Log messages not found"));
            }).catch(reject);
        });
        return await this.transactionLogs;
    }
}
// Keep in sync with client/src/rpc_custom_errors.rs
// Typescript `enums` thwart tree-shaking. See https://bargsten.org/jsts/enums/
const SolanaJSONRPCErrorCode = {
    JSON_RPC_SERVER_ERROR_BLOCK_CLEANED_UP: -32001,
    JSON_RPC_SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE: -32002,
    JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE: -32003,
    JSON_RPC_SERVER_ERROR_BLOCK_NOT_AVAILABLE: -32004,
    JSON_RPC_SERVER_ERROR_NODE_UNHEALTHY: -32005,
    JSON_RPC_SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE: -32006,
    JSON_RPC_SERVER_ERROR_SLOT_SKIPPED: -32007,
    JSON_RPC_SERVER_ERROR_NO_SNAPSHOT: -32008,
    JSON_RPC_SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED: -32009,
    JSON_RPC_SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX: -32010,
    JSON_RPC_SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE: -32011,
    JSON_RPC_SCAN_ERROR: -32012,
    JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH: -32013,
    JSON_RPC_SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET: -32014,
    JSON_RPC_SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION: -32015,
    JSON_RPC_SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED: -32016
};
class SolanaJSONRPCError extends Error {
    constructor({ code, message, data }, customMessage){
        super(customMessage != null ? `${customMessage}: ${message}` : message);
        this.code = void 0;
        this.data = void 0;
        this.code = code;
        this.data = data;
        this.name = "SolanaJSONRPCError";
    }
}
/**
 * Sign, send and confirm a transaction.
 *
 * If `commitment` option is not specified, defaults to 'max' commitment.
 *
 * @param {Connection} connection
 * @param {Transaction} transaction
 * @param {Array<Signer>} signers
 * @param {ConfirmOptions} [options]
 * @returns {Promise<TransactionSignature>}
 */ async function sendAndConfirmTransaction(connection, transaction, signers, options) {
    const sendOptions = options && {
        skipPreflight: options.skipPreflight,
        preflightCommitment: options.preflightCommitment || options.commitment,
        maxRetries: options.maxRetries,
        minContextSlot: options.minContextSlot
    };
    const signature = await connection.sendTransaction(transaction, signers, sendOptions);
    let status;
    if (transaction.recentBlockhash != null && transaction.lastValidBlockHeight != null) status = (await connection.confirmTransaction({
        abortSignal: options?.abortSignal,
        signature: signature,
        blockhash: transaction.recentBlockhash,
        lastValidBlockHeight: transaction.lastValidBlockHeight
    }, options && options.commitment)).value;
    else if (transaction.minNonceContextSlot != null && transaction.nonceInfo != null) {
        const { nonceInstruction } = transaction.nonceInfo;
        const nonceAccountPubkey = nonceInstruction.keys[0].pubkey;
        status = (await connection.confirmTransaction({
            abortSignal: options?.abortSignal,
            minContextSlot: transaction.minNonceContextSlot,
            nonceAccountPubkey,
            nonceValue: transaction.nonceInfo.nonce,
            signature
        }, options && options.commitment)).value;
    } else {
        if (options?.abortSignal != null) console.warn("sendAndConfirmTransaction(): A transaction with a deprecated confirmation strategy was supplied along with an `abortSignal`. Only transactions having `lastValidBlockHeight` or a combination of `nonceInfo` and `minNonceContextSlot` are abortable.");
        status = (await connection.confirmTransaction(signature, options && options.commitment)).value;
    }
    if (status.err) {
        if (signature != null) throw new SendTransactionError({
            action: "send",
            signature: signature,
            transactionMessage: `Status: (${JSON.stringify(status)})`
        });
        throw new Error(`Transaction ${signature} failed (${JSON.stringify(status)})`);
    }
    return signature;
}
// zzz
function sleep(ms) {
    return new Promise((resolve)=>setTimeout(resolve, ms));
}
/**
 * @internal
 */ /**
 * Populate a buffer of instruction data using an InstructionType
 * @internal
 */ function encodeData(type, fields) {
    const allocLength = type.layout.span >= 0 ? type.layout.span : getAlloc(type, fields);
    const data = (0, _buffer.Buffer).alloc(allocLength);
    const layoutFields = Object.assign({
        instruction: type.index
    }, fields);
    type.layout.encode(layoutFields, data);
    return data;
}
/**
 * Decode instruction data buffer using an InstructionType
 * @internal
 */ function decodeData$1(type, buffer) {
    let data;
    try {
        data = type.layout.decode(buffer);
    } catch (err) {
        throw new Error("invalid instruction; " + err);
    }
    if (data.instruction !== type.index) throw new Error(`invalid instruction; instruction index mismatch ${data.instruction} != ${type.index}`);
    return data;
}
/**
 * https://github.com/solana-labs/solana/blob/90bedd7e067b5b8f3ddbb45da00a4e9cabb22c62/sdk/src/fee_calculator.rs#L7-L11
 *
 * @internal
 */ const FeeCalculatorLayout = _bufferLayout.nu64("lamportsPerSignature");
/**
 * Calculator for transaction fees.
 *
 * @deprecated Deprecated since Solana v1.8.0.
 */ /**
 * See https://github.com/solana-labs/solana/blob/0ea2843ec9cdc517572b8e62c959f41b55cf4453/sdk/src/nonce_state.rs#L29-L32
 *
 * @internal
 */ const NonceAccountLayout = _bufferLayout.struct([
    _bufferLayout.u32("version"),
    _bufferLayout.u32("state"),
    publicKey("authorizedPubkey"),
    publicKey("nonce"),
    _bufferLayout.struct([
        FeeCalculatorLayout
    ], "feeCalculator")
]);
const NONCE_ACCOUNT_LENGTH = NonceAccountLayout.span;
/**
 * A durable nonce is a 32 byte value encoded as a base58 string.
 */ /**
 * NonceAccount class
 */ class NonceAccount {
    /**
   * @internal
   */ constructor(args){
        this.authorizedPubkey = void 0;
        this.nonce = void 0;
        this.feeCalculator = void 0;
        this.authorizedPubkey = args.authorizedPubkey;
        this.nonce = args.nonce;
        this.feeCalculator = args.feeCalculator;
    }
    /**
   * Deserialize NonceAccount from the account data.
   *
   * @param buffer account data
   * @return NonceAccount
   */ static fromAccountData(buffer) {
        const nonceAccount = NonceAccountLayout.decode(toBuffer(buffer), 0);
        return new NonceAccount({
            authorizedPubkey: new PublicKey(nonceAccount.authorizedPubkey),
            nonce: new PublicKey(nonceAccount.nonce).toString(),
            feeCalculator: nonceAccount.feeCalculator
        });
    }
}
const encodeDecode = (layout)=>{
    const decode = layout.decode.bind(layout);
    const encode = layout.encode.bind(layout);
    return {
        decode,
        encode
    };
};
const bigInt = (length)=>(property)=>{
        const layout = (0, _bufferLayout.blob)(length, property);
        const { encode, decode } = encodeDecode(layout);
        const bigIntLayout = layout;
        bigIntLayout.decode = (buffer, offset)=>{
            const src = decode(buffer, offset);
            return (0, _bigintBuffer.toBigIntLE)((0, _buffer.Buffer).from(src));
        };
        bigIntLayout.encode = (bigInt, buffer, offset)=>{
            const src = (0, _bigintBuffer.toBufferLE)(bigInt, length);
            return encode(src, buffer, offset);
        };
        return bigIntLayout;
    };
const u64 = bigInt(8);
/**
 * Create account system transaction params
 */ /**
 * Transfer system transaction params
 */ /**
 * Assign system transaction params
 */ /**
 * Create account with seed system transaction params
 */ /**
 * Create nonce account system transaction params
 */ /**
 * Create nonce account with seed system transaction params
 */ /**
 * Initialize nonce account system instruction params
 */ /**
 * Advance nonce account system instruction params
 */ /**
 * Withdraw nonce account system transaction params
 */ /**
 * Authorize nonce account system transaction params
 */ /**
 * Allocate account system transaction params
 */ /**
 * Allocate account with seed system transaction params
 */ /**
 * Assign account with seed system transaction params
 */ /**
 * Transfer with seed system transaction params
 */ /** Decoded transfer system transaction instruction */ /** Decoded transferWithSeed system transaction instruction */ /**
 * System Instruction class
 */ class SystemInstruction {
    /**
   * @internal
   */ constructor(){}
    /**
   * Decode a system instruction and retrieve the instruction type.
   */ static decodeInstructionType(instruction) {
        this.checkProgramId(instruction.programId);
        const instructionTypeLayout = _bufferLayout.u32("instruction");
        const typeIndex = instructionTypeLayout.decode(instruction.data);
        let type;
        for (const [ixType, layout] of Object.entries(SYSTEM_INSTRUCTION_LAYOUTS))if (layout.index == typeIndex) {
            type = ixType;
            break;
        }
        if (!type) throw new Error("Instruction type incorrect; not a SystemInstruction");
        return type;
    }
    /**
   * Decode a create account system instruction and retrieve the instruction params.
   */ static decodeCreateAccount(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeyLength(instruction.keys, 2);
        const { lamports, space, programId } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Create, instruction.data);
        return {
            fromPubkey: instruction.keys[0].pubkey,
            newAccountPubkey: instruction.keys[1].pubkey,
            lamports,
            space,
            programId: new PublicKey(programId)
        };
    }
    /**
   * Decode a transfer system instruction and retrieve the instruction params.
   */ static decodeTransfer(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeyLength(instruction.keys, 2);
        const { lamports } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Transfer, instruction.data);
        return {
            fromPubkey: instruction.keys[0].pubkey,
            toPubkey: instruction.keys[1].pubkey,
            lamports
        };
    }
    /**
   * Decode a transfer with seed system instruction and retrieve the instruction params.
   */ static decodeTransferWithSeed(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeyLength(instruction.keys, 3);
        const { lamports, seed, programId } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.TransferWithSeed, instruction.data);
        return {
            fromPubkey: instruction.keys[0].pubkey,
            basePubkey: instruction.keys[1].pubkey,
            toPubkey: instruction.keys[2].pubkey,
            lamports,
            seed,
            programId: new PublicKey(programId)
        };
    }
    /**
   * Decode an allocate system instruction and retrieve the instruction params.
   */ static decodeAllocate(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeyLength(instruction.keys, 1);
        const { space } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Allocate, instruction.data);
        return {
            accountPubkey: instruction.keys[0].pubkey,
            space
        };
    }
    /**
   * Decode an allocate with seed system instruction and retrieve the instruction params.
   */ static decodeAllocateWithSeed(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeyLength(instruction.keys, 1);
        const { base, seed, space, programId } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AllocateWithSeed, instruction.data);
        return {
            accountPubkey: instruction.keys[0].pubkey,
            basePubkey: new PublicKey(base),
            seed,
            space,
            programId: new PublicKey(programId)
        };
    }
    /**
   * Decode an assign system instruction and retrieve the instruction params.
   */ static decodeAssign(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeyLength(instruction.keys, 1);
        const { programId } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Assign, instruction.data);
        return {
            accountPubkey: instruction.keys[0].pubkey,
            programId: new PublicKey(programId)
        };
    }
    /**
   * Decode an assign with seed system instruction and retrieve the instruction params.
   */ static decodeAssignWithSeed(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeyLength(instruction.keys, 1);
        const { base, seed, programId } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AssignWithSeed, instruction.data);
        return {
            accountPubkey: instruction.keys[0].pubkey,
            basePubkey: new PublicKey(base),
            seed,
            programId: new PublicKey(programId)
        };
    }
    /**
   * Decode a create account with seed system instruction and retrieve the instruction params.
   */ static decodeCreateWithSeed(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeyLength(instruction.keys, 2);
        const { base, seed, lamports, space, programId } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.CreateWithSeed, instruction.data);
        return {
            fromPubkey: instruction.keys[0].pubkey,
            newAccountPubkey: instruction.keys[1].pubkey,
            basePubkey: new PublicKey(base),
            seed,
            lamports,
            space,
            programId: new PublicKey(programId)
        };
    }
    /**
   * Decode a nonce initialize system instruction and retrieve the instruction params.
   */ static decodeNonceInitialize(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeyLength(instruction.keys, 3);
        const { authorized } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.InitializeNonceAccount, instruction.data);
        return {
            noncePubkey: instruction.keys[0].pubkey,
            authorizedPubkey: new PublicKey(authorized)
        };
    }
    /**
   * Decode a nonce advance system instruction and retrieve the instruction params.
   */ static decodeNonceAdvance(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeyLength(instruction.keys, 3);
        decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AdvanceNonceAccount, instruction.data);
        return {
            noncePubkey: instruction.keys[0].pubkey,
            authorizedPubkey: instruction.keys[2].pubkey
        };
    }
    /**
   * Decode a nonce withdraw system instruction and retrieve the instruction params.
   */ static decodeNonceWithdraw(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeyLength(instruction.keys, 5);
        const { lamports } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.WithdrawNonceAccount, instruction.data);
        return {
            noncePubkey: instruction.keys[0].pubkey,
            toPubkey: instruction.keys[1].pubkey,
            authorizedPubkey: instruction.keys[4].pubkey,
            lamports
        };
    }
    /**
   * Decode a nonce authorize system instruction and retrieve the instruction params.
   */ static decodeNonceAuthorize(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeyLength(instruction.keys, 2);
        const { authorized } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AuthorizeNonceAccount, instruction.data);
        return {
            noncePubkey: instruction.keys[0].pubkey,
            authorizedPubkey: instruction.keys[1].pubkey,
            newAuthorizedPubkey: new PublicKey(authorized)
        };
    }
    /**
   * @internal
   */ static checkProgramId(programId) {
        if (!programId.equals(SystemProgram.programId)) throw new Error("invalid instruction; programId is not SystemProgram");
    }
    /**
   * @internal
   */ static checkKeyLength(keys, expectedLength) {
        if (keys.length < expectedLength) throw new Error(`invalid instruction; found ${keys.length} keys, expected at least ${expectedLength}`);
    }
}
/**
 * An enumeration of valid SystemInstructionType's
 */ /**
 * An enumeration of valid system InstructionType's
 * @internal
 */ const SYSTEM_INSTRUCTION_LAYOUTS = Object.freeze({
    Create: {
        index: 0,
        layout: _bufferLayout.struct([
            _bufferLayout.u32("instruction"),
            _bufferLayout.ns64("lamports"),
            _bufferLayout.ns64("space"),
            publicKey("programId")
        ])
    },
    Assign: {
        index: 1,
        layout: _bufferLayout.struct([
            _bufferLayout.u32("instruction"),
            publicKey("programId")
        ])
    },
    Transfer: {
        index: 2,
        layout: _bufferLayout.struct([
            _bufferLayout.u32("instruction"),
            u64("lamports")
        ])
    },
    CreateWithSeed: {
        index: 3,
        layout: _bufferLayout.struct([
            _bufferLayout.u32("instruction"),
            publicKey("base"),
            rustString("seed"),
            _bufferLayout.ns64("lamports"),
            _bufferLayout.ns64("space"),
            publicKey("programId")
        ])
    },
    AdvanceNonceAccount: {
        index: 4,
        layout: _bufferLayout.struct([
            _bufferLayout.u32("instruction")
        ])
    },
    WithdrawNonceAccount: {
        index: 5,
        layout: _bufferLayout.struct([
            _bufferLayout.u32("instruction"),
            _bufferLayout.ns64("lamports")
        ])
    },
    InitializeNonceAccount: {
        index: 6,
        layout: _bufferLayout.struct([
            _bufferLayout.u32("instruction"),
            publicKey("authorized")
        ])
    },
    AuthorizeNonceAccount: {
        index: 7,
        layout: _bufferLayout.struct([
            _bufferLayout.u32("instruction"),
            publicKey("authorized")
        ])
    },
    Allocate: {
        index: 8,
        layout: _bufferLayout.struct([
            _bufferLayout.u32("instruction"),
            _bufferLayout.ns64("space")
        ])
    },
    AllocateWithSeed: {
        index: 9,
        layout: _bufferLayout.struct([
            _bufferLayout.u32("instruction"),
            publicKey("base"),
            rustString("seed"),
            _bufferLayout.ns64("space"),
            publicKey("programId")
        ])
    },
    AssignWithSeed: {
        index: 10,
        layout: _bufferLayout.struct([
            _bufferLayout.u32("instruction"),
            publicKey("base"),
            rustString("seed"),
            publicKey("programId")
        ])
    },
    TransferWithSeed: {
        index: 11,
        layout: _bufferLayout.struct([
            _bufferLayout.u32("instruction"),
            u64("lamports"),
            rustString("seed"),
            publicKey("programId")
        ])
    },
    UpgradeNonceAccount: {
        index: 12,
        layout: _bufferLayout.struct([
            _bufferLayout.u32("instruction")
        ])
    }
});
/**
 * Factory class for transactions to interact with the System program
 */ class SystemProgram {
    /**
   * @internal
   */ constructor(){}
    /**
   * Public key that identifies the System program
   */ /**
   * Generate a transaction instruction that creates a new account
   */ static createAccount(params) {
        const type = SYSTEM_INSTRUCTION_LAYOUTS.Create;
        const data = encodeData(type, {
            lamports: params.lamports,
            space: params.space,
            programId: toBuffer(params.programId.toBuffer())
        });
        return new TransactionInstruction({
            keys: [
                {
                    pubkey: params.fromPubkey,
                    isSigner: true,
                    isWritable: true
                },
                {
                    pubkey: params.newAccountPubkey,
                    isSigner: true,
                    isWritable: true
                }
            ],
            programId: this.programId,
            data
        });
    }
    /**
   * Generate a transaction instruction that transfers lamports from one account to another
   */ static transfer(params) {
        let data;
        let keys;
        if ("basePubkey" in params) {
            const type = SYSTEM_INSTRUCTION_LAYOUTS.TransferWithSeed;
            data = encodeData(type, {
                lamports: BigInt(params.lamports),
                seed: params.seed,
                programId: toBuffer(params.programId.toBuffer())
            });
            keys = [
                {
                    pubkey: params.fromPubkey,
                    isSigner: false,
                    isWritable: true
                },
                {
                    pubkey: params.basePubkey,
                    isSigner: true,
                    isWritable: false
                },
                {
                    pubkey: params.toPubkey,
                    isSigner: false,
                    isWritable: true
                }
            ];
        } else {
            const type = SYSTEM_INSTRUCTION_LAYOUTS.Transfer;
            data = encodeData(type, {
                lamports: BigInt(params.lamports)
            });
            keys = [
                {
                    pubkey: params.fromPubkey,
                    isSigner: true,
                    isWritable: true
                },
                {
                    pubkey: params.toPubkey,
                    isSigner: false,
                    isWritable: true
                }
            ];
        }
        return new TransactionInstruction({
            keys,
            programId: this.programId,
            data
        });
    }
    /**
   * Generate a transaction instruction that assigns an account to a program
   */ static assign(params) {
        let data;
        let keys;
        if ("basePubkey" in params) {
            const type = SYSTEM_INSTRUCTION_LAYOUTS.AssignWithSeed;
            data = encodeData(type, {
                base: toBuffer(params.basePubkey.toBuffer()),
                seed: params.seed,
                programId: toBuffer(params.programId.toBuffer())
            });
            keys = [
                {
                    pubkey: params.accountPubkey,
                    isSigner: false,
                    isWritable: true
                },
                {
                    pubkey: params.basePubkey,
                    isSigner: true,
                    isWritable: false
                }
            ];
        } else {
            const type = SYSTEM_INSTRUCTION_LAYOUTS.Assign;
            data = encodeData(type, {
                programId: toBuffer(params.programId.toBuffer())
            });
            keys = [
                {
                    pubkey: params.accountPubkey,
                    isSigner: true,
                    isWritable: true
                }
            ];
        }
        return new TransactionInstruction({
            keys,
            programId: this.programId,
            data
        });
    }
    /**
   * Generate a transaction instruction that creates a new account at
   *   an address generated with `from`, a seed, and programId
   */ static createAccountWithSeed(params) {
        const type = SYSTEM_INSTRUCTION_LAYOUTS.CreateWithSeed;
        const data = encodeData(type, {
            base: toBuffer(params.basePubkey.toBuffer()),
            seed: params.seed,
            lamports: params.lamports,
            space: params.space,
            programId: toBuffer(params.programId.toBuffer())
        });
        let keys = [
            {
                pubkey: params.fromPubkey,
                isSigner: true,
                isWritable: true
            },
            {
                pubkey: params.newAccountPubkey,
                isSigner: false,
                isWritable: true
            }
        ];
        if (!params.basePubkey.equals(params.fromPubkey)) keys.push({
            pubkey: params.basePubkey,
            isSigner: true,
            isWritable: false
        });
        return new TransactionInstruction({
            keys,
            programId: this.programId,
            data
        });
    }
    /**
   * Generate a transaction that creates a new Nonce account
   */ static createNonceAccount(params) {
        const transaction = new Transaction();
        if ("basePubkey" in params && "seed" in params) transaction.add(SystemProgram.createAccountWithSeed({
            fromPubkey: params.fromPubkey,
            newAccountPubkey: params.noncePubkey,
            basePubkey: params.basePubkey,
            seed: params.seed,
            lamports: params.lamports,
            space: NONCE_ACCOUNT_LENGTH,
            programId: this.programId
        }));
        else transaction.add(SystemProgram.createAccount({
            fromPubkey: params.fromPubkey,
            newAccountPubkey: params.noncePubkey,
            lamports: params.lamports,
            space: NONCE_ACCOUNT_LENGTH,
            programId: this.programId
        }));
        const initParams = {
            noncePubkey: params.noncePubkey,
            authorizedPubkey: params.authorizedPubkey
        };
        transaction.add(this.nonceInitialize(initParams));
        return transaction;
    }
    /**
   * Generate an instruction to initialize a Nonce account
   */ static nonceInitialize(params) {
        const type = SYSTEM_INSTRUCTION_LAYOUTS.InitializeNonceAccount;
        const data = encodeData(type, {
            authorized: toBuffer(params.authorizedPubkey.toBuffer())
        });
        const instructionData = {
            keys: [
                {
                    pubkey: params.noncePubkey,
                    isSigner: false,
                    isWritable: true
                },
                {
                    pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,
                    isSigner: false,
                    isWritable: false
                },
                {
                    pubkey: SYSVAR_RENT_PUBKEY,
                    isSigner: false,
                    isWritable: false
                }
            ],
            programId: this.programId,
            data
        };
        return new TransactionInstruction(instructionData);
    }
    /**
   * Generate an instruction to advance the nonce in a Nonce account
   */ static nonceAdvance(params) {
        const type = SYSTEM_INSTRUCTION_LAYOUTS.AdvanceNonceAccount;
        const data = encodeData(type);
        const instructionData = {
            keys: [
                {
                    pubkey: params.noncePubkey,
                    isSigner: false,
                    isWritable: true
                },
                {
                    pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,
                    isSigner: false,
                    isWritable: false
                },
                {
                    pubkey: params.authorizedPubkey,
                    isSigner: true,
                    isWritable: false
                }
            ],
            programId: this.programId,
            data
        };
        return new TransactionInstruction(instructionData);
    }
    /**
   * Generate a transaction instruction that withdraws lamports from a Nonce account
   */ static nonceWithdraw(params) {
        const type = SYSTEM_INSTRUCTION_LAYOUTS.WithdrawNonceAccount;
        const data = encodeData(type, {
            lamports: params.lamports
        });
        return new TransactionInstruction({
            keys: [
                {
                    pubkey: params.noncePubkey,
                    isSigner: false,
                    isWritable: true
                },
                {
                    pubkey: params.toPubkey,
                    isSigner: false,
                    isWritable: true
                },
                {
                    pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,
                    isSigner: false,
                    isWritable: false
                },
                {
                    pubkey: SYSVAR_RENT_PUBKEY,
                    isSigner: false,
                    isWritable: false
                },
                {
                    pubkey: params.authorizedPubkey,
                    isSigner: true,
                    isWritable: false
                }
            ],
            programId: this.programId,
            data
        });
    }
    /**
   * Generate a transaction instruction that authorizes a new PublicKey as the authority
   * on a Nonce account.
   */ static nonceAuthorize(params) {
        const type = SYSTEM_INSTRUCTION_LAYOUTS.AuthorizeNonceAccount;
        const data = encodeData(type, {
            authorized: toBuffer(params.newAuthorizedPubkey.toBuffer())
        });
        return new TransactionInstruction({
            keys: [
                {
                    pubkey: params.noncePubkey,
                    isSigner: false,
                    isWritable: true
                },
                {
                    pubkey: params.authorizedPubkey,
                    isSigner: true,
                    isWritable: false
                }
            ],
            programId: this.programId,
            data
        });
    }
    /**
   * Generate a transaction instruction that allocates space in an account without funding
   */ static allocate(params) {
        let data;
        let keys;
        if ("basePubkey" in params) {
            const type = SYSTEM_INSTRUCTION_LAYOUTS.AllocateWithSeed;
            data = encodeData(type, {
                base: toBuffer(params.basePubkey.toBuffer()),
                seed: params.seed,
                space: params.space,
                programId: toBuffer(params.programId.toBuffer())
            });
            keys = [
                {
                    pubkey: params.accountPubkey,
                    isSigner: false,
                    isWritable: true
                },
                {
                    pubkey: params.basePubkey,
                    isSigner: true,
                    isWritable: false
                }
            ];
        } else {
            const type = SYSTEM_INSTRUCTION_LAYOUTS.Allocate;
            data = encodeData(type, {
                space: params.space
            });
            keys = [
                {
                    pubkey: params.accountPubkey,
                    isSigner: true,
                    isWritable: true
                }
            ];
        }
        return new TransactionInstruction({
            keys,
            programId: this.programId,
            data
        });
    }
}
SystemProgram.programId = new PublicKey("11111111111111111111111111111111");
// Keep program chunks under PACKET_DATA_SIZE, leaving enough room for the
// rest of the Transaction fields
//
// TODO: replace 300 with a proper constant for the size of the other
// Transaction fields
const CHUNK_SIZE = PACKET_DATA_SIZE - 300;
/**
 * Program loader interface
 */ class Loader {
    /**
   * @internal
   */ constructor(){}
    /**
   * Amount of program data placed in each load Transaction
   */ /**
   * Minimum number of signatures required to load a program not including
   * retries
   *
   * Can be used to calculate transaction fees
   */ static getMinNumSignatures(dataLength) {
        return 2 * // Every transaction requires two signatures (payer + program)
        (Math.ceil(dataLength / Loader.chunkSize) + 1 + // Add one for Create transaction
        1 // Add one for Finalize transaction
        );
    }
    /**
   * Loads a generic program
   *
   * @param connection The connection to use
   * @param payer System account that pays to load the program
   * @param program Account to load the program into
   * @param programId Public key that identifies the loader
   * @param data Program octets
   * @return true if program was loaded successfully, false if program was already loaded
   */ static async load(connection, payer, program, programId, data) {
        {
            const balanceNeeded = await connection.getMinimumBalanceForRentExemption(data.length);
            // Fetch program account info to check if it has already been created
            const programInfo = await connection.getAccountInfo(program.publicKey, "confirmed");
            let transaction = null;
            if (programInfo !== null) {
                if (programInfo.executable) {
                    console.error("Program load failed, account is already executable");
                    return false;
                }
                if (programInfo.data.length !== data.length) {
                    transaction = transaction || new Transaction();
                    transaction.add(SystemProgram.allocate({
                        accountPubkey: program.publicKey,
                        space: data.length
                    }));
                }
                if (!programInfo.owner.equals(programId)) {
                    transaction = transaction || new Transaction();
                    transaction.add(SystemProgram.assign({
                        accountPubkey: program.publicKey,
                        programId
                    }));
                }
                if (programInfo.lamports < balanceNeeded) {
                    transaction = transaction || new Transaction();
                    transaction.add(SystemProgram.transfer({
                        fromPubkey: payer.publicKey,
                        toPubkey: program.publicKey,
                        lamports: balanceNeeded - programInfo.lamports
                    }));
                }
            } else transaction = new Transaction().add(SystemProgram.createAccount({
                fromPubkey: payer.publicKey,
                newAccountPubkey: program.publicKey,
                lamports: balanceNeeded > 0 ? balanceNeeded : 1,
                space: data.length,
                programId
            }));
            // If the account is already created correctly, skip this step
            // and proceed directly to loading instructions
            if (transaction !== null) await sendAndConfirmTransaction(connection, transaction, [
                payer,
                program
            ], {
                commitment: "confirmed"
            });
        }
        const dataLayout = _bufferLayout.struct([
            _bufferLayout.u32("instruction"),
            _bufferLayout.u32("offset"),
            _bufferLayout.u32("bytesLength"),
            _bufferLayout.u32("bytesLengthPadding"),
            _bufferLayout.seq(_bufferLayout.u8("byte"), _bufferLayout.offset(_bufferLayout.u32(), -8), "bytes")
        ]);
        const chunkSize = Loader.chunkSize;
        let offset = 0;
        let array = data;
        let transactions = [];
        while(array.length > 0){
            const bytes = array.slice(0, chunkSize);
            const data = (0, _buffer.Buffer).alloc(chunkSize + 16);
            dataLayout.encode({
                instruction: 0,
                // Load instruction
                offset,
                bytes: bytes,
                bytesLength: 0,
                bytesLengthPadding: 0
            }, data);
            const transaction = new Transaction().add({
                keys: [
                    {
                        pubkey: program.publicKey,
                        isSigner: true,
                        isWritable: true
                    }
                ],
                programId,
                data
            });
            transactions.push(sendAndConfirmTransaction(connection, transaction, [
                payer,
                program
            ], {
                commitment: "confirmed"
            }));
            // Delay between sends in an attempt to reduce rate limit errors
            if (connection._rpcEndpoint.includes("solana.com")) {
                const REQUESTS_PER_SECOND = 4;
                await sleep(1000 / REQUESTS_PER_SECOND);
            }
            offset += chunkSize;
            array = array.slice(chunkSize);
        }
        await Promise.all(transactions);
        // Finalize the account loaded with program data for execution
        {
            const dataLayout = _bufferLayout.struct([
                _bufferLayout.u32("instruction")
            ]);
            const data = (0, _buffer.Buffer).alloc(dataLayout.span);
            dataLayout.encode({
                instruction: 1 // Finalize instruction
            }, data);
            const transaction = new Transaction().add({
                keys: [
                    {
                        pubkey: program.publicKey,
                        isSigner: true,
                        isWritable: true
                    },
                    {
                        pubkey: SYSVAR_RENT_PUBKEY,
                        isSigner: false,
                        isWritable: false
                    }
                ],
                programId,
                data
            });
            const deployCommitment = "processed";
            const finalizeSignature = await connection.sendTransaction(transaction, [
                payer,
                program
            ], {
                preflightCommitment: deployCommitment
            });
            const { context, value } = await connection.confirmTransaction({
                signature: finalizeSignature,
                lastValidBlockHeight: transaction.lastValidBlockHeight,
                blockhash: transaction.recentBlockhash
            }, deployCommitment);
            if (value.err) throw new Error(`Transaction ${finalizeSignature} failed (${JSON.stringify(value)})`);
            // We prevent programs from being usable until the slot after their deployment.
            // See https://github.com/solana-labs/solana/pull/29654
            while(true // eslint-disable-line no-constant-condition
            ){
                try {
                    const currentSlot = await connection.getSlot({
                        commitment: deployCommitment
                    });
                    if (currentSlot > context.slot) break;
                } catch  {
                /* empty */ }
                await new Promise((resolve)=>setTimeout(resolve, Math.round(MS_PER_SLOT / 2)));
            }
        }
        // success
        return true;
    }
}
Loader.chunkSize = CHUNK_SIZE;
/**
 * @deprecated Deprecated since Solana v1.17.20.
 */ const BPF_LOADER_PROGRAM_ID = new PublicKey("BPFLoader2111111111111111111111111111111111");
/**
 * Factory class for transactions to interact with a program loader
 *
 * @deprecated Deprecated since Solana v1.17.20.
 */ class BpfLoader {
    /**
   * Minimum number of signatures required to load a program not including
   * retries
   *
   * Can be used to calculate transaction fees
   */ static getMinNumSignatures(dataLength) {
        return Loader.getMinNumSignatures(dataLength);
    }
    /**
   * Load a SBF program
   *
   * @param connection The connection to use
   * @param payer Account that will pay program loading fees
   * @param program Account to load the program into
   * @param elf The entire ELF containing the SBF program
   * @param loaderProgramId The program id of the BPF loader to use
   * @return true if program was loaded successfully, false if program was already loaded
   */ static load(connection, payer, program, elf, loaderProgramId) {
        return Loader.load(connection, payer, program, loaderProgramId, elf);
    }
}
function getDefaultExportFromCjs(x) {
    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
var fastStableStringify$1;
var hasRequiredFastStableStringify;
function requireFastStableStringify() {
    if (hasRequiredFastStableStringify) return fastStableStringify$1;
    hasRequiredFastStableStringify = 1;
    var objToString = Object.prototype.toString;
    var objKeys = Object.keys || function(obj) {
        var keys = [];
        for(var name in obj)keys.push(name);
        return keys;
    };
    function stringify(val, isArrayProp) {
        var i, max, str, keys, key, propVal, toStr;
        if (val === true) return "true";
        if (val === false) return "false";
        switch(typeof val){
            case "object":
                if (val === null) return null;
                else if (val.toJSON && typeof val.toJSON === "function") return stringify(val.toJSON(), isArrayProp);
                else {
                    toStr = objToString.call(val);
                    if (toStr === "[object Array]") {
                        str = "[";
                        max = val.length - 1;
                        for(i = 0; i < max; i++)str += stringify(val[i], true) + ",";
                        if (max > -1) str += stringify(val[i], true);
                        return str + "]";
                    } else if (toStr === "[object Object]") {
                        // only object is left
                        keys = objKeys(val).sort();
                        max = keys.length;
                        str = "";
                        i = 0;
                        while(i < max){
                            key = keys[i];
                            propVal = stringify(val[key], false);
                            if (propVal !== undefined) {
                                if (str) str += ",";
                                str += JSON.stringify(key) + ":" + propVal;
                            }
                            i++;
                        }
                        return "{" + str + "}";
                    } else return JSON.stringify(val);
                }
            case "function":
            case "undefined":
                return isArrayProp ? null : undefined;
            case "string":
                return JSON.stringify(val);
            default:
                return isFinite(val) ? val : null;
        }
    }
    fastStableStringify$1 = function(val) {
        var returnVal = stringify(val, false);
        if (returnVal !== undefined) return "" + returnVal;
    };
    return fastStableStringify$1;
}
var fastStableStringifyExports = /*@__PURE__*/ requireFastStableStringify();
var fastStableStringify = /*@__PURE__*/ getDefaultExportFromCjs(fastStableStringifyExports);
const MINIMUM_SLOT_PER_EPOCH = 32;
// Returns the number of trailing zeros in the binary representation of self.
function trailingZeros(n) {
    let trailingZeros = 0;
    while(n > 1){
        n /= 2;
        trailingZeros++;
    }
    return trailingZeros;
}
// Returns the smallest power of two greater than or equal to n
function nextPowerOfTwo(n) {
    if (n === 0) return 1;
    n--;
    n |= n >> 1;
    n |= n >> 2;
    n |= n >> 4;
    n |= n >> 8;
    n |= n >> 16;
    n |= n >> 32;
    return n + 1;
}
/**
 * Epoch schedule
 * (see https://docs.solana.com/terminology#epoch)
 * Can be retrieved with the {@link Connection.getEpochSchedule} method
 */ class EpochSchedule {
    constructor(slotsPerEpoch, leaderScheduleSlotOffset, warmup, firstNormalEpoch, firstNormalSlot){
        /** The maximum number of slots in each epoch */ this.slotsPerEpoch = void 0;
        /** The number of slots before beginning of an epoch to calculate a leader schedule for that epoch */ this.leaderScheduleSlotOffset = void 0;
        /** Indicates whether epochs start short and grow */ this.warmup = void 0;
        /** The first epoch with `slotsPerEpoch` slots */ this.firstNormalEpoch = void 0;
        /** The first slot of `firstNormalEpoch` */ this.firstNormalSlot = void 0;
        this.slotsPerEpoch = slotsPerEpoch;
        this.leaderScheduleSlotOffset = leaderScheduleSlotOffset;
        this.warmup = warmup;
        this.firstNormalEpoch = firstNormalEpoch;
        this.firstNormalSlot = firstNormalSlot;
    }
    getEpoch(slot) {
        return this.getEpochAndSlotIndex(slot)[0];
    }
    getEpochAndSlotIndex(slot) {
        if (slot < this.firstNormalSlot) {
            const epoch = trailingZeros(nextPowerOfTwo(slot + MINIMUM_SLOT_PER_EPOCH + 1)) - trailingZeros(MINIMUM_SLOT_PER_EPOCH) - 1;
            const epochLen = this.getSlotsInEpoch(epoch);
            const slotIndex = slot - (epochLen - MINIMUM_SLOT_PER_EPOCH);
            return [
                epoch,
                slotIndex
            ];
        } else {
            const normalSlotIndex = slot - this.firstNormalSlot;
            const normalEpochIndex = Math.floor(normalSlotIndex / this.slotsPerEpoch);
            const epoch = this.firstNormalEpoch + normalEpochIndex;
            const slotIndex = normalSlotIndex % this.slotsPerEpoch;
            return [
                epoch,
                slotIndex
            ];
        }
    }
    getFirstSlotInEpoch(epoch) {
        if (epoch <= this.firstNormalEpoch) return (Math.pow(2, epoch) - 1) * MINIMUM_SLOT_PER_EPOCH;
        else return (epoch - this.firstNormalEpoch) * this.slotsPerEpoch + this.firstNormalSlot;
    }
    getLastSlotInEpoch(epoch) {
        return this.getFirstSlotInEpoch(epoch) + this.getSlotsInEpoch(epoch) - 1;
    }
    getSlotsInEpoch(epoch) {
        if (epoch < this.firstNormalEpoch) return Math.pow(2, epoch + trailingZeros(MINIMUM_SLOT_PER_EPOCH));
        else return this.slotsPerEpoch;
    }
}
var fetchImpl = globalThis.fetch;
class RpcWebSocketClient extends (0, _rpcWebsockets.CommonClient) {
    constructor(address, options, generate_request_id){
        const webSocketFactory = (url)=>{
            const rpc = (0, _rpcWebsockets.WebSocket)(url, {
                autoconnect: true,
                max_reconnects: 5,
                reconnect: true,
                reconnect_interval: 1000,
                ...options
            });
            if ("socket" in rpc) this.underlyingSocket = rpc.socket;
            else this.underlyingSocket = rpc;
            return rpc;
        };
        super(webSocketFactory, address, options, generate_request_id);
        this.underlyingSocket = void 0;
    }
    call(...args) {
        const readyState = this.underlyingSocket?.readyState;
        if (readyState === 1 /* WebSocket.OPEN */ ) return super.call(...args);
        return Promise.reject(new Error("Tried to call a JSON-RPC method `" + args[0] + "` but the socket was not `CONNECTING` or `OPEN` (`readyState` was " + readyState + ")"));
    }
    notify(...args) {
        const readyState = this.underlyingSocket?.readyState;
        if (readyState === 1 /* WebSocket.OPEN */ ) return super.notify(...args);
        return Promise.reject(new Error("Tried to send a JSON-RPC notification `" + args[0] + "` but the socket was not `CONNECTING` or `OPEN` (`readyState` was " + readyState + ")"));
    }
}
/**
 * @internal
 */ /**
 * Decode account data buffer using an AccountType
 * @internal
 */ function decodeData(type, data) {
    let decoded;
    try {
        decoded = type.layout.decode(data);
    } catch (err) {
        throw new Error("invalid instruction; " + err);
    }
    if (decoded.typeIndex !== type.index) throw new Error(`invalid account data; account type mismatch ${decoded.typeIndex} != ${type.index}`);
    return decoded;
}
/// The serialized size of lookup table metadata
const LOOKUP_TABLE_META_SIZE = 56;
class AddressLookupTableAccount {
    constructor(args){
        this.key = void 0;
        this.state = void 0;
        this.key = args.key;
        this.state = args.state;
    }
    isActive() {
        const U64_MAX = BigInt("0xffffffffffffffff");
        return this.state.deactivationSlot === U64_MAX;
    }
    static deserialize(accountData) {
        const meta = decodeData(LookupTableMetaLayout, accountData);
        const serializedAddressesLen = accountData.length - LOOKUP_TABLE_META_SIZE;
        assert(serializedAddressesLen >= 0, "lookup table is invalid");
        assert(serializedAddressesLen % 32 === 0, "lookup table is invalid");
        const numSerializedAddresses = serializedAddressesLen / 32;
        const { addresses } = _bufferLayout.struct([
            _bufferLayout.seq(publicKey(), numSerializedAddresses, "addresses")
        ]).decode(accountData.slice(LOOKUP_TABLE_META_SIZE));
        return {
            deactivationSlot: meta.deactivationSlot,
            lastExtendedSlot: meta.lastExtendedSlot,
            lastExtendedSlotStartIndex: meta.lastExtendedStartIndex,
            authority: meta.authority.length !== 0 ? new PublicKey(meta.authority[0]) : undefined,
            addresses: addresses.map((address)=>new PublicKey(address))
        };
    }
}
const LookupTableMetaLayout = {
    index: 1,
    layout: _bufferLayout.struct([
        _bufferLayout.u32("typeIndex"),
        u64("deactivationSlot"),
        _bufferLayout.nu64("lastExtendedSlot"),
        _bufferLayout.u8("lastExtendedStartIndex"),
        _bufferLayout.u8(),
        // option
        _bufferLayout.seq(publicKey(), _bufferLayout.offset(_bufferLayout.u8(), -1), "authority")
    ])
};
const URL_RE = /^[^:]+:\/\/([^:[]+|\[[^\]]+\])(:\d+)?(.*)/i;
function makeWebsocketUrl(endpoint) {
    const matches = endpoint.match(URL_RE);
    if (matches == null) throw TypeError(`Failed to validate endpoint URL \`${endpoint}\``);
    const [_, // eslint-disable-line @typescript-eslint/no-unused-vars
    hostish, portWithColon, rest] = matches;
    const protocol = endpoint.startsWith("https:") ? "wss:" : "ws:";
    const startPort = portWithColon == null ? null : parseInt(portWithColon.slice(1), 10);
    const websocketPort = // Only shift the port by +1 as a convention for ws(s) only if given endpoint
    // is explicitly specifying the endpoint port (HTTP-based RPC), assuming
    // we're directly trying to connect to agave-validator's ws listening port.
    // When the endpoint omits the port, we're connecting to the protocol
    // default ports: http(80) or https(443) and it's assumed we're behind a reverse
    // proxy which manages WebSocket upgrade and backend port redirection.
    startPort == null ? "" : `:${startPort + 1}`;
    return `${protocol}//${hostish}${websocketPort}${rest}`;
}
const PublicKeyFromString = (0, _superstruct.coerce)((0, _superstruct.instance)(PublicKey), (0, _superstruct.string)(), (value)=>new PublicKey(value));
const RawAccountDataResult = (0, _superstruct.tuple)([
    (0, _superstruct.string)(),
    (0, _superstruct.literal)("base64")
]);
const BufferFromRawAccountData = (0, _superstruct.coerce)((0, _superstruct.instance)((0, _buffer.Buffer)), RawAccountDataResult, (value)=>(0, _buffer.Buffer).from(value[0], "base64"));
/**
 * Attempt to use a recent blockhash for up to 30 seconds
 * @internal
 */ const BLOCKHASH_CACHE_TIMEOUT_MS = 30000;
/**
 * HACK.
 * Copied from rpc-websockets/dist/lib/client.
 * Otherwise, `yarn build` fails with:
 * https://gist.github.com/steveluscher/c057eca81d479ef705cdb53162f9971d
 */ /** @internal */ /** @internal */ /** @internal */ /** @internal */ /** @internal */ /**
 * @internal
 * Every subscription contains the args used to open the subscription with
 * the server, and a list of callers interested in notifications.
 */ /**
 * @internal
 * A subscription may be in various states of connectedness. Only when it is
 * fully connected will it have a server subscription id associated with it.
 * This id can be returned to the server to unsubscribe the client entirely.
 */ /**
 * A type that encapsulates a subscription's RPC method
 * names and notification (callback) signature.
 */ /**
 * @internal
 * Utility type that keeps tagged unions intact while omitting properties.
 */ /**
 * @internal
 * This type represents a single subscribable 'topic.' It's made up of:
 *
 * - The args used to open the subscription with the server,
 * - The state of the subscription, in terms of its connectedness, and
 * - The set of callbacks to call when the server publishes notifications
 *
 * This record gets indexed by `SubscriptionConfigHash` and is used to
 * set up subscriptions, fan out notifications, and track subscription state.
 */ /**
 * @internal
 */ /**
 * Extra contextual information for RPC responses
 */ /**
 * Options for sending transactions
 */ /**
 * Options for confirming transactions
 */ /**
 * Options for getConfirmedSignaturesForAddress2
 */ /**
 * Options for getSignaturesForAddress
 */ /**
 * RPC Response with extra contextual information
 */ /**
 * A strategy for confirming transactions that uses the last valid
 * block height for a given blockhash to check for transaction expiration.
 */ /**
 * A strategy for confirming durable nonce transactions.
 */ /**
 * Properties shared by all transaction confirmation strategies
 */ /**
 * This type represents all transaction confirmation strategies
 */ /* @internal */ function assertEndpointUrl(putativeUrl) {
    if (/^https?:/.test(putativeUrl) === false) throw new TypeError("Endpoint URL must start with `http:` or `https:`.");
    return putativeUrl;
}
/** @internal */ function extractCommitmentFromConfig(commitmentOrConfig) {
    let commitment;
    let config;
    if (typeof commitmentOrConfig === "string") commitment = commitmentOrConfig;
    else if (commitmentOrConfig) {
        const { commitment: specifiedCommitment, ...specifiedConfig } = commitmentOrConfig;
        commitment = specifiedCommitment;
        config = specifiedConfig;
    }
    return {
        commitment,
        config
    };
}
/**
 * @internal
 */ function applyDefaultMemcmpEncodingToFilters(filters) {
    return filters.map((filter)=>"memcmp" in filter ? {
            ...filter,
            memcmp: {
                ...filter.memcmp,
                encoding: filter.memcmp.encoding ?? "base58"
            }
        } : filter);
}
/**
 * @internal
 */ function createRpcResult(result) {
    return (0, _superstruct.union)([
        (0, _superstruct.type)({
            jsonrpc: (0, _superstruct.literal)("2.0"),
            id: (0, _superstruct.string)(),
            result
        }),
        (0, _superstruct.type)({
            jsonrpc: (0, _superstruct.literal)("2.0"),
            id: (0, _superstruct.string)(),
            error: (0, _superstruct.type)({
                code: (0, _superstruct.unknown)(),
                message: (0, _superstruct.string)(),
                data: (0, _superstruct.optional)((0, _superstruct.any)())
            })
        })
    ]);
}
const UnknownRpcResult = createRpcResult((0, _superstruct.unknown)());
/**
 * @internal
 */ function jsonRpcResult(schema) {
    return (0, _superstruct.coerce)(createRpcResult(schema), UnknownRpcResult, (value)=>{
        if ("error" in value) return value;
        else return {
            ...value,
            result: (0, _superstruct.create)(value.result, schema)
        };
    });
}
/**
 * @internal
 */ function jsonRpcResultAndContext(value) {
    return jsonRpcResult((0, _superstruct.type)({
        context: (0, _superstruct.type)({
            slot: (0, _superstruct.number)()
        }),
        value
    }));
}
/**
 * @internal
 */ function notificationResultAndContext(value) {
    return (0, _superstruct.type)({
        context: (0, _superstruct.type)({
            slot: (0, _superstruct.number)()
        }),
        value
    });
}
/**
 * @internal
 */ function versionedMessageFromResponse(version, response) {
    if (version === 0) return new MessageV0({
        header: response.header,
        staticAccountKeys: response.accountKeys.map((accountKey)=>new PublicKey(accountKey)),
        recentBlockhash: response.recentBlockhash,
        compiledInstructions: response.instructions.map((ix)=>({
                programIdIndex: ix.programIdIndex,
                accountKeyIndexes: ix.accounts,
                data: (0, _bs58Default.default).decode(ix.data)
            })),
        addressTableLookups: response.addressTableLookups
    });
    else return new Message(response);
}
/**
 * The level of commitment desired when querying state
 * <pre>
 *   'processed': Query the most recent block which has reached 1 confirmation by the connected node
 *   'confirmed': Query the most recent block which has reached 1 confirmation by the cluster
 *   'finalized': Query the most recent block which has been finalized by the cluster
 * </pre>
 */ // Deprecated as of v1.5.5
/**
 * A subset of Commitment levels, which are at least optimistically confirmed
 * <pre>
 *   'confirmed': Query the most recent block which has reached 1 confirmation by the cluster
 *   'finalized': Query the most recent block which has been finalized by the cluster
 * </pre>
 */ /**
 * Filter for largest accounts query
 * <pre>
 *   'circulating':    Return the largest accounts that are part of the circulating supply
 *   'nonCirculating': Return the largest accounts that are not part of the circulating supply
 * </pre>
 */ /**
 * Configuration object for changing `getAccountInfo` query behavior
 */ /**
 * Configuration object for changing `getBalance` query behavior
 */ /**
 * Configuration object for changing `getBlock` query behavior
 */ /**
 * Configuration object for changing `getBlock` query behavior
 */ /**
 * Configuration object for changing `getStakeMinimumDelegation` query behavior
 */ /**
 * Configuration object for changing `getBlockHeight` query behavior
 */ /**
 * Configuration object for changing `getEpochInfo` query behavior
 */ /**
 * Configuration object for changing `getInflationReward` query behavior
 */ /**
 * Configuration object for changing `getLatestBlockhash` query behavior
 */ /**
 * Configuration object for changing `isBlockhashValid` query behavior
 */ /**
 * Configuration object for changing `getSlot` query behavior
 */ /**
 * Configuration object for changing `getSlotLeader` query behavior
 */ /**
 * Configuration object for changing `getTransaction` query behavior
 */ /**
 * Configuration object for changing `getTransaction` query behavior
 */ /**
 * Configuration object for changing `getLargestAccounts` query behavior
 */ /**
 * Configuration object for changing `getSupply` request behavior
 */ /**
 * Configuration object for changing query behavior
 */ /**
 * Information describing a cluster node
 */ /**
 * Information describing a vote account
 */ /**
 * A collection of cluster vote accounts
 */ /**
 * Network Inflation
 * (see https://docs.solana.com/implemented-proposals/ed_overview)
 */ const GetInflationGovernorResult = (0, _superstruct.type)({
    foundation: (0, _superstruct.number)(),
    foundationTerm: (0, _superstruct.number)(),
    initial: (0, _superstruct.number)(),
    taper: (0, _superstruct.number)(),
    terminal: (0, _superstruct.number)()
});
/**
 * The inflation reward for an epoch
 */ /**
 * Expected JSON RPC response for the "getInflationReward" message
 */ const GetInflationRewardResult = jsonRpcResult((0, _superstruct.array)((0, _superstruct.nullable)((0, _superstruct.type)({
    epoch: (0, _superstruct.number)(),
    effectiveSlot: (0, _superstruct.number)(),
    amount: (0, _superstruct.number)(),
    postBalance: (0, _superstruct.number)(),
    commission: (0, _superstruct.optional)((0, _superstruct.nullable)((0, _superstruct.number)()))
}))));
/**
 * Configuration object for changing `getRecentPrioritizationFees` query behavior
 */ /**
 * Expected JSON RPC response for the "getRecentPrioritizationFees" message
 */ const GetRecentPrioritizationFeesResult = (0, _superstruct.array)((0, _superstruct.type)({
    slot: (0, _superstruct.number)(),
    prioritizationFee: (0, _superstruct.number)()
}));
/**
 * Expected JSON RPC response for the "getInflationRate" message
 */ const GetInflationRateResult = (0, _superstruct.type)({
    total: (0, _superstruct.number)(),
    validator: (0, _superstruct.number)(),
    foundation: (0, _superstruct.number)(),
    epoch: (0, _superstruct.number)()
});
/**
 * Information about the current epoch
 */ const GetEpochInfoResult = (0, _superstruct.type)({
    epoch: (0, _superstruct.number)(),
    slotIndex: (0, _superstruct.number)(),
    slotsInEpoch: (0, _superstruct.number)(),
    absoluteSlot: (0, _superstruct.number)(),
    blockHeight: (0, _superstruct.optional)((0, _superstruct.number)()),
    transactionCount: (0, _superstruct.optional)((0, _superstruct.number)())
});
const GetEpochScheduleResult = (0, _superstruct.type)({
    slotsPerEpoch: (0, _superstruct.number)(),
    leaderScheduleSlotOffset: (0, _superstruct.number)(),
    warmup: (0, _superstruct.boolean)(),
    firstNormalEpoch: (0, _superstruct.number)(),
    firstNormalSlot: (0, _superstruct.number)()
});
/**
 * Leader schedule
 * (see https://docs.solana.com/terminology#leader-schedule)
 */ const GetLeaderScheduleResult = (0, _superstruct.record)((0, _superstruct.string)(), (0, _superstruct.array)((0, _superstruct.number)()));
/**
 * Transaction error or null
 */ const TransactionErrorResult = (0, _superstruct.nullable)((0, _superstruct.union)([
    (0, _superstruct.type)({}),
    (0, _superstruct.string)()
]));
/**
 * Signature status for a transaction
 */ const SignatureStatusResult = (0, _superstruct.type)({
    err: TransactionErrorResult
});
/**
 * Transaction signature received notification
 */ const SignatureReceivedResult = (0, _superstruct.literal)("receivedSignature");
/**
 * Version info for a node
 */ const VersionResult = (0, _superstruct.type)({
    "solana-core": (0, _superstruct.string)(),
    "feature-set": (0, _superstruct.optional)((0, _superstruct.number)())
});
const ParsedInstructionStruct = (0, _superstruct.type)({
    program: (0, _superstruct.string)(),
    programId: PublicKeyFromString,
    parsed: (0, _superstruct.unknown)()
});
const PartiallyDecodedInstructionStruct = (0, _superstruct.type)({
    programId: PublicKeyFromString,
    accounts: (0, _superstruct.array)(PublicKeyFromString),
    data: (0, _superstruct.string)()
});
const SimulatedTransactionResponseStruct = jsonRpcResultAndContext((0, _superstruct.type)({
    err: (0, _superstruct.nullable)((0, _superstruct.union)([
        (0, _superstruct.type)({}),
        (0, _superstruct.string)()
    ])),
    logs: (0, _superstruct.nullable)((0, _superstruct.array)((0, _superstruct.string)())),
    accounts: (0, _superstruct.optional)((0, _superstruct.nullable)((0, _superstruct.array)((0, _superstruct.nullable)((0, _superstruct.type)({
        executable: (0, _superstruct.boolean)(),
        owner: (0, _superstruct.string)(),
        lamports: (0, _superstruct.number)(),
        data: (0, _superstruct.array)((0, _superstruct.string)()),
        rentEpoch: (0, _superstruct.optional)((0, _superstruct.number)())
    }))))),
    unitsConsumed: (0, _superstruct.optional)((0, _superstruct.number)()),
    returnData: (0, _superstruct.optional)((0, _superstruct.nullable)((0, _superstruct.type)({
        programId: (0, _superstruct.string)(),
        data: (0, _superstruct.tuple)([
            (0, _superstruct.string)(),
            (0, _superstruct.literal)("base64")
        ])
    }))),
    innerInstructions: (0, _superstruct.optional)((0, _superstruct.nullable)((0, _superstruct.array)((0, _superstruct.type)({
        index: (0, _superstruct.number)(),
        instructions: (0, _superstruct.array)((0, _superstruct.union)([
            ParsedInstructionStruct,
            PartiallyDecodedInstructionStruct
        ]))
    }))))
}));
/**
 * Metadata for a parsed confirmed transaction on the ledger
 *
 * @deprecated Deprecated since RPC v1.8.0. Please use {@link ParsedTransactionMeta} instead.
 */ /**
 * Collection of addresses loaded by a transaction using address table lookups
 */ /**
 * Metadata for a parsed transaction on the ledger
 */ /**
 * Metadata for a confirmed transaction on the ledger
 */ /**
 * A processed transaction from the RPC API
 */ /**
 * A processed transaction from the RPC API
 */ /**
 * A processed transaction message from the RPC API
 */ /**
 * A confirmed transaction on the ledger
 *
 * @deprecated Deprecated since RPC v1.8.0.
 */ /**
 * A partially decoded transaction instruction
 */ /**
 * A parsed transaction message account
 */ /**
 * A parsed transaction instruction
 */ /**
 * A parsed address table lookup
 */ /**
 * A parsed transaction message
 */ /**
 * A parsed transaction
 */ /**
 * A parsed and confirmed transaction on the ledger
 *
 * @deprecated Deprecated since RPC v1.8.0. Please use {@link ParsedTransactionWithMeta} instead.
 */ /**
 * A parsed transaction on the ledger with meta
 */ /**
 * A processed block fetched from the RPC API
 */ /**
 * A processed block fetched from the RPC API where the `transactionDetails` mode is `accounts`
 */ /**
 * A processed block fetched from the RPC API where the `transactionDetails` mode is `none`
 */ /**
 * A block with parsed transactions
 */ /**
 * A block with parsed transactions where the `transactionDetails` mode is `accounts`
 */ /**
 * A block with parsed transactions where the `transactionDetails` mode is `none`
 */ /**
 * A processed block fetched from the RPC API
 */ /**
 * A processed block fetched from the RPC API where the `transactionDetails` mode is `accounts`
 */ /**
 * A processed block fetched from the RPC API where the `transactionDetails` mode is `none`
 */ /**
 * A confirmed block on the ledger
 *
 * @deprecated Deprecated since RPC v1.8.0.
 */ /**
 * A Block on the ledger with signatures only
 */ /**
 * recent block production information
 */ /**
 * Expected JSON RPC response for the "getBlockProduction" message
 */ const BlockProductionResponseStruct = jsonRpcResultAndContext((0, _superstruct.type)({
    byIdentity: (0, _superstruct.record)((0, _superstruct.string)(), (0, _superstruct.array)((0, _superstruct.number)())),
    range: (0, _superstruct.type)({
        firstSlot: (0, _superstruct.number)(),
        lastSlot: (0, _superstruct.number)()
    })
}));
/**
 * A performance sample
 */ function createRpcClient(url, httpHeaders, customFetch, fetchMiddleware, disableRetryOnRateLimit, httpAgent) {
    const fetch = customFetch ? customFetch : fetchImpl;
    let agent;
    if (httpAgent != null) console.warn("You have supplied an `httpAgent` when creating a `Connection` in a browser environment.It has been ignored; `httpAgent` is only used in Node environments.");
    let fetchWithMiddleware;
    if (fetchMiddleware) fetchWithMiddleware = async (info, init)=>{
        const modifiedFetchArgs = await new Promise((resolve, reject)=>{
            try {
                fetchMiddleware(info, init, (modifiedInfo, modifiedInit)=>resolve([
                        modifiedInfo,
                        modifiedInit
                    ]));
            } catch (error) {
                reject(error);
            }
        });
        return await fetch(...modifiedFetchArgs);
    };
    const clientBrowser = new (0, _browserDefault.default)(async (request, callback)=>{
        const options = {
            method: "POST",
            body: request,
            agent,
            headers: Object.assign({
                "Content-Type": "application/json"
            }, httpHeaders || {}, COMMON_HTTP_HEADERS)
        };
        try {
            let too_many_requests_retries = 5;
            let res;
            let waitTime = 500;
            for(;;){
                if (fetchWithMiddleware) res = await fetchWithMiddleware(url, options);
                else res = await fetch(url, options);
                if (res.status !== 429 /* Too many requests */ ) break;
                if (disableRetryOnRateLimit === true) break;
                too_many_requests_retries -= 1;
                if (too_many_requests_retries === 0) break;
                console.error(`Server responded with ${res.status} ${res.statusText}.  Retrying after ${waitTime}ms delay...`);
                await sleep(waitTime);
                waitTime *= 2;
            }
            const text = await res.text();
            if (res.ok) callback(null, text);
            else callback(new Error(`${res.status} ${res.statusText}: ${text}`));
        } catch (err) {
            if (err instanceof Error) callback(err);
        }
    }, {});
    return clientBrowser;
}
function createRpcRequest(client) {
    return (method, args)=>{
        return new Promise((resolve, reject)=>{
            client.request(method, args, (err, response)=>{
                if (err) {
                    reject(err);
                    return;
                }
                resolve(response);
            });
        });
    };
}
function createRpcBatchRequest(client) {
    return (requests)=>{
        return new Promise((resolve, reject)=>{
            // Do nothing if requests is empty
            if (requests.length === 0) resolve([]);
            const batch = requests.map((params)=>{
                return client.request(params.methodName, params.args);
            });
            client.request(batch, (err, response)=>{
                if (err) {
                    reject(err);
                    return;
                }
                resolve(response);
            });
        });
    };
}
/**
 * Expected JSON RPC response for the "getInflationGovernor" message
 */ const GetInflationGovernorRpcResult = jsonRpcResult(GetInflationGovernorResult);
/**
 * Expected JSON RPC response for the "getInflationRate" message
 */ const GetInflationRateRpcResult = jsonRpcResult(GetInflationRateResult);
/**
 * Expected JSON RPC response for the "getRecentPrioritizationFees" message
 */ const GetRecentPrioritizationFeesRpcResult = jsonRpcResult(GetRecentPrioritizationFeesResult);
/**
 * Expected JSON RPC response for the "getEpochInfo" message
 */ const GetEpochInfoRpcResult = jsonRpcResult(GetEpochInfoResult);
/**
 * Expected JSON RPC response for the "getEpochSchedule" message
 */ const GetEpochScheduleRpcResult = jsonRpcResult(GetEpochScheduleResult);
/**
 * Expected JSON RPC response for the "getLeaderSchedule" message
 */ const GetLeaderScheduleRpcResult = jsonRpcResult(GetLeaderScheduleResult);
/**
 * Expected JSON RPC response for the "minimumLedgerSlot" and "getFirstAvailableBlock" messages
 */ const SlotRpcResult = jsonRpcResult((0, _superstruct.number)());
/**
 * Supply
 */ /**
 * Expected JSON RPC response for the "getSupply" message
 */ const GetSupplyRpcResult = jsonRpcResultAndContext((0, _superstruct.type)({
    total: (0, _superstruct.number)(),
    circulating: (0, _superstruct.number)(),
    nonCirculating: (0, _superstruct.number)(),
    nonCirculatingAccounts: (0, _superstruct.array)(PublicKeyFromString)
}));
/**
 * Token amount object which returns a token amount in different formats
 * for various client use cases.
 */ /**
 * Expected JSON RPC structure for token amounts
 */ const TokenAmountResult = (0, _superstruct.type)({
    amount: (0, _superstruct.string)(),
    uiAmount: (0, _superstruct.nullable)((0, _superstruct.number)()),
    decimals: (0, _superstruct.number)(),
    uiAmountString: (0, _superstruct.optional)((0, _superstruct.string)())
});
/**
 * Token address and balance.
 */ /**
 * Expected JSON RPC response for the "getTokenLargestAccounts" message
 */ const GetTokenLargestAccountsResult = jsonRpcResultAndContext((0, _superstruct.array)((0, _superstruct.type)({
    address: PublicKeyFromString,
    amount: (0, _superstruct.string)(),
    uiAmount: (0, _superstruct.nullable)((0, _superstruct.number)()),
    decimals: (0, _superstruct.number)(),
    uiAmountString: (0, _superstruct.optional)((0, _superstruct.string)())
})));
/**
 * Expected JSON RPC response for the "getTokenAccountsByOwner" message
 */ const GetTokenAccountsByOwner = jsonRpcResultAndContext((0, _superstruct.array)((0, _superstruct.type)({
    pubkey: PublicKeyFromString,
    account: (0, _superstruct.type)({
        executable: (0, _superstruct.boolean)(),
        owner: PublicKeyFromString,
        lamports: (0, _superstruct.number)(),
        data: BufferFromRawAccountData,
        rentEpoch: (0, _superstruct.number)()
    })
})));
const ParsedAccountDataResult = (0, _superstruct.type)({
    program: (0, _superstruct.string)(),
    parsed: (0, _superstruct.unknown)(),
    space: (0, _superstruct.number)()
});
/**
 * Expected JSON RPC response for the "getTokenAccountsByOwner" message with parsed data
 */ const GetParsedTokenAccountsByOwner = jsonRpcResultAndContext((0, _superstruct.array)((0, _superstruct.type)({
    pubkey: PublicKeyFromString,
    account: (0, _superstruct.type)({
        executable: (0, _superstruct.boolean)(),
        owner: PublicKeyFromString,
        lamports: (0, _superstruct.number)(),
        data: ParsedAccountDataResult,
        rentEpoch: (0, _superstruct.number)()
    })
})));
/**
 * Pair of an account address and its balance
 */ /**
 * Expected JSON RPC response for the "getLargestAccounts" message
 */ const GetLargestAccountsRpcResult = jsonRpcResultAndContext((0, _superstruct.array)((0, _superstruct.type)({
    lamports: (0, _superstruct.number)(),
    address: PublicKeyFromString
})));
/**
 * @internal
 */ const AccountInfoResult = (0, _superstruct.type)({
    executable: (0, _superstruct.boolean)(),
    owner: PublicKeyFromString,
    lamports: (0, _superstruct.number)(),
    data: BufferFromRawAccountData,
    rentEpoch: (0, _superstruct.number)()
});
/**
 * @internal
 */ const KeyedAccountInfoResult = (0, _superstruct.type)({
    pubkey: PublicKeyFromString,
    account: AccountInfoResult
});
const ParsedOrRawAccountData = (0, _superstruct.coerce)((0, _superstruct.union)([
    (0, _superstruct.instance)((0, _buffer.Buffer)),
    ParsedAccountDataResult
]), (0, _superstruct.union)([
    RawAccountDataResult,
    ParsedAccountDataResult
]), (value)=>{
    if (Array.isArray(value)) return (0, _superstruct.create)(value, BufferFromRawAccountData);
    else return value;
});
/**
 * @internal
 */ const ParsedAccountInfoResult = (0, _superstruct.type)({
    executable: (0, _superstruct.boolean)(),
    owner: PublicKeyFromString,
    lamports: (0, _superstruct.number)(),
    data: ParsedOrRawAccountData,
    rentEpoch: (0, _superstruct.number)()
});
const KeyedParsedAccountInfoResult = (0, _superstruct.type)({
    pubkey: PublicKeyFromString,
    account: ParsedAccountInfoResult
});
/**
 * @internal
 */ const StakeActivationResult = (0, _superstruct.type)({
    state: (0, _superstruct.union)([
        (0, _superstruct.literal)("active"),
        (0, _superstruct.literal)("inactive"),
        (0, _superstruct.literal)("activating"),
        (0, _superstruct.literal)("deactivating")
    ]),
    active: (0, _superstruct.number)(),
    inactive: (0, _superstruct.number)()
});
/**
 * Expected JSON RPC response for the "getConfirmedSignaturesForAddress2" message
 */ const GetConfirmedSignaturesForAddress2RpcResult = jsonRpcResult((0, _superstruct.array)((0, _superstruct.type)({
    signature: (0, _superstruct.string)(),
    slot: (0, _superstruct.number)(),
    err: TransactionErrorResult,
    memo: (0, _superstruct.nullable)((0, _superstruct.string)()),
    blockTime: (0, _superstruct.optional)((0, _superstruct.nullable)((0, _superstruct.number)()))
})));
/**
 * Expected JSON RPC response for the "getSignaturesForAddress" message
 */ const GetSignaturesForAddressRpcResult = jsonRpcResult((0, _superstruct.array)((0, _superstruct.type)({
    signature: (0, _superstruct.string)(),
    slot: (0, _superstruct.number)(),
    err: TransactionErrorResult,
    memo: (0, _superstruct.nullable)((0, _superstruct.string)()),
    blockTime: (0, _superstruct.optional)((0, _superstruct.nullable)((0, _superstruct.number)()))
})));
/***
 * Expected JSON RPC response for the "accountNotification" message
 */ const AccountNotificationResult = (0, _superstruct.type)({
    subscription: (0, _superstruct.number)(),
    result: notificationResultAndContext(AccountInfoResult)
});
/**
 * @internal
 */ const ProgramAccountInfoResult = (0, _superstruct.type)({
    pubkey: PublicKeyFromString,
    account: AccountInfoResult
});
/***
 * Expected JSON RPC response for the "programNotification" message
 */ const ProgramAccountNotificationResult = (0, _superstruct.type)({
    subscription: (0, _superstruct.number)(),
    result: notificationResultAndContext(ProgramAccountInfoResult)
});
/**
 * @internal
 */ const SlotInfoResult = (0, _superstruct.type)({
    parent: (0, _superstruct.number)(),
    slot: (0, _superstruct.number)(),
    root: (0, _superstruct.number)()
});
/**
 * Expected JSON RPC response for the "slotNotification" message
 */ const SlotNotificationResult = (0, _superstruct.type)({
    subscription: (0, _superstruct.number)(),
    result: SlotInfoResult
});
/**
 * Slot updates which can be used for tracking the live progress of a cluster.
 * - `"firstShredReceived"`: connected node received the first shred of a block.
 * Indicates that a new block that is being produced.
 * - `"completed"`: connected node has received all shreds of a block. Indicates
 * a block was recently produced.
 * - `"optimisticConfirmation"`: block was optimistically confirmed by the
 * cluster. It is not guaranteed that an optimistic confirmation notification
 * will be sent for every finalized blocks.
 * - `"root"`: the connected node rooted this block.
 * - `"createdBank"`: the connected node has started validating this block.
 * - `"frozen"`: the connected node has validated this block.
 * - `"dead"`: the connected node failed to validate this block.
 */ /**
 * @internal
 */ const SlotUpdateResult = (0, _superstruct.union)([
    (0, _superstruct.type)({
        type: (0, _superstruct.union)([
            (0, _superstruct.literal)("firstShredReceived"),
            (0, _superstruct.literal)("completed"),
            (0, _superstruct.literal)("optimisticConfirmation"),
            (0, _superstruct.literal)("root")
        ]),
        slot: (0, _superstruct.number)(),
        timestamp: (0, _superstruct.number)()
    }),
    (0, _superstruct.type)({
        type: (0, _superstruct.literal)("createdBank"),
        parent: (0, _superstruct.number)(),
        slot: (0, _superstruct.number)(),
        timestamp: (0, _superstruct.number)()
    }),
    (0, _superstruct.type)({
        type: (0, _superstruct.literal)("frozen"),
        slot: (0, _superstruct.number)(),
        timestamp: (0, _superstruct.number)(),
        stats: (0, _superstruct.type)({
            numTransactionEntries: (0, _superstruct.number)(),
            numSuccessfulTransactions: (0, _superstruct.number)(),
            numFailedTransactions: (0, _superstruct.number)(),
            maxTransactionsPerEntry: (0, _superstruct.number)()
        })
    }),
    (0, _superstruct.type)({
        type: (0, _superstruct.literal)("dead"),
        slot: (0, _superstruct.number)(),
        timestamp: (0, _superstruct.number)(),
        err: (0, _superstruct.string)()
    })
]);
/**
 * Expected JSON RPC response for the "slotsUpdatesNotification" message
 */ const SlotUpdateNotificationResult = (0, _superstruct.type)({
    subscription: (0, _superstruct.number)(),
    result: SlotUpdateResult
});
/**
 * Expected JSON RPC response for the "signatureNotification" message
 */ const SignatureNotificationResult = (0, _superstruct.type)({
    subscription: (0, _superstruct.number)(),
    result: notificationResultAndContext((0, _superstruct.union)([
        SignatureStatusResult,
        SignatureReceivedResult
    ]))
});
/**
 * Expected JSON RPC response for the "rootNotification" message
 */ const RootNotificationResult = (0, _superstruct.type)({
    subscription: (0, _superstruct.number)(),
    result: (0, _superstruct.number)()
});
const ContactInfoResult = (0, _superstruct.type)({
    pubkey: (0, _superstruct.string)(),
    gossip: (0, _superstruct.nullable)((0, _superstruct.string)()),
    tpu: (0, _superstruct.nullable)((0, _superstruct.string)()),
    rpc: (0, _superstruct.nullable)((0, _superstruct.string)()),
    version: (0, _superstruct.nullable)((0, _superstruct.string)())
});
const VoteAccountInfoResult = (0, _superstruct.type)({
    votePubkey: (0, _superstruct.string)(),
    nodePubkey: (0, _superstruct.string)(),
    activatedStake: (0, _superstruct.number)(),
    epochVoteAccount: (0, _superstruct.boolean)(),
    epochCredits: (0, _superstruct.array)((0, _superstruct.tuple)([
        (0, _superstruct.number)(),
        (0, _superstruct.number)(),
        (0, _superstruct.number)()
    ])),
    commission: (0, _superstruct.number)(),
    lastVote: (0, _superstruct.number)(),
    rootSlot: (0, _superstruct.nullable)((0, _superstruct.number)())
});
/**
 * Expected JSON RPC response for the "getVoteAccounts" message
 */ const GetVoteAccounts = jsonRpcResult((0, _superstruct.type)({
    current: (0, _superstruct.array)(VoteAccountInfoResult),
    delinquent: (0, _superstruct.array)(VoteAccountInfoResult)
}));
const ConfirmationStatus = (0, _superstruct.union)([
    (0, _superstruct.literal)("processed"),
    (0, _superstruct.literal)("confirmed"),
    (0, _superstruct.literal)("finalized")
]);
const SignatureStatusResponse = (0, _superstruct.type)({
    slot: (0, _superstruct.number)(),
    confirmations: (0, _superstruct.nullable)((0, _superstruct.number)()),
    err: TransactionErrorResult,
    confirmationStatus: (0, _superstruct.optional)(ConfirmationStatus)
});
/**
 * Expected JSON RPC response for the "getSignatureStatuses" message
 */ const GetSignatureStatusesRpcResult = jsonRpcResultAndContext((0, _superstruct.array)((0, _superstruct.nullable)(SignatureStatusResponse)));
/**
 * Expected JSON RPC response for the "getMinimumBalanceForRentExemption" message
 */ const GetMinimumBalanceForRentExemptionRpcResult = jsonRpcResult((0, _superstruct.number)());
const AddressTableLookupStruct = (0, _superstruct.type)({
    accountKey: PublicKeyFromString,
    writableIndexes: (0, _superstruct.array)((0, _superstruct.number)()),
    readonlyIndexes: (0, _superstruct.array)((0, _superstruct.number)())
});
const ConfirmedTransactionResult = (0, _superstruct.type)({
    signatures: (0, _superstruct.array)((0, _superstruct.string)()),
    message: (0, _superstruct.type)({
        accountKeys: (0, _superstruct.array)((0, _superstruct.string)()),
        header: (0, _superstruct.type)({
            numRequiredSignatures: (0, _superstruct.number)(),
            numReadonlySignedAccounts: (0, _superstruct.number)(),
            numReadonlyUnsignedAccounts: (0, _superstruct.number)()
        }),
        instructions: (0, _superstruct.array)((0, _superstruct.type)({
            accounts: (0, _superstruct.array)((0, _superstruct.number)()),
            data: (0, _superstruct.string)(),
            programIdIndex: (0, _superstruct.number)()
        })),
        recentBlockhash: (0, _superstruct.string)(),
        addressTableLookups: (0, _superstruct.optional)((0, _superstruct.array)(AddressTableLookupStruct))
    })
});
const AnnotatedAccountKey = (0, _superstruct.type)({
    pubkey: PublicKeyFromString,
    signer: (0, _superstruct.boolean)(),
    writable: (0, _superstruct.boolean)(),
    source: (0, _superstruct.optional)((0, _superstruct.union)([
        (0, _superstruct.literal)("transaction"),
        (0, _superstruct.literal)("lookupTable")
    ]))
});
const ConfirmedTransactionAccountsModeResult = (0, _superstruct.type)({
    accountKeys: (0, _superstruct.array)(AnnotatedAccountKey),
    signatures: (0, _superstruct.array)((0, _superstruct.string)())
});
const ParsedInstructionResult = (0, _superstruct.type)({
    parsed: (0, _superstruct.unknown)(),
    program: (0, _superstruct.string)(),
    programId: PublicKeyFromString
});
const RawInstructionResult = (0, _superstruct.type)({
    accounts: (0, _superstruct.array)(PublicKeyFromString),
    data: (0, _superstruct.string)(),
    programId: PublicKeyFromString
});
const InstructionResult = (0, _superstruct.union)([
    RawInstructionResult,
    ParsedInstructionResult
]);
const UnknownInstructionResult = (0, _superstruct.union)([
    (0, _superstruct.type)({
        parsed: (0, _superstruct.unknown)(),
        program: (0, _superstruct.string)(),
        programId: (0, _superstruct.string)()
    }),
    (0, _superstruct.type)({
        accounts: (0, _superstruct.array)((0, _superstruct.string)()),
        data: (0, _superstruct.string)(),
        programId: (0, _superstruct.string)()
    })
]);
const ParsedOrRawInstruction = (0, _superstruct.coerce)(InstructionResult, UnknownInstructionResult, (value)=>{
    if ("accounts" in value) return (0, _superstruct.create)(value, RawInstructionResult);
    else return (0, _superstruct.create)(value, ParsedInstructionResult);
});
/**
 * @internal
 */ const ParsedConfirmedTransactionResult = (0, _superstruct.type)({
    signatures: (0, _superstruct.array)((0, _superstruct.string)()),
    message: (0, _superstruct.type)({
        accountKeys: (0, _superstruct.array)(AnnotatedAccountKey),
        instructions: (0, _superstruct.array)(ParsedOrRawInstruction),
        recentBlockhash: (0, _superstruct.string)(),
        addressTableLookups: (0, _superstruct.optional)((0, _superstruct.nullable)((0, _superstruct.array)(AddressTableLookupStruct)))
    })
});
const TokenBalanceResult = (0, _superstruct.type)({
    accountIndex: (0, _superstruct.number)(),
    mint: (0, _superstruct.string)(),
    owner: (0, _superstruct.optional)((0, _superstruct.string)()),
    uiTokenAmount: TokenAmountResult
});
const LoadedAddressesResult = (0, _superstruct.type)({
    writable: (0, _superstruct.array)(PublicKeyFromString),
    readonly: (0, _superstruct.array)(PublicKeyFromString)
});
/**
 * @internal
 */ const ConfirmedTransactionMetaResult = (0, _superstruct.type)({
    err: TransactionErrorResult,
    fee: (0, _superstruct.number)(),
    innerInstructions: (0, _superstruct.optional)((0, _superstruct.nullable)((0, _superstruct.array)((0, _superstruct.type)({
        index: (0, _superstruct.number)(),
        instructions: (0, _superstruct.array)((0, _superstruct.type)({
            accounts: (0, _superstruct.array)((0, _superstruct.number)()),
            data: (0, _superstruct.string)(),
            programIdIndex: (0, _superstruct.number)()
        }))
    })))),
    preBalances: (0, _superstruct.array)((0, _superstruct.number)()),
    postBalances: (0, _superstruct.array)((0, _superstruct.number)()),
    logMessages: (0, _superstruct.optional)((0, _superstruct.nullable)((0, _superstruct.array)((0, _superstruct.string)()))),
    preTokenBalances: (0, _superstruct.optional)((0, _superstruct.nullable)((0, _superstruct.array)(TokenBalanceResult))),
    postTokenBalances: (0, _superstruct.optional)((0, _superstruct.nullable)((0, _superstruct.array)(TokenBalanceResult))),
    loadedAddresses: (0, _superstruct.optional)(LoadedAddressesResult),
    computeUnitsConsumed: (0, _superstruct.optional)((0, _superstruct.number)())
});
/**
 * @internal
 */ const ParsedConfirmedTransactionMetaResult = (0, _superstruct.type)({
    err: TransactionErrorResult,
    fee: (0, _superstruct.number)(),
    innerInstructions: (0, _superstruct.optional)((0, _superstruct.nullable)((0, _superstruct.array)((0, _superstruct.type)({
        index: (0, _superstruct.number)(),
        instructions: (0, _superstruct.array)(ParsedOrRawInstruction)
    })))),
    preBalances: (0, _superstruct.array)((0, _superstruct.number)()),
    postBalances: (0, _superstruct.array)((0, _superstruct.number)()),
    logMessages: (0, _superstruct.optional)((0, _superstruct.nullable)((0, _superstruct.array)((0, _superstruct.string)()))),
    preTokenBalances: (0, _superstruct.optional)((0, _superstruct.nullable)((0, _superstruct.array)(TokenBalanceResult))),
    postTokenBalances: (0, _superstruct.optional)((0, _superstruct.nullable)((0, _superstruct.array)(TokenBalanceResult))),
    loadedAddresses: (0, _superstruct.optional)(LoadedAddressesResult),
    computeUnitsConsumed: (0, _superstruct.optional)((0, _superstruct.number)())
});
const TransactionVersionStruct = (0, _superstruct.union)([
    (0, _superstruct.literal)(0),
    (0, _superstruct.literal)("legacy")
]);
/** @internal */ const RewardsResult = (0, _superstruct.type)({
    pubkey: (0, _superstruct.string)(),
    lamports: (0, _superstruct.number)(),
    postBalance: (0, _superstruct.nullable)((0, _superstruct.number)()),
    rewardType: (0, _superstruct.nullable)((0, _superstruct.string)()),
    commission: (0, _superstruct.optional)((0, _superstruct.nullable)((0, _superstruct.number)()))
});
/**
 * Expected JSON RPC response for the "getBlock" message
 */ const GetBlockRpcResult = jsonRpcResult((0, _superstruct.nullable)((0, _superstruct.type)({
    blockhash: (0, _superstruct.string)(),
    previousBlockhash: (0, _superstruct.string)(),
    parentSlot: (0, _superstruct.number)(),
    transactions: (0, _superstruct.array)((0, _superstruct.type)({
        transaction: ConfirmedTransactionResult,
        meta: (0, _superstruct.nullable)(ConfirmedTransactionMetaResult),
        version: (0, _superstruct.optional)(TransactionVersionStruct)
    })),
    rewards: (0, _superstruct.optional)((0, _superstruct.array)(RewardsResult)),
    blockTime: (0, _superstruct.nullable)((0, _superstruct.number)()),
    blockHeight: (0, _superstruct.nullable)((0, _superstruct.number)())
})));
/**
 * Expected JSON RPC response for the "getBlock" message when `transactionDetails` is `none`
 */ const GetNoneModeBlockRpcResult = jsonRpcResult((0, _superstruct.nullable)((0, _superstruct.type)({
    blockhash: (0, _superstruct.string)(),
    previousBlockhash: (0, _superstruct.string)(),
    parentSlot: (0, _superstruct.number)(),
    rewards: (0, _superstruct.optional)((0, _superstruct.array)(RewardsResult)),
    blockTime: (0, _superstruct.nullable)((0, _superstruct.number)()),
    blockHeight: (0, _superstruct.nullable)((0, _superstruct.number)())
})));
/**
 * Expected JSON RPC response for the "getBlock" message when `transactionDetails` is `accounts`
 */ const GetAccountsModeBlockRpcResult = jsonRpcResult((0, _superstruct.nullable)((0, _superstruct.type)({
    blockhash: (0, _superstruct.string)(),
    previousBlockhash: (0, _superstruct.string)(),
    parentSlot: (0, _superstruct.number)(),
    transactions: (0, _superstruct.array)((0, _superstruct.type)({
        transaction: ConfirmedTransactionAccountsModeResult,
        meta: (0, _superstruct.nullable)(ConfirmedTransactionMetaResult),
        version: (0, _superstruct.optional)(TransactionVersionStruct)
    })),
    rewards: (0, _superstruct.optional)((0, _superstruct.array)(RewardsResult)),
    blockTime: (0, _superstruct.nullable)((0, _superstruct.number)()),
    blockHeight: (0, _superstruct.nullable)((0, _superstruct.number)())
})));
/**
 * Expected parsed JSON RPC response for the "getBlock" message
 */ const GetParsedBlockRpcResult = jsonRpcResult((0, _superstruct.nullable)((0, _superstruct.type)({
    blockhash: (0, _superstruct.string)(),
    previousBlockhash: (0, _superstruct.string)(),
    parentSlot: (0, _superstruct.number)(),
    transactions: (0, _superstruct.array)((0, _superstruct.type)({
        transaction: ParsedConfirmedTransactionResult,
        meta: (0, _superstruct.nullable)(ParsedConfirmedTransactionMetaResult),
        version: (0, _superstruct.optional)(TransactionVersionStruct)
    })),
    rewards: (0, _superstruct.optional)((0, _superstruct.array)(RewardsResult)),
    blockTime: (0, _superstruct.nullable)((0, _superstruct.number)()),
    blockHeight: (0, _superstruct.nullable)((0, _superstruct.number)())
})));
/**
 * Expected parsed JSON RPC response for the "getBlock" message  when `transactionDetails` is `accounts`
 */ const GetParsedAccountsModeBlockRpcResult = jsonRpcResult((0, _superstruct.nullable)((0, _superstruct.type)({
    blockhash: (0, _superstruct.string)(),
    previousBlockhash: (0, _superstruct.string)(),
    parentSlot: (0, _superstruct.number)(),
    transactions: (0, _superstruct.array)((0, _superstruct.type)({
        transaction: ConfirmedTransactionAccountsModeResult,
        meta: (0, _superstruct.nullable)(ParsedConfirmedTransactionMetaResult),
        version: (0, _superstruct.optional)(TransactionVersionStruct)
    })),
    rewards: (0, _superstruct.optional)((0, _superstruct.array)(RewardsResult)),
    blockTime: (0, _superstruct.nullable)((0, _superstruct.number)()),
    blockHeight: (0, _superstruct.nullable)((0, _superstruct.number)())
})));
/**
 * Expected parsed JSON RPC response for the "getBlock" message  when `transactionDetails` is `none`
 */ const GetParsedNoneModeBlockRpcResult = jsonRpcResult((0, _superstruct.nullable)((0, _superstruct.type)({
    blockhash: (0, _superstruct.string)(),
    previousBlockhash: (0, _superstruct.string)(),
    parentSlot: (0, _superstruct.number)(),
    rewards: (0, _superstruct.optional)((0, _superstruct.array)(RewardsResult)),
    blockTime: (0, _superstruct.nullable)((0, _superstruct.number)()),
    blockHeight: (0, _superstruct.nullable)((0, _superstruct.number)())
})));
/**
 * Expected JSON RPC response for the "getConfirmedBlock" message
 *
 * @deprecated Deprecated since RPC v1.8.0. Please use {@link GetBlockRpcResult} instead.
 */ const GetConfirmedBlockRpcResult = jsonRpcResult((0, _superstruct.nullable)((0, _superstruct.type)({
    blockhash: (0, _superstruct.string)(),
    previousBlockhash: (0, _superstruct.string)(),
    parentSlot: (0, _superstruct.number)(),
    transactions: (0, _superstruct.array)((0, _superstruct.type)({
        transaction: ConfirmedTransactionResult,
        meta: (0, _superstruct.nullable)(ConfirmedTransactionMetaResult)
    })),
    rewards: (0, _superstruct.optional)((0, _superstruct.array)(RewardsResult)),
    blockTime: (0, _superstruct.nullable)((0, _superstruct.number)())
})));
/**
 * Expected JSON RPC response for the "getBlock" message
 */ const GetBlockSignaturesRpcResult = jsonRpcResult((0, _superstruct.nullable)((0, _superstruct.type)({
    blockhash: (0, _superstruct.string)(),
    previousBlockhash: (0, _superstruct.string)(),
    parentSlot: (0, _superstruct.number)(),
    signatures: (0, _superstruct.array)((0, _superstruct.string)()),
    blockTime: (0, _superstruct.nullable)((0, _superstruct.number)())
})));
/**
 * Expected JSON RPC response for the "getTransaction" message
 */ const GetTransactionRpcResult = jsonRpcResult((0, _superstruct.nullable)((0, _superstruct.type)({
    slot: (0, _superstruct.number)(),
    meta: (0, _superstruct.nullable)(ConfirmedTransactionMetaResult),
    blockTime: (0, _superstruct.optional)((0, _superstruct.nullable)((0, _superstruct.number)())),
    transaction: ConfirmedTransactionResult,
    version: (0, _superstruct.optional)(TransactionVersionStruct)
})));
/**
 * Expected parsed JSON RPC response for the "getTransaction" message
 */ const GetParsedTransactionRpcResult = jsonRpcResult((0, _superstruct.nullable)((0, _superstruct.type)({
    slot: (0, _superstruct.number)(),
    transaction: ParsedConfirmedTransactionResult,
    meta: (0, _superstruct.nullable)(ParsedConfirmedTransactionMetaResult),
    blockTime: (0, _superstruct.optional)((0, _superstruct.nullable)((0, _superstruct.number)())),
    version: (0, _superstruct.optional)(TransactionVersionStruct)
})));
/**
 * Expected JSON RPC response for the "getRecentBlockhash" message
 *
 * @deprecated Deprecated since RPC v1.8.0. Please use {@link GetLatestBlockhashRpcResult} instead.
 */ const GetRecentBlockhashAndContextRpcResult = jsonRpcResultAndContext((0, _superstruct.type)({
    blockhash: (0, _superstruct.string)(),
    feeCalculator: (0, _superstruct.type)({
        lamportsPerSignature: (0, _superstruct.number)()
    })
}));
/**
 * Expected JSON RPC response for the "getLatestBlockhash" message
 */ const GetLatestBlockhashRpcResult = jsonRpcResultAndContext((0, _superstruct.type)({
    blockhash: (0, _superstruct.string)(),
    lastValidBlockHeight: (0, _superstruct.number)()
}));
/**
 * Expected JSON RPC response for the "isBlockhashValid" message
 */ const IsBlockhashValidRpcResult = jsonRpcResultAndContext((0, _superstruct.boolean)());
const PerfSampleResult = (0, _superstruct.type)({
    slot: (0, _superstruct.number)(),
    numTransactions: (0, _superstruct.number)(),
    numSlots: (0, _superstruct.number)(),
    samplePeriodSecs: (0, _superstruct.number)()
});
/*
 * Expected JSON RPC response for "getRecentPerformanceSamples" message
 */ const GetRecentPerformanceSamplesRpcResult = jsonRpcResult((0, _superstruct.array)(PerfSampleResult));
/**
 * Expected JSON RPC response for the "getFeeCalculatorForBlockhash" message
 */ const GetFeeCalculatorRpcResult = jsonRpcResultAndContext((0, _superstruct.nullable)((0, _superstruct.type)({
    feeCalculator: (0, _superstruct.type)({
        lamportsPerSignature: (0, _superstruct.number)()
    })
})));
/**
 * Expected JSON RPC response for the "requestAirdrop" message
 */ const RequestAirdropRpcResult = jsonRpcResult((0, _superstruct.string)());
/**
 * Expected JSON RPC response for the "sendTransaction" message
 */ const SendTransactionRpcResult = jsonRpcResult((0, _superstruct.string)());
/**
 * Information about the latest slot being processed by a node
 */ /**
 * Parsed account data
 */ /**
 * Stake Activation data
 */ /**
 * Data slice argument for getProgramAccounts
 */ /**
 * Memory comparison filter for getProgramAccounts
 */ /**
 * Data size comparison filter for getProgramAccounts
 */ /**
 * A filter object for getProgramAccounts
 */ /**
 * Configuration object for getProgramAccounts requests
 */ /**
 * Configuration object for getParsedProgramAccounts
 */ /**
 * Configuration object for getMultipleAccounts
 */ /**
 * Configuration object for `getStakeActivation`
 */ /**
 * Configuration object for `getStakeActivation`
 */ /**
 * Configuration object for `getStakeActivation`
 */ /**
 * Configuration object for `getNonce`
 */ /**
 * Configuration object for `getNonceAndContext`
 */ /**
 * Information describing an account
 */ /**
 * Account information identified by pubkey
 */ /**
 * Callback function for account change notifications
 */ /**
 * Callback function for program account change notifications
 */ /**
 * Callback function for slot change notifications
 */ /**
 * Callback function for slot update notifications
 */ /**
 * Callback function for signature status notifications
 */ /**
 * Signature status notification with transaction result
 */ /**
 * Signature received notification
 */ /**
 * Callback function for signature notifications
 */ /**
 * Signature subscription options
 */ /**
 * Callback function for root change notifications
 */ /**
 * @internal
 */ const LogsResult = (0, _superstruct.type)({
    err: TransactionErrorResult,
    logs: (0, _superstruct.array)((0, _superstruct.string)()),
    signature: (0, _superstruct.string)()
});
/**
 * Logs result.
 */ /**
 * Expected JSON RPC response for the "logsNotification" message.
 */ const LogsNotificationResult = (0, _superstruct.type)({
    result: notificationResultAndContext(LogsResult),
    subscription: (0, _superstruct.number)()
});
/**
 * Filter for log subscriptions.
 */ /**
 * Callback function for log notifications.
 */ /**
 * Signature result
 */ /**
 * Transaction error
 */ /**
 * Transaction confirmation status
 * <pre>
 *   'processed': Transaction landed in a block which has reached 1 confirmation by the connected node
 *   'confirmed': Transaction landed in a block which has reached 1 confirmation by the cluster
 *   'finalized': Transaction landed in a block which has been finalized by the cluster
 * </pre>
 */ /**
 * Signature status
 */ /**
 * A confirmed signature with its status
 */ /**
 * An object defining headers to be passed to the RPC server
 */ /**
 * The type of the JavaScript `fetch()` API
 */ /**
 * A callback used to augment the outgoing HTTP request
 */ /**
 * Configuration for instantiating a Connection
 */ /** @internal */ const COMMON_HTTP_HEADERS = {
    "solana-client": `js/${"1.0.0-maintenance"}`
};
/**
 * A connection to a fullnode JSON RPC endpoint
 */ class Connection {
    /**
   * Establish a JSON RPC connection
   *
   * @param endpoint URL to the fullnode JSON RPC endpoint
   * @param commitmentOrConfig optional default commitment level or optional ConnectionConfig configuration object
   */ constructor(endpoint, _commitmentOrConfig){
        /** @internal */ this._commitment = void 0;
        /** @internal */ this._confirmTransactionInitialTimeout = void 0;
        /** @internal */ this._rpcEndpoint = void 0;
        /** @internal */ this._rpcWsEndpoint = void 0;
        /** @internal */ this._rpcClient = void 0;
        /** @internal */ this._rpcRequest = void 0;
        /** @internal */ this._rpcBatchRequest = void 0;
        /** @internal */ this._rpcWebSocket = void 0;
        /** @internal */ this._rpcWebSocketConnected = false;
        /** @internal */ this._rpcWebSocketHeartbeat = null;
        /** @internal */ this._rpcWebSocketIdleTimeout = null;
        /** @internal
     * A number that we increment every time an active connection closes.
     * Used to determine whether the same socket connection that was open
     * when an async operation started is the same one that's active when
     * its continuation fires.
     *
     */ this._rpcWebSocketGeneration = 0;
        /** @internal */ this._disableBlockhashCaching = false;
        /** @internal */ this._pollingBlockhash = false;
        /** @internal */ this._blockhashInfo = {
            latestBlockhash: null,
            lastFetch: 0,
            transactionSignatures: [],
            simulatedSignatures: []
        };
        /** @internal */ this._nextClientSubscriptionId = 0;
        /** @internal */ this._subscriptionDisposeFunctionsByClientSubscriptionId = {};
        /** @internal */ this._subscriptionHashByClientSubscriptionId = {};
        /** @internal */ this._subscriptionStateChangeCallbacksByHash = {};
        /** @internal */ this._subscriptionCallbacksByServerSubscriptionId = {};
        /** @internal */ this._subscriptionsByHash = {};
        /**
     * Special case.
     * After a signature is processed, RPCs automatically dispose of the
     * subscription on the server side. We need to track which of these
     * subscriptions have been disposed in such a way, so that we know
     * whether the client is dealing with a not-yet-processed signature
     * (in which case we must tear down the server subscription) or an
     * already-processed signature (in which case the client can simply
     * clear out the subscription locally without telling the server).
     *
     * NOTE: There is a proposal to eliminate this special case, here:
     * https://github.com/solana-labs/solana/issues/18892
     */ /** @internal */ this._subscriptionsAutoDisposedByRpc = new Set();
        /*
     * Returns the current block height of the node
     */ this.getBlockHeight = (()=>{
            const requestPromises = {};
            return async (commitmentOrConfig)=>{
                const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);
                const args = this._buildArgs([], commitment, undefined /* encoding */ , config);
                const requestHash = fastStableStringify(args);
                requestPromises[requestHash] = requestPromises[requestHash] ?? (async ()=>{
                    try {
                        const unsafeRes = await this._rpcRequest("getBlockHeight", args);
                        const res = (0, _superstruct.create)(unsafeRes, jsonRpcResult((0, _superstruct.number)()));
                        if ("error" in res) throw new SolanaJSONRPCError(res.error, "failed to get block height information");
                        return res.result;
                    } finally{
                        delete requestPromises[requestHash];
                    }
                })();
                return await requestPromises[requestHash];
            };
        })();
        let wsEndpoint;
        let httpHeaders;
        let fetch;
        let fetchMiddleware;
        let disableRetryOnRateLimit;
        let httpAgent;
        if (_commitmentOrConfig && typeof _commitmentOrConfig === "string") this._commitment = _commitmentOrConfig;
        else if (_commitmentOrConfig) {
            this._commitment = _commitmentOrConfig.commitment;
            this._confirmTransactionInitialTimeout = _commitmentOrConfig.confirmTransactionInitialTimeout;
            wsEndpoint = _commitmentOrConfig.wsEndpoint;
            httpHeaders = _commitmentOrConfig.httpHeaders;
            fetch = _commitmentOrConfig.fetch;
            fetchMiddleware = _commitmentOrConfig.fetchMiddleware;
            disableRetryOnRateLimit = _commitmentOrConfig.disableRetryOnRateLimit;
            httpAgent = _commitmentOrConfig.httpAgent;
        }
        this._rpcEndpoint = assertEndpointUrl(endpoint);
        this._rpcWsEndpoint = wsEndpoint || makeWebsocketUrl(endpoint);
        this._rpcClient = createRpcClient(endpoint, httpHeaders, fetch, fetchMiddleware, disableRetryOnRateLimit, httpAgent);
        this._rpcRequest = createRpcRequest(this._rpcClient);
        this._rpcBatchRequest = createRpcBatchRequest(this._rpcClient);
        this._rpcWebSocket = new RpcWebSocketClient(this._rpcWsEndpoint, {
            autoconnect: false,
            max_reconnects: Infinity
        });
        this._rpcWebSocket.on("open", this._wsOnOpen.bind(this));
        this._rpcWebSocket.on("error", this._wsOnError.bind(this));
        this._rpcWebSocket.on("close", this._wsOnClose.bind(this));
        this._rpcWebSocket.on("accountNotification", this._wsOnAccountNotification.bind(this));
        this._rpcWebSocket.on("programNotification", this._wsOnProgramAccountNotification.bind(this));
        this._rpcWebSocket.on("slotNotification", this._wsOnSlotNotification.bind(this));
        this._rpcWebSocket.on("slotsUpdatesNotification", this._wsOnSlotUpdatesNotification.bind(this));
        this._rpcWebSocket.on("signatureNotification", this._wsOnSignatureNotification.bind(this));
        this._rpcWebSocket.on("rootNotification", this._wsOnRootNotification.bind(this));
        this._rpcWebSocket.on("logsNotification", this._wsOnLogsNotification.bind(this));
    }
    /**
   * The default commitment used for requests
   */ get commitment() {
        return this._commitment;
    }
    /**
   * The RPC endpoint
   */ get rpcEndpoint() {
        return this._rpcEndpoint;
    }
    /**
   * Fetch the balance for the specified public key, return with context
   */ async getBalanceAndContext(publicKey, commitmentOrConfig) {
        /** @internal */ const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);
        const args = this._buildArgs([
            publicKey.toBase58()
        ], commitment, undefined /* encoding */ , config);
        const unsafeRes = await this._rpcRequest("getBalance", args);
        const res = (0, _superstruct.create)(unsafeRes, jsonRpcResultAndContext((0, _superstruct.number)()));
        if ("error" in res) throw new SolanaJSONRPCError(res.error, `failed to get balance for ${publicKey.toBase58()}`);
        return res.result;
    }
    /**
   * Fetch the balance for the specified public key
   */ async getBalance(publicKey, commitmentOrConfig) {
        return await this.getBalanceAndContext(publicKey, commitmentOrConfig).then((x)=>x.value).catch((e)=>{
            throw new Error("failed to get balance of account " + publicKey.toBase58() + ": " + e);
        });
    }
    /**
   * Fetch the estimated production time of a block
   */ async getBlockTime(slot) {
        const unsafeRes = await this._rpcRequest("getBlockTime", [
            slot
        ]);
        const res = (0, _superstruct.create)(unsafeRes, jsonRpcResult((0, _superstruct.nullable)((0, _superstruct.number)())));
        if ("error" in res) throw new SolanaJSONRPCError(res.error, `failed to get block time for slot ${slot}`);
        return res.result;
    }
    /**
   * Fetch the lowest slot that the node has information about in its ledger.
   * This value may increase over time if the node is configured to purge older ledger data
   */ async getMinimumLedgerSlot() {
        const unsafeRes = await this._rpcRequest("minimumLedgerSlot", []);
        const res = (0, _superstruct.create)(unsafeRes, jsonRpcResult((0, _superstruct.number)()));
        if ("error" in res) throw new SolanaJSONRPCError(res.error, "failed to get minimum ledger slot");
        return res.result;
    }
    /**
   * Fetch the slot of the lowest confirmed block that has not been purged from the ledger
   */ async getFirstAvailableBlock() {
        const unsafeRes = await this._rpcRequest("getFirstAvailableBlock", []);
        const res = (0, _superstruct.create)(unsafeRes, SlotRpcResult);
        if ("error" in res) throw new SolanaJSONRPCError(res.error, "failed to get first available block");
        return res.result;
    }
    /**
   * Fetch information about the current supply
   */ async getSupply(config) {
        let configArg = {};
        if (typeof config === "string") configArg = {
            commitment: config
        };
        else if (config) configArg = {
            ...config,
            commitment: config && config.commitment || this.commitment
        };
        else configArg = {
            commitment: this.commitment
        };
        const unsafeRes = await this._rpcRequest("getSupply", [
            configArg
        ]);
        const res = (0, _superstruct.create)(unsafeRes, GetSupplyRpcResult);
        if ("error" in res) throw new SolanaJSONRPCError(res.error, "failed to get supply");
        return res.result;
    }
    /**
   * Fetch the current supply of a token mint
   */ async getTokenSupply(tokenMintAddress, commitment) {
        const args = this._buildArgs([
            tokenMintAddress.toBase58()
        ], commitment);
        const unsafeRes = await this._rpcRequest("getTokenSupply", args);
        const res = (0, _superstruct.create)(unsafeRes, jsonRpcResultAndContext(TokenAmountResult));
        if ("error" in res) throw new SolanaJSONRPCError(res.error, "failed to get token supply");
        return res.result;
    }
    /**
   * Fetch the current balance of a token account
   */ async getTokenAccountBalance(tokenAddress, commitment) {
        const args = this._buildArgs([
            tokenAddress.toBase58()
        ], commitment);
        const unsafeRes = await this._rpcRequest("getTokenAccountBalance", args);
        const res = (0, _superstruct.create)(unsafeRes, jsonRpcResultAndContext(TokenAmountResult));
        if ("error" in res) throw new SolanaJSONRPCError(res.error, "failed to get token account balance");
        return res.result;
    }
    /**
   * Fetch all the token accounts owned by the specified account
   *
   * @return {Promise<RpcResponseAndContext<GetProgramAccountsResponse>}
   */ async getTokenAccountsByOwner(ownerAddress, filter, commitmentOrConfig) {
        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);
        let _args = [
            ownerAddress.toBase58()
        ];
        if ("mint" in filter) _args.push({
            mint: filter.mint.toBase58()
        });
        else _args.push({
            programId: filter.programId.toBase58()
        });
        const args = this._buildArgs(_args, commitment, "base64", config);
        const unsafeRes = await this._rpcRequest("getTokenAccountsByOwner", args);
        const res = (0, _superstruct.create)(unsafeRes, GetTokenAccountsByOwner);
        if ("error" in res) throw new SolanaJSONRPCError(res.error, `failed to get token accounts owned by account ${ownerAddress.toBase58()}`);
        return res.result;
    }
    /**
   * Fetch parsed token accounts owned by the specified account
   *
   * @return {Promise<RpcResponseAndContext<Array<{pubkey: PublicKey, account: AccountInfo<ParsedAccountData>}>>>}
   */ async getParsedTokenAccountsByOwner(ownerAddress, filter, commitment) {
        let _args = [
            ownerAddress.toBase58()
        ];
        if ("mint" in filter) _args.push({
            mint: filter.mint.toBase58()
        });
        else _args.push({
            programId: filter.programId.toBase58()
        });
        const args = this._buildArgs(_args, commitment, "jsonParsed");
        const unsafeRes = await this._rpcRequest("getTokenAccountsByOwner", args);
        const res = (0, _superstruct.create)(unsafeRes, GetParsedTokenAccountsByOwner);
        if ("error" in res) throw new SolanaJSONRPCError(res.error, `failed to get token accounts owned by account ${ownerAddress.toBase58()}`);
        return res.result;
    }
    /**
   * Fetch the 20 largest accounts with their current balances
   */ async getLargestAccounts(config) {
        const arg = {
            ...config,
            commitment: config && config.commitment || this.commitment
        };
        const args = arg.filter || arg.commitment ? [
            arg
        ] : [];
        const unsafeRes = await this._rpcRequest("getLargestAccounts", args);
        const res = (0, _superstruct.create)(unsafeRes, GetLargestAccountsRpcResult);
        if ("error" in res) throw new SolanaJSONRPCError(res.error, "failed to get largest accounts");
        return res.result;
    }
    /**
   * Fetch the 20 largest token accounts with their current balances
   * for a given mint.
   */ async getTokenLargestAccounts(mintAddress, commitment) {
        const args = this._buildArgs([
            mintAddress.toBase58()
        ], commitment);
        const unsafeRes = await this._rpcRequest("getTokenLargestAccounts", args);
        const res = (0, _superstruct.create)(unsafeRes, GetTokenLargestAccountsResult);
        if ("error" in res) throw new SolanaJSONRPCError(res.error, "failed to get token largest accounts");
        return res.result;
    }
    /**
   * Fetch all the account info for the specified public key, return with context
   */ async getAccountInfoAndContext(publicKey, commitmentOrConfig) {
        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);
        const args = this._buildArgs([
            publicKey.toBase58()
        ], commitment, "base64", config);
        const unsafeRes = await this._rpcRequest("getAccountInfo", args);
        const res = (0, _superstruct.create)(unsafeRes, jsonRpcResultAndContext((0, _superstruct.nullable)(AccountInfoResult)));
        if ("error" in res) throw new SolanaJSONRPCError(res.error, `failed to get info about account ${publicKey.toBase58()}`);
        return res.result;
    }
    /**
   * Fetch parsed account info for the specified public key
   */ async getParsedAccountInfo(publicKey, commitmentOrConfig) {
        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);
        const args = this._buildArgs([
            publicKey.toBase58()
        ], commitment, "jsonParsed", config);
        const unsafeRes = await this._rpcRequest("getAccountInfo", args);
        const res = (0, _superstruct.create)(unsafeRes, jsonRpcResultAndContext((0, _superstruct.nullable)(ParsedAccountInfoResult)));
        if ("error" in res) throw new SolanaJSONRPCError(res.error, `failed to get info about account ${publicKey.toBase58()}`);
        return res.result;
    }
    /**
   * Fetch all the account info for the specified public key
   */ async getAccountInfo(publicKey, commitmentOrConfig) {
        try {
            const res = await this.getAccountInfoAndContext(publicKey, commitmentOrConfig);
            return res.value;
        } catch (e) {
            throw new Error("failed to get info about account " + publicKey.toBase58() + ": " + e);
        }
    }
    /**
   * Fetch all the account info for multiple accounts specified by an array of public keys, return with context
   */ async getMultipleParsedAccounts(publicKeys, rawConfig) {
        const { commitment, config } = extractCommitmentFromConfig(rawConfig);
        const keys = publicKeys.map((key)=>key.toBase58());
        const args = this._buildArgs([
            keys
        ], commitment, "jsonParsed", config);
        const unsafeRes = await this._rpcRequest("getMultipleAccounts", args);
        const res = (0, _superstruct.create)(unsafeRes, jsonRpcResultAndContext((0, _superstruct.array)((0, _superstruct.nullable)(ParsedAccountInfoResult))));
        if ("error" in res) throw new SolanaJSONRPCError(res.error, `failed to get info for accounts ${keys}`);
        return res.result;
    }
    /**
   * Fetch all the account info for multiple accounts specified by an array of public keys, return with context
   */ async getMultipleAccountsInfoAndContext(publicKeys, commitmentOrConfig) {
        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);
        const keys = publicKeys.map((key)=>key.toBase58());
        const args = this._buildArgs([
            keys
        ], commitment, "base64", config);
        const unsafeRes = await this._rpcRequest("getMultipleAccounts", args);
        const res = (0, _superstruct.create)(unsafeRes, jsonRpcResultAndContext((0, _superstruct.array)((0, _superstruct.nullable)(AccountInfoResult))));
        if ("error" in res) throw new SolanaJSONRPCError(res.error, `failed to get info for accounts ${keys}`);
        return res.result;
    }
    /**
   * Fetch all the account info for multiple accounts specified by an array of public keys
   */ async getMultipleAccountsInfo(publicKeys, commitmentOrConfig) {
        const res = await this.getMultipleAccountsInfoAndContext(publicKeys, commitmentOrConfig);
        return res.value;
    }
    /**
   * Returns epoch activation information for a stake account that has been delegated
   *
   * @deprecated Deprecated since RPC v1.18; will be removed in a future version.
   */ async getStakeActivation(publicKey, commitmentOrConfig, epoch) {
        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);
        const args = this._buildArgs([
            publicKey.toBase58()
        ], commitment, undefined /* encoding */ , {
            ...config,
            epoch: epoch != null ? epoch : config?.epoch
        });
        const unsafeRes = await this._rpcRequest("getStakeActivation", args);
        const res = (0, _superstruct.create)(unsafeRes, jsonRpcResult(StakeActivationResult));
        if ("error" in res) throw new SolanaJSONRPCError(res.error, `failed to get Stake Activation ${publicKey.toBase58()}`);
        return res.result;
    }
    /**
   * Fetch all the accounts owned by the specified program id
   *
   * @return {Promise<Array<{pubkey: PublicKey, account: AccountInfo<Buffer>}>>}
   */ // eslint-disable-next-line no-dupe-class-members
    // eslint-disable-next-line no-dupe-class-members
    async getProgramAccounts(programId, configOrCommitment) {
        const { commitment, config } = extractCommitmentFromConfig(configOrCommitment);
        const { encoding, ...configWithoutEncoding } = config || {};
        const args = this._buildArgs([
            programId.toBase58()
        ], commitment, encoding || "base64", {
            ...configWithoutEncoding,
            ...configWithoutEncoding.filters ? {
                filters: applyDefaultMemcmpEncodingToFilters(configWithoutEncoding.filters)
            } : null
        });
        const unsafeRes = await this._rpcRequest("getProgramAccounts", args);
        const baseSchema = (0, _superstruct.array)(KeyedAccountInfoResult);
        const res = configWithoutEncoding.withContext === true ? (0, _superstruct.create)(unsafeRes, jsonRpcResultAndContext(baseSchema)) : (0, _superstruct.create)(unsafeRes, jsonRpcResult(baseSchema));
        if ("error" in res) throw new SolanaJSONRPCError(res.error, `failed to get accounts owned by program ${programId.toBase58()}`);
        return res.result;
    }
    /**
   * Fetch and parse all the accounts owned by the specified program id
   *
   * @return {Promise<Array<{pubkey: PublicKey, account: AccountInfo<Buffer | ParsedAccountData>}>>}
   */ async getParsedProgramAccounts(programId, configOrCommitment) {
        const { commitment, config } = extractCommitmentFromConfig(configOrCommitment);
        const args = this._buildArgs([
            programId.toBase58()
        ], commitment, "jsonParsed", config);
        const unsafeRes = await this._rpcRequest("getProgramAccounts", args);
        const res = (0, _superstruct.create)(unsafeRes, jsonRpcResult((0, _superstruct.array)(KeyedParsedAccountInfoResult)));
        if ("error" in res) throw new SolanaJSONRPCError(res.error, `failed to get accounts owned by program ${programId.toBase58()}`);
        return res.result;
    }
    /** @deprecated Instead, call `confirmTransaction` and pass in {@link TransactionConfirmationStrategy} */ // eslint-disable-next-line no-dupe-class-members
    // eslint-disable-next-line no-dupe-class-members
    async confirmTransaction(strategy, commitment) {
        let rawSignature;
        if (typeof strategy == "string") rawSignature = strategy;
        else {
            const config = strategy;
            if (config.abortSignal?.aborted) return Promise.reject(config.abortSignal.reason);
            rawSignature = config.signature;
        }
        let decodedSignature;
        try {
            decodedSignature = (0, _bs58Default.default).decode(rawSignature);
        } catch (err) {
            throw new Error("signature must be base58 encoded: " + rawSignature);
        }
        assert(decodedSignature.length === 64, "signature has invalid length");
        if (typeof strategy === "string") return await this.confirmTransactionUsingLegacyTimeoutStrategy({
            commitment: commitment || this.commitment,
            signature: rawSignature
        });
        else if ("lastValidBlockHeight" in strategy) return await this.confirmTransactionUsingBlockHeightExceedanceStrategy({
            commitment: commitment || this.commitment,
            strategy
        });
        else return await this.confirmTransactionUsingDurableNonceStrategy({
            commitment: commitment || this.commitment,
            strategy
        });
    }
    getCancellationPromise(signal) {
        return new Promise((_, reject)=>{
            if (signal == null) return;
            if (signal.aborted) reject(signal.reason);
            else signal.addEventListener("abort", ()=>{
                reject(signal.reason);
            });
        });
    }
    getTransactionConfirmationPromise({ commitment, signature }) {
        let signatureSubscriptionId;
        let disposeSignatureSubscriptionStateChangeObserver;
        let done = false;
        const confirmationPromise = new Promise((resolve, reject)=>{
            try {
                signatureSubscriptionId = this.onSignature(signature, (result, context)=>{
                    signatureSubscriptionId = undefined;
                    const response = {
                        context,
                        value: result
                    };
                    resolve({
                        __type: TransactionStatus.PROCESSED,
                        response
                    });
                }, commitment);
                const subscriptionSetupPromise = new Promise((resolveSubscriptionSetup)=>{
                    if (signatureSubscriptionId == null) resolveSubscriptionSetup();
                    else disposeSignatureSubscriptionStateChangeObserver = this._onSubscriptionStateChange(signatureSubscriptionId, (nextState)=>{
                        if (nextState === "subscribed") resolveSubscriptionSetup();
                    });
                });
                (async ()=>{
                    await subscriptionSetupPromise;
                    if (done) return;
                    const response = await this.getSignatureStatus(signature);
                    if (done) return;
                    if (response == null) return;
                    const { context, value } = response;
                    if (value == null) return;
                    if (value?.err) reject(value.err);
                    else {
                        switch(commitment){
                            case "confirmed":
                            case "single":
                            case "singleGossip":
                                if (value.confirmationStatus === "processed") return;
                                break;
                            case "finalized":
                            case "max":
                            case "root":
                                if (value.confirmationStatus === "processed" || value.confirmationStatus === "confirmed") return;
                                break;
                            // exhaust enums to ensure full coverage
                            case "processed":
                            case "recent":
                        }
                        done = true;
                        resolve({
                            __type: TransactionStatus.PROCESSED,
                            response: {
                                context,
                                value
                            }
                        });
                    }
                })();
            } catch (err) {
                reject(err);
            }
        });
        const abortConfirmation = ()=>{
            if (disposeSignatureSubscriptionStateChangeObserver) {
                disposeSignatureSubscriptionStateChangeObserver();
                disposeSignatureSubscriptionStateChangeObserver = undefined;
            }
            if (signatureSubscriptionId != null) {
                this.removeSignatureListener(signatureSubscriptionId);
                signatureSubscriptionId = undefined;
            }
        };
        return {
            abortConfirmation,
            confirmationPromise
        };
    }
    async confirmTransactionUsingBlockHeightExceedanceStrategy({ commitment, strategy: { abortSignal, lastValidBlockHeight, signature } }) {
        let done = false;
        const expiryPromise = new Promise((resolve)=>{
            const checkBlockHeight = async ()=>{
                try {
                    const blockHeight = await this.getBlockHeight(commitment);
                    return blockHeight;
                } catch (_e) {
                    return -1;
                }
            };
            (async ()=>{
                let currentBlockHeight = await checkBlockHeight();
                if (done) return;
                while(currentBlockHeight <= lastValidBlockHeight){
                    await sleep(1000);
                    if (done) return;
                    currentBlockHeight = await checkBlockHeight();
                    if (done) return;
                }
                resolve({
                    __type: TransactionStatus.BLOCKHEIGHT_EXCEEDED
                });
            })();
        });
        const { abortConfirmation, confirmationPromise } = this.getTransactionConfirmationPromise({
            commitment,
            signature
        });
        const cancellationPromise = this.getCancellationPromise(abortSignal);
        let result;
        try {
            const outcome = await Promise.race([
                cancellationPromise,
                confirmationPromise,
                expiryPromise
            ]);
            if (outcome.__type === TransactionStatus.PROCESSED) result = outcome.response;
            else throw new TransactionExpiredBlockheightExceededError(signature);
        } finally{
            done = true;
            abortConfirmation();
        }
        return result;
    }
    async confirmTransactionUsingDurableNonceStrategy({ commitment, strategy: { abortSignal, minContextSlot, nonceAccountPubkey, nonceValue, signature } }) {
        let done = false;
        const expiryPromise = new Promise((resolve)=>{
            let currentNonceValue = nonceValue;
            let lastCheckedSlot = null;
            const getCurrentNonceValue = async ()=>{
                try {
                    const { context, value: nonceAccount } = await this.getNonceAndContext(nonceAccountPubkey, {
                        commitment,
                        minContextSlot
                    });
                    lastCheckedSlot = context.slot;
                    return nonceAccount?.nonce;
                } catch (e) {
                    // If for whatever reason we can't reach/read the nonce
                    // account, just keep using the last-known value.
                    return currentNonceValue;
                }
            };
            (async ()=>{
                currentNonceValue = await getCurrentNonceValue();
                if (done) return;
                while(true // eslint-disable-line no-constant-condition
                ){
                    if (nonceValue !== currentNonceValue) {
                        resolve({
                            __type: TransactionStatus.NONCE_INVALID,
                            slotInWhichNonceDidAdvance: lastCheckedSlot
                        });
                        return;
                    }
                    await sleep(2000);
                    if (done) return;
                    currentNonceValue = await getCurrentNonceValue();
                    if (done) return;
                }
            })();
        });
        const { abortConfirmation, confirmationPromise } = this.getTransactionConfirmationPromise({
            commitment,
            signature
        });
        const cancellationPromise = this.getCancellationPromise(abortSignal);
        let result;
        try {
            const outcome = await Promise.race([
                cancellationPromise,
                confirmationPromise,
                expiryPromise
            ]);
            if (outcome.__type === TransactionStatus.PROCESSED) result = outcome.response;
            else {
                // Double check that the transaction is indeed unconfirmed.
                let signatureStatus;
                while(true // eslint-disable-line no-constant-condition
                ){
                    const status = await this.getSignatureStatus(signature);
                    if (status == null) break;
                    if (status.context.slot < (outcome.slotInWhichNonceDidAdvance ?? minContextSlot)) {
                        await sleep(400);
                        continue;
                    }
                    signatureStatus = status;
                    break;
                }
                if (signatureStatus?.value) {
                    const commitmentForStatus = commitment || "finalized";
                    const { confirmationStatus } = signatureStatus.value;
                    switch(commitmentForStatus){
                        case "processed":
                        case "recent":
                            if (confirmationStatus !== "processed" && confirmationStatus !== "confirmed" && confirmationStatus !== "finalized") throw new TransactionExpiredNonceInvalidError(signature);
                            break;
                        case "confirmed":
                        case "single":
                        case "singleGossip":
                            if (confirmationStatus !== "confirmed" && confirmationStatus !== "finalized") throw new TransactionExpiredNonceInvalidError(signature);
                            break;
                        case "finalized":
                        case "max":
                        case "root":
                            if (confirmationStatus !== "finalized") throw new TransactionExpiredNonceInvalidError(signature);
                            break;
                        default:
                            // Exhaustive switch.
                            // eslint-disable-next-line @typescript-eslint/no-unused-vars
                            ((_)=>{})(commitmentForStatus);
                    }
                    result = {
                        context: signatureStatus.context,
                        value: {
                            err: signatureStatus.value.err
                        }
                    };
                } else throw new TransactionExpiredNonceInvalidError(signature);
            }
        } finally{
            done = true;
            abortConfirmation();
        }
        return result;
    }
    async confirmTransactionUsingLegacyTimeoutStrategy({ commitment, signature }) {
        let timeoutId;
        const expiryPromise = new Promise((resolve)=>{
            let timeoutMs = this._confirmTransactionInitialTimeout || 60000;
            switch(commitment){
                case "processed":
                case "recent":
                case "single":
                case "confirmed":
                case "singleGossip":
                    timeoutMs = this._confirmTransactionInitialTimeout || 30000;
                    break;
            }
            timeoutId = setTimeout(()=>resolve({
                    __type: TransactionStatus.TIMED_OUT,
                    timeoutMs
                }), timeoutMs);
        });
        const { abortConfirmation, confirmationPromise } = this.getTransactionConfirmationPromise({
            commitment,
            signature
        });
        let result;
        try {
            const outcome = await Promise.race([
                confirmationPromise,
                expiryPromise
            ]);
            if (outcome.__type === TransactionStatus.PROCESSED) result = outcome.response;
            else throw new TransactionExpiredTimeoutError(signature, outcome.timeoutMs / 1000);
        } finally{
            clearTimeout(timeoutId);
            abortConfirmation();
        }
        return result;
    }
    /**
   * Return the list of nodes that are currently participating in the cluster
   */ async getClusterNodes() {
        const unsafeRes = await this._rpcRequest("getClusterNodes", []);
        const res = (0, _superstruct.create)(unsafeRes, jsonRpcResult((0, _superstruct.array)(ContactInfoResult)));
        if ("error" in res) throw new SolanaJSONRPCError(res.error, "failed to get cluster nodes");
        return res.result;
    }
    /**
   * Return the list of nodes that are currently participating in the cluster
   */ async getVoteAccounts(commitment) {
        const args = this._buildArgs([], commitment);
        const unsafeRes = await this._rpcRequest("getVoteAccounts", args);
        const res = (0, _superstruct.create)(unsafeRes, GetVoteAccounts);
        if ("error" in res) throw new SolanaJSONRPCError(res.error, "failed to get vote accounts");
        return res.result;
    }
    /**
   * Fetch the current slot that the node is processing
   */ async getSlot(commitmentOrConfig) {
        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);
        const args = this._buildArgs([], commitment, undefined /* encoding */ , config);
        const unsafeRes = await this._rpcRequest("getSlot", args);
        const res = (0, _superstruct.create)(unsafeRes, jsonRpcResult((0, _superstruct.number)()));
        if ("error" in res) throw new SolanaJSONRPCError(res.error, "failed to get slot");
        return res.result;
    }
    /**
   * Fetch the current slot leader of the cluster
   */ async getSlotLeader(commitmentOrConfig) {
        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);
        const args = this._buildArgs([], commitment, undefined /* encoding */ , config);
        const unsafeRes = await this._rpcRequest("getSlotLeader", args);
        const res = (0, _superstruct.create)(unsafeRes, jsonRpcResult((0, _superstruct.string)()));
        if ("error" in res) throw new SolanaJSONRPCError(res.error, "failed to get slot leader");
        return res.result;
    }
    /**
   * Fetch `limit` number of slot leaders starting from `startSlot`
   *
   * @param startSlot fetch slot leaders starting from this slot
   * @param limit number of slot leaders to return
   */ async getSlotLeaders(startSlot, limit) {
        const args = [
            startSlot,
            limit
        ];
        const unsafeRes = await this._rpcRequest("getSlotLeaders", args);
        const res = (0, _superstruct.create)(unsafeRes, jsonRpcResult((0, _superstruct.array)(PublicKeyFromString)));
        if ("error" in res) throw new SolanaJSONRPCError(res.error, "failed to get slot leaders");
        return res.result;
    }
    /**
   * Fetch the current status of a signature
   */ async getSignatureStatus(signature, config) {
        const { context, value: values } = await this.getSignatureStatuses([
            signature
        ], config);
        assert(values.length === 1);
        const value = values[0];
        return {
            context,
            value
        };
    }
    /**
   * Fetch the current statuses of a batch of signatures
   */ async getSignatureStatuses(signatures, config) {
        const params = [
            signatures
        ];
        if (config) params.push(config);
        const unsafeRes = await this._rpcRequest("getSignatureStatuses", params);
        const res = (0, _superstruct.create)(unsafeRes, GetSignatureStatusesRpcResult);
        if ("error" in res) throw new SolanaJSONRPCError(res.error, "failed to get signature status");
        return res.result;
    }
    /**
   * Fetch the current transaction count of the cluster
   */ async getTransactionCount(commitmentOrConfig) {
        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);
        const args = this._buildArgs([], commitment, undefined /* encoding */ , config);
        const unsafeRes = await this._rpcRequest("getTransactionCount", args);
        const res = (0, _superstruct.create)(unsafeRes, jsonRpcResult((0, _superstruct.number)()));
        if ("error" in res) throw new SolanaJSONRPCError(res.error, "failed to get transaction count");
        return res.result;
    }
    /**
   * Fetch the current total currency supply of the cluster in lamports
   *
   * @deprecated Deprecated since RPC v1.2.8. Please use {@link getSupply} instead.
   */ async getTotalSupply(commitment) {
        const result = await this.getSupply({
            commitment,
            excludeNonCirculatingAccountsList: true
        });
        return result.value.total;
    }
    /**
   * Fetch the cluster InflationGovernor parameters
   */ async getInflationGovernor(commitment) {
        const args = this._buildArgs([], commitment);
        const unsafeRes = await this._rpcRequest("getInflationGovernor", args);
        const res = (0, _superstruct.create)(unsafeRes, GetInflationGovernorRpcResult);
        if ("error" in res) throw new SolanaJSONRPCError(res.error, "failed to get inflation");
        return res.result;
    }
    /**
   * Fetch the inflation reward for a list of addresses for an epoch
   */ async getInflationReward(addresses, epoch, commitmentOrConfig) {
        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);
        const args = this._buildArgs([
            addresses.map((pubkey)=>pubkey.toBase58())
        ], commitment, undefined /* encoding */ , {
            ...config,
            epoch: epoch != null ? epoch : config?.epoch
        });
        const unsafeRes = await this._rpcRequest("getInflationReward", args);
        const res = (0, _superstruct.create)(unsafeRes, GetInflationRewardResult);
        if ("error" in res) throw new SolanaJSONRPCError(res.error, "failed to get inflation reward");
        return res.result;
    }
    /**
   * Fetch the specific inflation values for the current epoch
   */ async getInflationRate() {
        const unsafeRes = await this._rpcRequest("getInflationRate", []);
        const res = (0, _superstruct.create)(unsafeRes, GetInflationRateRpcResult);
        if ("error" in res) throw new SolanaJSONRPCError(res.error, "failed to get inflation rate");
        return res.result;
    }
    /**
   * Fetch the Epoch Info parameters
   */ async getEpochInfo(commitmentOrConfig) {
        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);
        const args = this._buildArgs([], commitment, undefined /* encoding */ , config);
        const unsafeRes = await this._rpcRequest("getEpochInfo", args);
        const res = (0, _superstruct.create)(unsafeRes, GetEpochInfoRpcResult);
        if ("error" in res) throw new SolanaJSONRPCError(res.error, "failed to get epoch info");
        return res.result;
    }
    /**
   * Fetch the Epoch Schedule parameters
   */ async getEpochSchedule() {
        const unsafeRes = await this._rpcRequest("getEpochSchedule", []);
        const res = (0, _superstruct.create)(unsafeRes, GetEpochScheduleRpcResult);
        if ("error" in res) throw new SolanaJSONRPCError(res.error, "failed to get epoch schedule");
        const epochSchedule = res.result;
        return new EpochSchedule(epochSchedule.slotsPerEpoch, epochSchedule.leaderScheduleSlotOffset, epochSchedule.warmup, epochSchedule.firstNormalEpoch, epochSchedule.firstNormalSlot);
    }
    /**
   * Fetch the leader schedule for the current epoch
   * @return {Promise<RpcResponseAndContext<LeaderSchedule>>}
   */ async getLeaderSchedule() {
        const unsafeRes = await this._rpcRequest("getLeaderSchedule", []);
        const res = (0, _superstruct.create)(unsafeRes, GetLeaderScheduleRpcResult);
        if ("error" in res) throw new SolanaJSONRPCError(res.error, "failed to get leader schedule");
        return res.result;
    }
    /**
   * Fetch the minimum balance needed to exempt an account of `dataLength`
   * size from rent
   */ async getMinimumBalanceForRentExemption(dataLength, commitment) {
        const args = this._buildArgs([
            dataLength
        ], commitment);
        const unsafeRes = await this._rpcRequest("getMinimumBalanceForRentExemption", args);
        const res = (0, _superstruct.create)(unsafeRes, GetMinimumBalanceForRentExemptionRpcResult);
        if ("error" in res) {
            console.warn("Unable to fetch minimum balance for rent exemption");
            return 0;
        }
        return res.result;
    }
    /**
   * Fetch a recent blockhash from the cluster, return with context
   * @return {Promise<RpcResponseAndContext<{blockhash: Blockhash, feeCalculator: FeeCalculator}>>}
   *
   * @deprecated Deprecated since RPC v1.9.0. Please use {@link getLatestBlockhash} instead.
   */ async getRecentBlockhashAndContext(commitment) {
        const args = this._buildArgs([], commitment);
        const unsafeRes = await this._rpcRequest("getRecentBlockhash", args);
        const res = (0, _superstruct.create)(unsafeRes, GetRecentBlockhashAndContextRpcResult);
        if ("error" in res) throw new SolanaJSONRPCError(res.error, "failed to get recent blockhash");
        return res.result;
    }
    /**
   * Fetch recent performance samples
   * @return {Promise<Array<PerfSample>>}
   */ async getRecentPerformanceSamples(limit) {
        const unsafeRes = await this._rpcRequest("getRecentPerformanceSamples", limit ? [
            limit
        ] : []);
        const res = (0, _superstruct.create)(unsafeRes, GetRecentPerformanceSamplesRpcResult);
        if ("error" in res) throw new SolanaJSONRPCError(res.error, "failed to get recent performance samples");
        return res.result;
    }
    /**
   * Fetch the fee calculator for a recent blockhash from the cluster, return with context
   *
   * @deprecated Deprecated since RPC v1.9.0. Please use {@link getFeeForMessage} instead.
   */ async getFeeCalculatorForBlockhash(blockhash, commitment) {
        const args = this._buildArgs([
            blockhash
        ], commitment);
        const unsafeRes = await this._rpcRequest("getFeeCalculatorForBlockhash", args);
        const res = (0, _superstruct.create)(unsafeRes, GetFeeCalculatorRpcResult);
        if ("error" in res) throw new SolanaJSONRPCError(res.error, "failed to get fee calculator");
        const { context, value } = res.result;
        return {
            context,
            value: value !== null ? value.feeCalculator : null
        };
    }
    /**
   * Fetch the fee for a message from the cluster, return with context
   */ async getFeeForMessage(message, commitment) {
        const wireMessage = toBuffer(message.serialize()).toString("base64");
        const args = this._buildArgs([
            wireMessage
        ], commitment);
        const unsafeRes = await this._rpcRequest("getFeeForMessage", args);
        const res = (0, _superstruct.create)(unsafeRes, jsonRpcResultAndContext((0, _superstruct.nullable)((0, _superstruct.number)())));
        if ("error" in res) throw new SolanaJSONRPCError(res.error, "failed to get fee for message");
        if (res.result === null) throw new Error("invalid blockhash");
        return res.result;
    }
    /**
   * Fetch a list of prioritization fees from recent blocks.
   */ async getRecentPrioritizationFees(config) {
        const accounts = config?.lockedWritableAccounts?.map((key)=>key.toBase58());
        const args = accounts?.length ? [
            accounts
        ] : [];
        const unsafeRes = await this._rpcRequest("getRecentPrioritizationFees", args);
        const res = (0, _superstruct.create)(unsafeRes, GetRecentPrioritizationFeesRpcResult);
        if ("error" in res) throw new SolanaJSONRPCError(res.error, "failed to get recent prioritization fees");
        return res.result;
    }
    /**
   * Fetch a recent blockhash from the cluster
   * @return {Promise<{blockhash: Blockhash, feeCalculator: FeeCalculator}>}
   *
   * @deprecated Deprecated since RPC v1.8.0. Please use {@link getLatestBlockhash} instead.
   */ async getRecentBlockhash(commitment) {
        try {
            const res = await this.getRecentBlockhashAndContext(commitment);
            return res.value;
        } catch (e) {
            throw new Error("failed to get recent blockhash: " + e);
        }
    }
    /**
   * Fetch the latest blockhash from the cluster
   * @return {Promise<BlockhashWithExpiryBlockHeight>}
   */ async getLatestBlockhash(commitmentOrConfig) {
        try {
            const res = await this.getLatestBlockhashAndContext(commitmentOrConfig);
            return res.value;
        } catch (e) {
            throw new Error("failed to get recent blockhash: " + e);
        }
    }
    /**
   * Fetch the latest blockhash from the cluster
   * @return {Promise<BlockhashWithExpiryBlockHeight>}
   */ async getLatestBlockhashAndContext(commitmentOrConfig) {
        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);
        const args = this._buildArgs([], commitment, undefined /* encoding */ , config);
        const unsafeRes = await this._rpcRequest("getLatestBlockhash", args);
        const res = (0, _superstruct.create)(unsafeRes, GetLatestBlockhashRpcResult);
        if ("error" in res) throw new SolanaJSONRPCError(res.error, "failed to get latest blockhash");
        return res.result;
    }
    /**
   * Returns whether a blockhash is still valid or not
   */ async isBlockhashValid(blockhash, rawConfig) {
        const { commitment, config } = extractCommitmentFromConfig(rawConfig);
        const args = this._buildArgs([
            blockhash
        ], commitment, undefined /* encoding */ , config);
        const unsafeRes = await this._rpcRequest("isBlockhashValid", args);
        const res = (0, _superstruct.create)(unsafeRes, IsBlockhashValidRpcResult);
        if ("error" in res) throw new SolanaJSONRPCError(res.error, "failed to determine if the blockhash `" + blockhash + "`is valid");
        return res.result;
    }
    /**
   * Fetch the node version
   */ async getVersion() {
        const unsafeRes = await this._rpcRequest("getVersion", []);
        const res = (0, _superstruct.create)(unsafeRes, jsonRpcResult(VersionResult));
        if ("error" in res) throw new SolanaJSONRPCError(res.error, "failed to get version");
        return res.result;
    }
    /**
   * Fetch the genesis hash
   */ async getGenesisHash() {
        const unsafeRes = await this._rpcRequest("getGenesisHash", []);
        const res = (0, _superstruct.create)(unsafeRes, jsonRpcResult((0, _superstruct.string)()));
        if ("error" in res) throw new SolanaJSONRPCError(res.error, "failed to get genesis hash");
        return res.result;
    }
    /**
   * Fetch a processed block from the cluster.
   *
   * @deprecated Instead, call `getBlock` using a `GetVersionedBlockConfig` by
   * setting the `maxSupportedTransactionVersion` property.
   */ /**
   * @deprecated Instead, call `getBlock` using a `GetVersionedBlockConfig` by
   * setting the `maxSupportedTransactionVersion` property.
   */ // eslint-disable-next-line no-dupe-class-members
    /**
   * @deprecated Instead, call `getBlock` using a `GetVersionedBlockConfig` by
   * setting the `maxSupportedTransactionVersion` property.
   */ // eslint-disable-next-line no-dupe-class-members
    /**
   * Fetch a processed block from the cluster.
   */ // eslint-disable-next-line no-dupe-class-members
    // eslint-disable-next-line no-dupe-class-members
    // eslint-disable-next-line no-dupe-class-members
    /**
   * Fetch a processed block from the cluster.
   */ // eslint-disable-next-line no-dupe-class-members
    async getBlock(slot, rawConfig) {
        const { commitment, config } = extractCommitmentFromConfig(rawConfig);
        const args = this._buildArgsAtLeastConfirmed([
            slot
        ], commitment, undefined /* encoding */ , config);
        const unsafeRes = await this._rpcRequest("getBlock", args);
        try {
            switch(config?.transactionDetails){
                case "accounts":
                    {
                        const res = (0, _superstruct.create)(unsafeRes, GetAccountsModeBlockRpcResult);
                        if ("error" in res) throw res.error;
                        return res.result;
                    }
                case "none":
                    {
                        const res = (0, _superstruct.create)(unsafeRes, GetNoneModeBlockRpcResult);
                        if ("error" in res) throw res.error;
                        return res.result;
                    }
                default:
                    {
                        const res = (0, _superstruct.create)(unsafeRes, GetBlockRpcResult);
                        if ("error" in res) throw res.error;
                        const { result } = res;
                        return result ? {
                            ...result,
                            transactions: result.transactions.map(({ transaction, meta, version })=>({
                                    meta,
                                    transaction: {
                                        ...transaction,
                                        message: versionedMessageFromResponse(version, transaction.message)
                                    },
                                    version
                                }))
                        } : null;
                    }
            }
        } catch (e) {
            throw new SolanaJSONRPCError(e, "failed to get confirmed block");
        }
    }
    /**
   * Fetch parsed transaction details for a confirmed or finalized block
   */ // eslint-disable-next-line no-dupe-class-members
    // eslint-disable-next-line no-dupe-class-members
    // eslint-disable-next-line no-dupe-class-members
    async getParsedBlock(slot, rawConfig) {
        const { commitment, config } = extractCommitmentFromConfig(rawConfig);
        const args = this._buildArgsAtLeastConfirmed([
            slot
        ], commitment, "jsonParsed", config);
        const unsafeRes = await this._rpcRequest("getBlock", args);
        try {
            switch(config?.transactionDetails){
                case "accounts":
                    {
                        const res = (0, _superstruct.create)(unsafeRes, GetParsedAccountsModeBlockRpcResult);
                        if ("error" in res) throw res.error;
                        return res.result;
                    }
                case "none":
                    {
                        const res = (0, _superstruct.create)(unsafeRes, GetParsedNoneModeBlockRpcResult);
                        if ("error" in res) throw res.error;
                        return res.result;
                    }
                default:
                    {
                        const res = (0, _superstruct.create)(unsafeRes, GetParsedBlockRpcResult);
                        if ("error" in res) throw res.error;
                        return res.result;
                    }
            }
        } catch (e) {
            throw new SolanaJSONRPCError(e, "failed to get block");
        }
    }
    /*
   * Returns recent block production information from the current or previous epoch
   */ async getBlockProduction(configOrCommitment) {
        let extra;
        let commitment;
        if (typeof configOrCommitment === "string") commitment = configOrCommitment;
        else if (configOrCommitment) {
            const { commitment: c, ...rest } = configOrCommitment;
            commitment = c;
            extra = rest;
        }
        const args = this._buildArgs([], commitment, "base64", extra);
        const unsafeRes = await this._rpcRequest("getBlockProduction", args);
        const res = (0, _superstruct.create)(unsafeRes, BlockProductionResponseStruct);
        if ("error" in res) throw new SolanaJSONRPCError(res.error, "failed to get block production information");
        return res.result;
    }
    /**
   * Fetch a confirmed or finalized transaction from the cluster.
   *
   * @deprecated Instead, call `getTransaction` using a
   * `GetVersionedTransactionConfig` by setting the
   * `maxSupportedTransactionVersion` property.
   */ /**
   * Fetch a confirmed or finalized transaction from the cluster.
   */ // eslint-disable-next-line no-dupe-class-members
    /**
   * Fetch a confirmed or finalized transaction from the cluster.
   */ // eslint-disable-next-line no-dupe-class-members
    async getTransaction(signature, rawConfig) {
        const { commitment, config } = extractCommitmentFromConfig(rawConfig);
        const args = this._buildArgsAtLeastConfirmed([
            signature
        ], commitment, undefined /* encoding */ , config);
        const unsafeRes = await this._rpcRequest("getTransaction", args);
        const res = (0, _superstruct.create)(unsafeRes, GetTransactionRpcResult);
        if ("error" in res) throw new SolanaJSONRPCError(res.error, "failed to get transaction");
        const result = res.result;
        if (!result) return result;
        return {
            ...result,
            transaction: {
                ...result.transaction,
                message: versionedMessageFromResponse(result.version, result.transaction.message)
            }
        };
    }
    /**
   * Fetch parsed transaction details for a confirmed or finalized transaction
   */ async getParsedTransaction(signature, commitmentOrConfig) {
        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);
        const args = this._buildArgsAtLeastConfirmed([
            signature
        ], commitment, "jsonParsed", config);
        const unsafeRes = await this._rpcRequest("getTransaction", args);
        const res = (0, _superstruct.create)(unsafeRes, GetParsedTransactionRpcResult);
        if ("error" in res) throw new SolanaJSONRPCError(res.error, "failed to get transaction");
        return res.result;
    }
    /**
   * Fetch parsed transaction details for a batch of confirmed transactions
   */ async getParsedTransactions(signatures, commitmentOrConfig) {
        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);
        const batch = signatures.map((signature)=>{
            const args = this._buildArgsAtLeastConfirmed([
                signature
            ], commitment, "jsonParsed", config);
            return {
                methodName: "getTransaction",
                args
            };
        });
        const unsafeRes = await this._rpcBatchRequest(batch);
        const res = unsafeRes.map((unsafeRes)=>{
            const res = (0, _superstruct.create)(unsafeRes, GetParsedTransactionRpcResult);
            if ("error" in res) throw new SolanaJSONRPCError(res.error, "failed to get transactions");
            return res.result;
        });
        return res;
    }
    /**
   * Fetch transaction details for a batch of confirmed transactions.
   * Similar to {@link getParsedTransactions} but returns a {@link TransactionResponse}.
   *
   * @deprecated Instead, call `getTransactions` using a
   * `GetVersionedTransactionConfig` by setting the
   * `maxSupportedTransactionVersion` property.
   */ /**
   * Fetch transaction details for a batch of confirmed transactions.
   * Similar to {@link getParsedTransactions} but returns a {@link
   * VersionedTransactionResponse}.
   */ // eslint-disable-next-line no-dupe-class-members
    /**
   * Fetch transaction details for a batch of confirmed transactions.
   * Similar to {@link getParsedTransactions} but returns a {@link
   * VersionedTransactionResponse}.
   */ // eslint-disable-next-line no-dupe-class-members
    async getTransactions(signatures, commitmentOrConfig) {
        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);
        const batch = signatures.map((signature)=>{
            const args = this._buildArgsAtLeastConfirmed([
                signature
            ], commitment, undefined /* encoding */ , config);
            return {
                methodName: "getTransaction",
                args
            };
        });
        const unsafeRes = await this._rpcBatchRequest(batch);
        const res = unsafeRes.map((unsafeRes)=>{
            const res = (0, _superstruct.create)(unsafeRes, GetTransactionRpcResult);
            if ("error" in res) throw new SolanaJSONRPCError(res.error, "failed to get transactions");
            const result = res.result;
            if (!result) return result;
            return {
                ...result,
                transaction: {
                    ...result.transaction,
                    message: versionedMessageFromResponse(result.version, result.transaction.message)
                }
            };
        });
        return res;
    }
    /**
   * Fetch a list of Transactions and transaction statuses from the cluster
   * for a confirmed block.
   *
   * @deprecated Deprecated since RPC v1.7.0. Please use {@link getBlock} instead.
   */ async getConfirmedBlock(slot, commitment) {
        const args = this._buildArgsAtLeastConfirmed([
            slot
        ], commitment);
        const unsafeRes = await this._rpcRequest("getConfirmedBlock", args);
        const res = (0, _superstruct.create)(unsafeRes, GetConfirmedBlockRpcResult);
        if ("error" in res) throw new SolanaJSONRPCError(res.error, "failed to get confirmed block");
        const result = res.result;
        if (!result) throw new Error("Confirmed block " + slot + " not found");
        const block = {
            ...result,
            transactions: result.transactions.map(({ transaction, meta })=>{
                const message = new Message(transaction.message);
                return {
                    meta,
                    transaction: {
                        ...transaction,
                        message
                    }
                };
            })
        };
        return {
            ...block,
            transactions: block.transactions.map(({ transaction, meta })=>{
                return {
                    meta,
                    transaction: Transaction.populate(transaction.message, transaction.signatures)
                };
            })
        };
    }
    /**
   * Fetch confirmed blocks between two slots
   */ async getBlocks(startSlot, endSlot, commitment) {
        const args = this._buildArgsAtLeastConfirmed(endSlot !== undefined ? [
            startSlot,
            endSlot
        ] : [
            startSlot
        ], commitment);
        const unsafeRes = await this._rpcRequest("getBlocks", args);
        const res = (0, _superstruct.create)(unsafeRes, jsonRpcResult((0, _superstruct.array)((0, _superstruct.number)())));
        if ("error" in res) throw new SolanaJSONRPCError(res.error, "failed to get blocks");
        return res.result;
    }
    /**
   * Fetch a list of Signatures from the cluster for a block, excluding rewards
   */ async getBlockSignatures(slot, commitment) {
        const args = this._buildArgsAtLeastConfirmed([
            slot
        ], commitment, undefined, {
            transactionDetails: "signatures",
            rewards: false
        });
        const unsafeRes = await this._rpcRequest("getBlock", args);
        const res = (0, _superstruct.create)(unsafeRes, GetBlockSignaturesRpcResult);
        if ("error" in res) throw new SolanaJSONRPCError(res.error, "failed to get block");
        const result = res.result;
        if (!result) throw new Error("Block " + slot + " not found");
        return result;
    }
    /**
   * Fetch a list of Signatures from the cluster for a confirmed block, excluding rewards
   *
   * @deprecated Deprecated since RPC v1.7.0. Please use {@link getBlockSignatures} instead.
   */ async getConfirmedBlockSignatures(slot, commitment) {
        const args = this._buildArgsAtLeastConfirmed([
            slot
        ], commitment, undefined, {
            transactionDetails: "signatures",
            rewards: false
        });
        const unsafeRes = await this._rpcRequest("getConfirmedBlock", args);
        const res = (0, _superstruct.create)(unsafeRes, GetBlockSignaturesRpcResult);
        if ("error" in res) throw new SolanaJSONRPCError(res.error, "failed to get confirmed block");
        const result = res.result;
        if (!result) throw new Error("Confirmed block " + slot + " not found");
        return result;
    }
    /**
   * Fetch a transaction details for a confirmed transaction
   *
   * @deprecated Deprecated since RPC v1.7.0. Please use {@link getTransaction} instead.
   */ async getConfirmedTransaction(signature, commitment) {
        const args = this._buildArgsAtLeastConfirmed([
            signature
        ], commitment);
        const unsafeRes = await this._rpcRequest("getConfirmedTransaction", args);
        const res = (0, _superstruct.create)(unsafeRes, GetTransactionRpcResult);
        if ("error" in res) throw new SolanaJSONRPCError(res.error, "failed to get transaction");
        const result = res.result;
        if (!result) return result;
        const message = new Message(result.transaction.message);
        const signatures = result.transaction.signatures;
        return {
            ...result,
            transaction: Transaction.populate(message, signatures)
        };
    }
    /**
   * Fetch parsed transaction details for a confirmed transaction
   *
   * @deprecated Deprecated since RPC v1.7.0. Please use {@link getParsedTransaction} instead.
   */ async getParsedConfirmedTransaction(signature, commitment) {
        const args = this._buildArgsAtLeastConfirmed([
            signature
        ], commitment, "jsonParsed");
        const unsafeRes = await this._rpcRequest("getConfirmedTransaction", args);
        const res = (0, _superstruct.create)(unsafeRes, GetParsedTransactionRpcResult);
        if ("error" in res) throw new SolanaJSONRPCError(res.error, "failed to get confirmed transaction");
        return res.result;
    }
    /**
   * Fetch parsed transaction details for a batch of confirmed transactions
   *
   * @deprecated Deprecated since RPC v1.7.0. Please use {@link getParsedTransactions} instead.
   */ async getParsedConfirmedTransactions(signatures, commitment) {
        const batch = signatures.map((signature)=>{
            const args = this._buildArgsAtLeastConfirmed([
                signature
            ], commitment, "jsonParsed");
            return {
                methodName: "getConfirmedTransaction",
                args
            };
        });
        const unsafeRes = await this._rpcBatchRequest(batch);
        const res = unsafeRes.map((unsafeRes)=>{
            const res = (0, _superstruct.create)(unsafeRes, GetParsedTransactionRpcResult);
            if ("error" in res) throw new SolanaJSONRPCError(res.error, "failed to get confirmed transactions");
            return res.result;
        });
        return res;
    }
    /**
   * Fetch a list of all the confirmed signatures for transactions involving an address
   * within a specified slot range. Max range allowed is 10,000 slots.
   *
   * @deprecated Deprecated since RPC v1.3. Please use {@link getConfirmedSignaturesForAddress2} instead.
   *
   * @param address queried address
   * @param startSlot start slot, inclusive
   * @param endSlot end slot, inclusive
   */ async getConfirmedSignaturesForAddress(address, startSlot, endSlot) {
        let options = {};
        let firstAvailableBlock = await this.getFirstAvailableBlock();
        while(!("until" in options)){
            startSlot--;
            if (startSlot <= 0 || startSlot < firstAvailableBlock) break;
            try {
                const block = await this.getConfirmedBlockSignatures(startSlot, "finalized");
                if (block.signatures.length > 0) options.until = block.signatures[block.signatures.length - 1].toString();
            } catch (err) {
                if (err instanceof Error && err.message.includes("skipped")) continue;
                else throw err;
            }
        }
        let highestConfirmedRoot = await this.getSlot("finalized");
        while(!("before" in options)){
            endSlot++;
            if (endSlot > highestConfirmedRoot) break;
            try {
                const block = await this.getConfirmedBlockSignatures(endSlot);
                if (block.signatures.length > 0) options.before = block.signatures[block.signatures.length - 1].toString();
            } catch (err) {
                if (err instanceof Error && err.message.includes("skipped")) continue;
                else throw err;
            }
        }
        const confirmedSignatureInfo = await this.getConfirmedSignaturesForAddress2(address, options);
        return confirmedSignatureInfo.map((info)=>info.signature);
    }
    /**
   * Returns confirmed signatures for transactions involving an
   * address backwards in time from the provided signature or most recent confirmed block
   *
   * @deprecated Deprecated since RPC v1.7.0. Please use {@link getSignaturesForAddress} instead.
   */ async getConfirmedSignaturesForAddress2(address, options, commitment) {
        const args = this._buildArgsAtLeastConfirmed([
            address.toBase58()
        ], commitment, undefined, options);
        const unsafeRes = await this._rpcRequest("getConfirmedSignaturesForAddress2", args);
        const res = (0, _superstruct.create)(unsafeRes, GetConfirmedSignaturesForAddress2RpcResult);
        if ("error" in res) throw new SolanaJSONRPCError(res.error, "failed to get confirmed signatures for address");
        return res.result;
    }
    /**
   * Returns confirmed signatures for transactions involving an
   * address backwards in time from the provided signature or most recent confirmed block
   *
   *
   * @param address queried address
   * @param options
   */ async getSignaturesForAddress(address, options, commitment) {
        const args = this._buildArgsAtLeastConfirmed([
            address.toBase58()
        ], commitment, undefined, options);
        const unsafeRes = await this._rpcRequest("getSignaturesForAddress", args);
        const res = (0, _superstruct.create)(unsafeRes, GetSignaturesForAddressRpcResult);
        if ("error" in res) throw new SolanaJSONRPCError(res.error, "failed to get signatures for address");
        return res.result;
    }
    async getAddressLookupTable(accountKey, config) {
        const { context, value: accountInfo } = await this.getAccountInfoAndContext(accountKey, config);
        let value = null;
        if (accountInfo !== null) value = new AddressLookupTableAccount({
            key: accountKey,
            state: AddressLookupTableAccount.deserialize(accountInfo.data)
        });
        return {
            context,
            value
        };
    }
    /**
   * Fetch the contents of a Nonce account from the cluster, return with context
   */ async getNonceAndContext(nonceAccount, commitmentOrConfig) {
        const { context, value: accountInfo } = await this.getAccountInfoAndContext(nonceAccount, commitmentOrConfig);
        let value = null;
        if (accountInfo !== null) value = NonceAccount.fromAccountData(accountInfo.data);
        return {
            context,
            value
        };
    }
    /**
   * Fetch the contents of a Nonce account from the cluster
   */ async getNonce(nonceAccount, commitmentOrConfig) {
        return await this.getNonceAndContext(nonceAccount, commitmentOrConfig).then((x)=>x.value).catch((e)=>{
            throw new Error("failed to get nonce for account " + nonceAccount.toBase58() + ": " + e);
        });
    }
    /**
   * Request an allocation of lamports to the specified address
   *
   * ```typescript
   * import { Connection, PublicKey, LAMPORTS_PER_SOL } from "@solana/web3.js";
   *
   * (async () => {
   *   const connection = new Connection("https://api.testnet.solana.com", "confirmed");
   *   const myAddress = new PublicKey("2nr1bHFT86W9tGnyvmYW4vcHKsQB3sVQfnddasz4kExM");
   *   const signature = await connection.requestAirdrop(myAddress, LAMPORTS_PER_SOL);
   *   await connection.confirmTransaction(signature);
   * })();
   * ```
   */ async requestAirdrop(to, lamports) {
        const unsafeRes = await this._rpcRequest("requestAirdrop", [
            to.toBase58(),
            lamports
        ]);
        const res = (0, _superstruct.create)(unsafeRes, RequestAirdropRpcResult);
        if ("error" in res) throw new SolanaJSONRPCError(res.error, `airdrop to ${to.toBase58()} failed`);
        return res.result;
    }
    /**
   * @internal
   */ async _blockhashWithExpiryBlockHeight(disableCache) {
        if (!disableCache) {
            // Wait for polling to finish
            while(this._pollingBlockhash)await sleep(100);
            const timeSinceFetch = Date.now() - this._blockhashInfo.lastFetch;
            const expired = timeSinceFetch >= BLOCKHASH_CACHE_TIMEOUT_MS;
            if (this._blockhashInfo.latestBlockhash !== null && !expired) return this._blockhashInfo.latestBlockhash;
        }
        return await this._pollNewBlockhash();
    }
    /**
   * @internal
   */ async _pollNewBlockhash() {
        this._pollingBlockhash = true;
        try {
            const startTime = Date.now();
            const cachedLatestBlockhash = this._blockhashInfo.latestBlockhash;
            const cachedBlockhash = cachedLatestBlockhash ? cachedLatestBlockhash.blockhash : null;
            for(let i = 0; i < 50; i++){
                const latestBlockhash = await this.getLatestBlockhash("finalized");
                if (cachedBlockhash !== latestBlockhash.blockhash) {
                    this._blockhashInfo = {
                        latestBlockhash,
                        lastFetch: Date.now(),
                        transactionSignatures: [],
                        simulatedSignatures: []
                    };
                    return latestBlockhash;
                }
                // Sleep for approximately half a slot
                await sleep(MS_PER_SLOT / 2);
            }
            throw new Error(`Unable to obtain a new blockhash after ${Date.now() - startTime}ms`);
        } finally{
            this._pollingBlockhash = false;
        }
    }
    /**
   * get the stake minimum delegation
   */ async getStakeMinimumDelegation(config) {
        const { commitment, config: configArg } = extractCommitmentFromConfig(config);
        const args = this._buildArgs([], commitment, "base64", configArg);
        const unsafeRes = await this._rpcRequest("getStakeMinimumDelegation", args);
        const res = (0, _superstruct.create)(unsafeRes, jsonRpcResultAndContext((0, _superstruct.number)()));
        if ("error" in res) throw new SolanaJSONRPCError(res.error, `failed to get stake minimum delegation`);
        return res.result;
    }
    /**
   * Simulate a transaction
   *
   * @deprecated Instead, call {@link simulateTransaction} with {@link
   * VersionedTransaction} and {@link SimulateTransactionConfig} parameters
   */ /**
   * Simulate a transaction
   */ // eslint-disable-next-line no-dupe-class-members
    /**
   * Simulate a transaction
   */ // eslint-disable-next-line no-dupe-class-members
    async simulateTransaction(transactionOrMessage, configOrSigners, includeAccounts) {
        if ("message" in transactionOrMessage) {
            const versionedTx = transactionOrMessage;
            const wireTransaction = versionedTx.serialize();
            const encodedTransaction = (0, _buffer.Buffer).from(wireTransaction).toString("base64");
            if (Array.isArray(configOrSigners) || includeAccounts !== undefined) throw new Error("Invalid arguments");
            const config = configOrSigners || {};
            config.encoding = "base64";
            if (!("commitment" in config)) config.commitment = this.commitment;
            if (configOrSigners && typeof configOrSigners === "object" && "innerInstructions" in configOrSigners) config.innerInstructions = configOrSigners.innerInstructions;
            const args = [
                encodedTransaction,
                config
            ];
            const unsafeRes = await this._rpcRequest("simulateTransaction", args);
            const res = (0, _superstruct.create)(unsafeRes, SimulatedTransactionResponseStruct);
            if ("error" in res) throw new Error("failed to simulate transaction: " + res.error.message);
            return res.result;
        }
        let transaction;
        if (transactionOrMessage instanceof Transaction) {
            let originalTx = transactionOrMessage;
            transaction = new Transaction();
            transaction.feePayer = originalTx.feePayer;
            transaction.instructions = transactionOrMessage.instructions;
            transaction.nonceInfo = originalTx.nonceInfo;
            transaction.signatures = originalTx.signatures;
        } else {
            transaction = Transaction.populate(transactionOrMessage);
            // HACK: this function relies on mutating the populated transaction
            transaction._message = transaction._json = undefined;
        }
        if (configOrSigners !== undefined && !Array.isArray(configOrSigners)) throw new Error("Invalid arguments");
        const signers = configOrSigners;
        if (transaction.nonceInfo && signers) transaction.sign(...signers);
        else {
            let disableCache = this._disableBlockhashCaching;
            for(;;){
                const latestBlockhash = await this._blockhashWithExpiryBlockHeight(disableCache);
                transaction.lastValidBlockHeight = latestBlockhash.lastValidBlockHeight;
                transaction.recentBlockhash = latestBlockhash.blockhash;
                if (!signers) break;
                transaction.sign(...signers);
                if (!transaction.signature) throw new Error("!signature"); // should never happen
                const signature = transaction.signature.toString("base64");
                if (!this._blockhashInfo.simulatedSignatures.includes(signature) && !this._blockhashInfo.transactionSignatures.includes(signature)) {
                    // The signature of this transaction has not been seen before with the
                    // current recentBlockhash, all done. Let's break
                    this._blockhashInfo.simulatedSignatures.push(signature);
                    break;
                } else // This transaction would be treated as duplicate (its derived signature
                // matched to one of already recorded signatures).
                // So, we must fetch a new blockhash for a different signature by disabling
                // our cache not to wait for the cache expiration (BLOCKHASH_CACHE_TIMEOUT_MS).
                disableCache = true;
            }
        }
        const message = transaction._compile();
        const signData = message.serialize();
        const wireTransaction = transaction._serialize(signData);
        const encodedTransaction = wireTransaction.toString("base64");
        const config = {
            encoding: "base64",
            commitment: this.commitment
        };
        if (includeAccounts) {
            const addresses = (Array.isArray(includeAccounts) ? includeAccounts : message.nonProgramIds()).map((key)=>key.toBase58());
            config["accounts"] = {
                encoding: "base64",
                addresses
            };
        }
        if (signers) config.sigVerify = true;
        if (configOrSigners && typeof configOrSigners === "object" && "innerInstructions" in configOrSigners) config.innerInstructions = configOrSigners.innerInstructions;
        const args = [
            encodedTransaction,
            config
        ];
        const unsafeRes = await this._rpcRequest("simulateTransaction", args);
        const res = (0, _superstruct.create)(unsafeRes, SimulatedTransactionResponseStruct);
        if ("error" in res) {
            let logs;
            if ("data" in res.error) {
                logs = res.error.data.logs;
                if (logs && Array.isArray(logs)) {
                    const traceIndent = "\n    ";
                    const logTrace = traceIndent + logs.join(traceIndent);
                    console.error(res.error.message, logTrace);
                }
            }
            throw new SendTransactionError({
                action: "simulate",
                signature: "",
                transactionMessage: res.error.message,
                logs: logs
            });
        }
        return res.result;
    }
    /**
   * Sign and send a transaction
   *
   * @deprecated Instead, call {@link sendTransaction} with a {@link
   * VersionedTransaction}
   */ /**
   * Send a signed transaction
   */ // eslint-disable-next-line no-dupe-class-members
    /**
   * Sign and send a transaction
   */ // eslint-disable-next-line no-dupe-class-members
    async sendTransaction(transaction, signersOrOptions, options) {
        if ("version" in transaction) {
            if (signersOrOptions && Array.isArray(signersOrOptions)) throw new Error("Invalid arguments");
            const wireTransaction = transaction.serialize();
            return await this.sendRawTransaction(wireTransaction, signersOrOptions);
        }
        if (signersOrOptions === undefined || !Array.isArray(signersOrOptions)) throw new Error("Invalid arguments");
        const signers = signersOrOptions;
        if (transaction.nonceInfo) transaction.sign(...signers);
        else {
            let disableCache = this._disableBlockhashCaching;
            for(;;){
                const latestBlockhash = await this._blockhashWithExpiryBlockHeight(disableCache);
                transaction.lastValidBlockHeight = latestBlockhash.lastValidBlockHeight;
                transaction.recentBlockhash = latestBlockhash.blockhash;
                transaction.sign(...signers);
                if (!transaction.signature) throw new Error("!signature"); // should never happen
                const signature = transaction.signature.toString("base64");
                if (!this._blockhashInfo.transactionSignatures.includes(signature)) {
                    // The signature of this transaction has not been seen before with the
                    // current recentBlockhash, all done. Let's break
                    this._blockhashInfo.transactionSignatures.push(signature);
                    break;
                } else // This transaction would be treated as duplicate (its derived signature
                // matched to one of already recorded signatures).
                // So, we must fetch a new blockhash for a different signature by disabling
                // our cache not to wait for the cache expiration (BLOCKHASH_CACHE_TIMEOUT_MS).
                disableCache = true;
            }
        }
        const wireTransaction = transaction.serialize();
        return await this.sendRawTransaction(wireTransaction, options);
    }
    /**
   * Send a transaction that has already been signed and serialized into the
   * wire format
   */ async sendRawTransaction(rawTransaction, options) {
        const encodedTransaction = toBuffer(rawTransaction).toString("base64");
        const result = await this.sendEncodedTransaction(encodedTransaction, options);
        return result;
    }
    /**
   * Send a transaction that has already been signed, serialized into the
   * wire format, and encoded as a base64 string
   */ async sendEncodedTransaction(encodedTransaction, options) {
        const config = {
            encoding: "base64"
        };
        const skipPreflight = options && options.skipPreflight;
        const preflightCommitment = skipPreflight === true ? "processed" // FIXME Remove when https://github.com/anza-xyz/agave/pull/483 is deployed.
         : options && options.preflightCommitment || this.commitment;
        if (options && options.maxRetries != null) config.maxRetries = options.maxRetries;
        if (options && options.minContextSlot != null) config.minContextSlot = options.minContextSlot;
        if (skipPreflight) config.skipPreflight = skipPreflight;
        if (preflightCommitment) config.preflightCommitment = preflightCommitment;
        const args = [
            encodedTransaction,
            config
        ];
        const unsafeRes = await this._rpcRequest("sendTransaction", args);
        const res = (0, _superstruct.create)(unsafeRes, SendTransactionRpcResult);
        if ("error" in res) {
            let logs = undefined;
            if ("data" in res.error) logs = res.error.data.logs;
            throw new SendTransactionError({
                action: skipPreflight ? "send" : "simulate",
                signature: "",
                transactionMessage: res.error.message,
                logs: logs
            });
        }
        return res.result;
    }
    /**
   * @internal
   */ _wsOnOpen() {
        this._rpcWebSocketConnected = true;
        this._rpcWebSocketHeartbeat = setInterval(()=>{
            // Ping server every 5s to prevent idle timeouts
            (async ()=>{
                try {
                    await this._rpcWebSocket.notify("ping");
                // eslint-disable-next-line no-empty
                } catch  {}
            })();
        }, 5000);
        this._updateSubscriptions();
    }
    /**
   * @internal
   */ _wsOnError(err) {
        this._rpcWebSocketConnected = false;
        console.error("ws error:", err.message);
    }
    /**
   * @internal
   */ _wsOnClose(code) {
        this._rpcWebSocketConnected = false;
        this._rpcWebSocketGeneration = (this._rpcWebSocketGeneration + 1) % Number.MAX_SAFE_INTEGER;
        if (this._rpcWebSocketIdleTimeout) {
            clearTimeout(this._rpcWebSocketIdleTimeout);
            this._rpcWebSocketIdleTimeout = null;
        }
        if (this._rpcWebSocketHeartbeat) {
            clearInterval(this._rpcWebSocketHeartbeat);
            this._rpcWebSocketHeartbeat = null;
        }
        if (code === 1000) {
            // explicit close, check if any subscriptions have been made since close
            this._updateSubscriptions();
            return;
        }
        // implicit close, prepare subscriptions for auto-reconnect
        this._subscriptionCallbacksByServerSubscriptionId = {};
        Object.entries(this._subscriptionsByHash).forEach(([hash, subscription])=>{
            this._setSubscription(hash, {
                ...subscription,
                state: "pending"
            });
        });
    }
    /**
   * @internal
   */ _setSubscription(hash, nextSubscription) {
        const prevState = this._subscriptionsByHash[hash]?.state;
        this._subscriptionsByHash[hash] = nextSubscription;
        if (prevState !== nextSubscription.state) {
            const stateChangeCallbacks = this._subscriptionStateChangeCallbacksByHash[hash];
            if (stateChangeCallbacks) stateChangeCallbacks.forEach((cb)=>{
                try {
                    cb(nextSubscription.state);
                // eslint-disable-next-line no-empty
                } catch  {}
            });
        }
    }
    /**
   * @internal
   */ _onSubscriptionStateChange(clientSubscriptionId, callback) {
        const hash = this._subscriptionHashByClientSubscriptionId[clientSubscriptionId];
        if (hash == null) return ()=>{};
        const stateChangeCallbacks = this._subscriptionStateChangeCallbacksByHash[hash] ||= new Set();
        stateChangeCallbacks.add(callback);
        return ()=>{
            stateChangeCallbacks.delete(callback);
            if (stateChangeCallbacks.size === 0) delete this._subscriptionStateChangeCallbacksByHash[hash];
        };
    }
    /**
   * @internal
   */ async _updateSubscriptions() {
        if (Object.keys(this._subscriptionsByHash).length === 0) {
            if (this._rpcWebSocketConnected) {
                this._rpcWebSocketConnected = false;
                this._rpcWebSocketIdleTimeout = setTimeout(()=>{
                    this._rpcWebSocketIdleTimeout = null;
                    try {
                        this._rpcWebSocket.close();
                    } catch (err) {
                        // swallow error if socket has already been closed.
                        if (err instanceof Error) console.log(`Error when closing socket connection: ${err.message}`);
                    }
                }, 500);
            }
            return;
        }
        if (this._rpcWebSocketIdleTimeout !== null) {
            clearTimeout(this._rpcWebSocketIdleTimeout);
            this._rpcWebSocketIdleTimeout = null;
            this._rpcWebSocketConnected = true;
        }
        if (!this._rpcWebSocketConnected) {
            this._rpcWebSocket.connect();
            return;
        }
        const activeWebSocketGeneration = this._rpcWebSocketGeneration;
        const isCurrentConnectionStillActive = ()=>{
            return activeWebSocketGeneration === this._rpcWebSocketGeneration;
        };
        await Promise.all(// Don't be tempted to change this to `Object.entries`. We call
        // `_updateSubscriptions` recursively when processing the state,
        // so it's important that we look up the *current* version of
        // each subscription, every time we process a hash.
        Object.keys(this._subscriptionsByHash).map(async (hash)=>{
            const subscription = this._subscriptionsByHash[hash];
            if (subscription === undefined) // This entry has since been deleted. Skip.
            return;
            switch(subscription.state){
                case "pending":
                case "unsubscribed":
                    if (subscription.callbacks.size === 0) {
                        /**
             * You can end up here when:
             *
             * - a subscription has recently unsubscribed
             *   without having new callbacks added to it
             *   while the unsubscribe was in flight, or
             * - when a pending subscription has its
             *   listeners removed before a request was
             *   sent to the server.
             *
             * Being that nobody is interested in this
             * subscription any longer, delete it.
             */ delete this._subscriptionsByHash[hash];
                        if (subscription.state === "unsubscribed") delete this._subscriptionCallbacksByServerSubscriptionId[subscription.serverSubscriptionId];
                        await this._updateSubscriptions();
                        return;
                    }
                    await (async ()=>{
                        const { args, method } = subscription;
                        try {
                            this._setSubscription(hash, {
                                ...subscription,
                                state: "subscribing"
                            });
                            const serverSubscriptionId = await this._rpcWebSocket.call(method, args);
                            this._setSubscription(hash, {
                                ...subscription,
                                serverSubscriptionId,
                                state: "subscribed"
                            });
                            this._subscriptionCallbacksByServerSubscriptionId[serverSubscriptionId] = subscription.callbacks;
                            await this._updateSubscriptions();
                        } catch (e) {
                            console.error(`Received ${e instanceof Error ? "" : "JSON-RPC "}error calling \`${method}\``, {
                                args,
                                error: e
                            });
                            if (!isCurrentConnectionStillActive()) return;
                            // TODO: Maybe add an 'errored' state or a retry limit?
                            this._setSubscription(hash, {
                                ...subscription,
                                state: "pending"
                            });
                            await this._updateSubscriptions();
                        }
                    })();
                    break;
                case "subscribed":
                    if (subscription.callbacks.size === 0) // By the time we successfully set up a subscription
                    // with the server, the client stopped caring about it.
                    // Tear it down now.
                    await (async ()=>{
                        const { serverSubscriptionId, unsubscribeMethod } = subscription;
                        if (this._subscriptionsAutoDisposedByRpc.has(serverSubscriptionId)) /**
                 * Special case.
                 * If we're dealing with a subscription that has been auto-
                 * disposed by the RPC, then we can skip the RPC call to
                 * tear down the subscription here.
                 *
                 * NOTE: There is a proposal to eliminate this special case, here:
                 * https://github.com/solana-labs/solana/issues/18892
                 */ this._subscriptionsAutoDisposedByRpc.delete(serverSubscriptionId);
                        else {
                            this._setSubscription(hash, {
                                ...subscription,
                                state: "unsubscribing"
                            });
                            this._setSubscription(hash, {
                                ...subscription,
                                state: "unsubscribing"
                            });
                            try {
                                await this._rpcWebSocket.call(unsubscribeMethod, [
                                    serverSubscriptionId
                                ]);
                            } catch (e) {
                                if (e instanceof Error) console.error(`${unsubscribeMethod} error:`, e.message);
                                if (!isCurrentConnectionStillActive()) return;
                                // TODO: Maybe add an 'errored' state or a retry limit?
                                this._setSubscription(hash, {
                                    ...subscription,
                                    state: "subscribed"
                                });
                                await this._updateSubscriptions();
                                return;
                            }
                        }
                        this._setSubscription(hash, {
                            ...subscription,
                            state: "unsubscribed"
                        });
                        await this._updateSubscriptions();
                    })();
                    break;
            }
        }));
    }
    /**
   * @internal
   */ _handleServerNotification(serverSubscriptionId, callbackArgs) {
        const callbacks = this._subscriptionCallbacksByServerSubscriptionId[serverSubscriptionId];
        if (callbacks === undefined) return;
        callbacks.forEach((cb)=>{
            try {
                cb(// I failed to find a way to convince TypeScript that `cb` is of type
                // `TCallback` which is certainly compatible with `Parameters<TCallback>`.
                // See https://github.com/microsoft/TypeScript/issues/47615
                // @ts-ignore
                ...callbackArgs);
            } catch (e) {
                console.error(e);
            }
        });
    }
    /**
   * @internal
   */ _wsOnAccountNotification(notification) {
        const { result, subscription } = (0, _superstruct.create)(notification, AccountNotificationResult);
        this._handleServerNotification(subscription, [
            result.value,
            result.context
        ]);
    }
    /**
   * @internal
   */ _makeSubscription(subscriptionConfig, /**
   * When preparing `args` for a call to `_makeSubscription`, be sure
   * to carefully apply a default `commitment` property, if necessary.
   *
   * - If the user supplied a `commitment` use that.
   * - Otherwise, if the `Connection::commitment` is set, use that.
   * - Otherwise, set it to the RPC server default: `finalized`.
   *
   * This is extremely important to ensure that these two fundamentally
   * identical subscriptions produce the same identifying hash:
   *
   * - A subscription made without specifying a commitment.
   * - A subscription made where the commitment specified is the same
   *   as the default applied to the subscription above.
   *
   * Example; these two subscriptions must produce the same hash:
   *
   * - An `accountSubscribe` subscription for `'PUBKEY'`
   * - An `accountSubscribe` subscription for `'PUBKEY'` with commitment
   *   `'finalized'`.
   *
   * See the 'making a subscription with defaulted params omitted' test
   * in `connection-subscriptions.ts` for more.
   */ args) {
        const clientSubscriptionId = this._nextClientSubscriptionId++;
        const hash = fastStableStringify([
            subscriptionConfig.method,
            args
        ]);
        const existingSubscription = this._subscriptionsByHash[hash];
        if (existingSubscription === undefined) this._subscriptionsByHash[hash] = {
            ...subscriptionConfig,
            args,
            callbacks: new Set([
                subscriptionConfig.callback
            ]),
            state: "pending"
        };
        else existingSubscription.callbacks.add(subscriptionConfig.callback);
        this._subscriptionHashByClientSubscriptionId[clientSubscriptionId] = hash;
        this._subscriptionDisposeFunctionsByClientSubscriptionId[clientSubscriptionId] = async ()=>{
            delete this._subscriptionDisposeFunctionsByClientSubscriptionId[clientSubscriptionId];
            delete this._subscriptionHashByClientSubscriptionId[clientSubscriptionId];
            const subscription = this._subscriptionsByHash[hash];
            assert(subscription !== undefined, `Could not find a \`Subscription\` when tearing down client subscription #${clientSubscriptionId}`);
            subscription.callbacks.delete(subscriptionConfig.callback);
            await this._updateSubscriptions();
        };
        this._updateSubscriptions();
        return clientSubscriptionId;
    }
    /**
   * Register a callback to be invoked whenever the specified account changes
   *
   * @param publicKey Public key of the account to monitor
   * @param callback Function to invoke whenever the account is changed
   * @param config
   * @return subscription id
   */ /** @deprecated Instead, pass in an {@link AccountSubscriptionConfig} */ // eslint-disable-next-line no-dupe-class-members
    // eslint-disable-next-line no-dupe-class-members
    onAccountChange(publicKey, callback, commitmentOrConfig) {
        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);
        const args = this._buildArgs([
            publicKey.toBase58()
        ], commitment || this._commitment || "finalized", // Apply connection/server default.
        "base64", config);
        return this._makeSubscription({
            callback,
            method: "accountSubscribe",
            unsubscribeMethod: "accountUnsubscribe"
        }, args);
    }
    /**
   * Deregister an account notification callback
   *
   * @param clientSubscriptionId client subscription id to deregister
   */ async removeAccountChangeListener(clientSubscriptionId) {
        await this._unsubscribeClientSubscription(clientSubscriptionId, "account change");
    }
    /**
   * @internal
   */ _wsOnProgramAccountNotification(notification) {
        const { result, subscription } = (0, _superstruct.create)(notification, ProgramAccountNotificationResult);
        this._handleServerNotification(subscription, [
            {
                accountId: result.value.pubkey,
                accountInfo: result.value.account
            },
            result.context
        ]);
    }
    /**
   * Register a callback to be invoked whenever accounts owned by the
   * specified program change
   *
   * @param programId Public key of the program to monitor
   * @param callback Function to invoke whenever the account is changed
   * @param config
   * @return subscription id
   */ /** @deprecated Instead, pass in a {@link ProgramAccountSubscriptionConfig} */ // eslint-disable-next-line no-dupe-class-members
    // eslint-disable-next-line no-dupe-class-members
    onProgramAccountChange(programId, callback, commitmentOrConfig, maybeFilters) {
        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);
        const args = this._buildArgs([
            programId.toBase58()
        ], commitment || this._commitment || "finalized", // Apply connection/server default.
        "base64" /* encoding */ , config ? config : maybeFilters ? {
            filters: applyDefaultMemcmpEncodingToFilters(maybeFilters)
        } : undefined /* extra */ );
        return this._makeSubscription({
            callback,
            method: "programSubscribe",
            unsubscribeMethod: "programUnsubscribe"
        }, args);
    }
    /**
   * Deregister an account notification callback
   *
   * @param clientSubscriptionId client subscription id to deregister
   */ async removeProgramAccountChangeListener(clientSubscriptionId) {
        await this._unsubscribeClientSubscription(clientSubscriptionId, "program account change");
    }
    /**
   * Registers a callback to be invoked whenever logs are emitted.
   */ onLogs(filter, callback, commitment) {
        const args = this._buildArgs([
            typeof filter === "object" ? {
                mentions: [
                    filter.toString()
                ]
            } : filter
        ], commitment || this._commitment || "finalized" // Apply connection/server default.
        );
        return this._makeSubscription({
            callback,
            method: "logsSubscribe",
            unsubscribeMethod: "logsUnsubscribe"
        }, args);
    }
    /**
   * Deregister a logs callback.
   *
   * @param clientSubscriptionId client subscription id to deregister.
   */ async removeOnLogsListener(clientSubscriptionId) {
        await this._unsubscribeClientSubscription(clientSubscriptionId, "logs");
    }
    /**
   * @internal
   */ _wsOnLogsNotification(notification) {
        const { result, subscription } = (0, _superstruct.create)(notification, LogsNotificationResult);
        this._handleServerNotification(subscription, [
            result.value,
            result.context
        ]);
    }
    /**
   * @internal
   */ _wsOnSlotNotification(notification) {
        const { result, subscription } = (0, _superstruct.create)(notification, SlotNotificationResult);
        this._handleServerNotification(subscription, [
            result
        ]);
    }
    /**
   * Register a callback to be invoked upon slot changes
   *
   * @param callback Function to invoke whenever the slot changes
   * @return subscription id
   */ onSlotChange(callback) {
        return this._makeSubscription({
            callback,
            method: "slotSubscribe",
            unsubscribeMethod: "slotUnsubscribe"
        }, []);
    }
    /**
   * Deregister a slot notification callback
   *
   * @param clientSubscriptionId client subscription id to deregister
   */ async removeSlotChangeListener(clientSubscriptionId) {
        await this._unsubscribeClientSubscription(clientSubscriptionId, "slot change");
    }
    /**
   * @internal
   */ _wsOnSlotUpdatesNotification(notification) {
        const { result, subscription } = (0, _superstruct.create)(notification, SlotUpdateNotificationResult);
        this._handleServerNotification(subscription, [
            result
        ]);
    }
    /**
   * Register a callback to be invoked upon slot updates. {@link SlotUpdate}'s
   * may be useful to track live progress of a cluster.
   *
   * @param callback Function to invoke whenever the slot updates
   * @return subscription id
   */ onSlotUpdate(callback) {
        return this._makeSubscription({
            callback,
            method: "slotsUpdatesSubscribe",
            unsubscribeMethod: "slotsUpdatesUnsubscribe"
        }, []);
    }
    /**
   * Deregister a slot update notification callback
   *
   * @param clientSubscriptionId client subscription id to deregister
   */ async removeSlotUpdateListener(clientSubscriptionId) {
        await this._unsubscribeClientSubscription(clientSubscriptionId, "slot update");
    }
    /**
   * @internal
   */ async _unsubscribeClientSubscription(clientSubscriptionId, subscriptionName) {
        const dispose = this._subscriptionDisposeFunctionsByClientSubscriptionId[clientSubscriptionId];
        if (dispose) await dispose();
        else console.warn("Ignored unsubscribe request because an active subscription with id " + `\`${clientSubscriptionId}\` for '${subscriptionName}' events ` + "could not be found.");
    }
    _buildArgs(args, override, encoding, extra) {
        const commitment = override || this._commitment;
        if (commitment || encoding || extra) {
            let options = {};
            if (encoding) options.encoding = encoding;
            if (commitment) options.commitment = commitment;
            if (extra) options = Object.assign(options, extra);
            args.push(options);
        }
        return args;
    }
    /**
   * @internal
   */ _buildArgsAtLeastConfirmed(args, override, encoding, extra) {
        const commitment = override || this._commitment;
        if (commitment && ![
            "confirmed",
            "finalized"
        ].includes(commitment)) throw new Error("Using Connection with default commitment: `" + this._commitment + "`, but method requires at least `confirmed`");
        return this._buildArgs(args, override, encoding, extra);
    }
    /**
   * @internal
   */ _wsOnSignatureNotification(notification) {
        const { result, subscription } = (0, _superstruct.create)(notification, SignatureNotificationResult);
        if (result.value !== "receivedSignature") /**
       * Special case.
       * After a signature is processed, RPCs automatically dispose of the
       * subscription on the server side. We need to track which of these
       * subscriptions have been disposed in such a way, so that we know
       * whether the client is dealing with a not-yet-processed signature
       * (in which case we must tear down the server subscription) or an
       * already-processed signature (in which case the client can simply
       * clear out the subscription locally without telling the server).
       *
       * NOTE: There is a proposal to eliminate this special case, here:
       * https://github.com/solana-labs/solana/issues/18892
       */ this._subscriptionsAutoDisposedByRpc.add(subscription);
        this._handleServerNotification(subscription, result.value === "receivedSignature" ? [
            {
                type: "received"
            },
            result.context
        ] : [
            {
                type: "status",
                result: result.value
            },
            result.context
        ]);
    }
    /**
   * Register a callback to be invoked upon signature updates
   *
   * @param signature Transaction signature string in base 58
   * @param callback Function to invoke on signature notifications
   * @param commitment Specify the commitment level signature must reach before notification
   * @return subscription id
   */ onSignature(signature, callback, commitment) {
        const args = this._buildArgs([
            signature
        ], commitment || this._commitment || "finalized" // Apply connection/server default.
        );
        const clientSubscriptionId = this._makeSubscription({
            callback: (notification, context)=>{
                if (notification.type === "status") {
                    callback(notification.result, context);
                    // Signatures subscriptions are auto-removed by the RPC service
                    // so no need to explicitly send an unsubscribe message.
                    try {
                        this.removeSignatureListener(clientSubscriptionId);
                    // eslint-disable-next-line no-empty
                    } catch (_err) {
                    // Already removed.
                    }
                }
            },
            method: "signatureSubscribe",
            unsubscribeMethod: "signatureUnsubscribe"
        }, args);
        return clientSubscriptionId;
    }
    /**
   * Register a callback to be invoked when a transaction is
   * received and/or processed.
   *
   * @param signature Transaction signature string in base 58
   * @param callback Function to invoke on signature notifications
   * @param options Enable received notifications and set the commitment
   *   level that signature must reach before notification
   * @return subscription id
   */ onSignatureWithOptions(signature, callback, options) {
        const { commitment, ...extra } = {
            ...options,
            commitment: options && options.commitment || this._commitment || "finalized" // Apply connection/server default.
        };
        const args = this._buildArgs([
            signature
        ], commitment, undefined /* encoding */ , extra);
        const clientSubscriptionId = this._makeSubscription({
            callback: (notification, context)=>{
                callback(notification, context);
                // Signatures subscriptions are auto-removed by the RPC service
                // so no need to explicitly send an unsubscribe message.
                try {
                    this.removeSignatureListener(clientSubscriptionId);
                // eslint-disable-next-line no-empty
                } catch (_err) {
                // Already removed.
                }
            },
            method: "signatureSubscribe",
            unsubscribeMethod: "signatureUnsubscribe"
        }, args);
        return clientSubscriptionId;
    }
    /**
   * Deregister a signature notification callback
   *
   * @param clientSubscriptionId client subscription id to deregister
   */ async removeSignatureListener(clientSubscriptionId) {
        await this._unsubscribeClientSubscription(clientSubscriptionId, "signature result");
    }
    /**
   * @internal
   */ _wsOnRootNotification(notification) {
        const { result, subscription } = (0, _superstruct.create)(notification, RootNotificationResult);
        this._handleServerNotification(subscription, [
            result
        ]);
    }
    /**
   * Register a callback to be invoked upon root changes
   *
   * @param callback Function to invoke whenever the root changes
   * @return subscription id
   */ onRootChange(callback) {
        return this._makeSubscription({
            callback,
            method: "rootSubscribe",
            unsubscribeMethod: "rootUnsubscribe"
        }, []);
    }
    /**
   * Deregister a root notification callback
   *
   * @param clientSubscriptionId client subscription id to deregister
   */ async removeRootChangeListener(clientSubscriptionId) {
        await this._unsubscribeClientSubscription(clientSubscriptionId, "root change");
    }
}
/**
 * Keypair signer interface
 */ /**
 * An account keypair used for signing transactions.
 */ class Keypair {
    /**
   * Create a new keypair instance.
   * Generate random keypair if no {@link Ed25519Keypair} is provided.
   *
   * @param {Ed25519Keypair} keypair ed25519 keypair
   */ constructor(keypair){
        this._keypair = void 0;
        this._keypair = keypair ?? generateKeypair();
    }
    /**
   * Generate a new random keypair
   *
   * @returns {Keypair} Keypair
   */ static generate() {
        return new Keypair(generateKeypair());
    }
    /**
   * Create a keypair from a raw secret key byte array.
   *
   * This method should only be used to recreate a keypair from a previously
   * generated secret key. Generating keypairs from a random seed should be done
   * with the {@link Keypair.fromSeed} method.
   *
   * @throws error if the provided secret key is invalid and validation is not skipped.
   *
   * @param secretKey secret key byte array
   * @param options skip secret key validation
   *
   * @returns {Keypair} Keypair
   */ static fromSecretKey(secretKey, options) {
        if (secretKey.byteLength !== 64) throw new Error("bad secret key size");
        const publicKey = secretKey.slice(32, 64);
        if (!options || !options.skipValidation) {
            const privateScalar = secretKey.slice(0, 32);
            const computedPublicKey = getPublicKey(privateScalar);
            for(let ii = 0; ii < 32; ii++){
                if (publicKey[ii] !== computedPublicKey[ii]) throw new Error("provided secretKey is invalid");
            }
        }
        return new Keypair({
            publicKey,
            secretKey
        });
    }
    /**
   * Generate a keypair from a 32 byte seed.
   *
   * @param seed seed byte array
   *
   * @returns {Keypair} Keypair
   */ static fromSeed(seed) {
        const publicKey = getPublicKey(seed);
        const secretKey = new Uint8Array(64);
        secretKey.set(seed);
        secretKey.set(publicKey, 32);
        return new Keypair({
            publicKey,
            secretKey
        });
    }
    /**
   * The public key for this keypair
   *
   * @returns {PublicKey} PublicKey
   */ get publicKey() {
        return new PublicKey(this._keypair.publicKey);
    }
    /**
   * The raw secret key for this keypair
   * @returns {Uint8Array} Secret key in an array of Uint8 bytes
   */ get secretKey() {
        return new Uint8Array(this._keypair.secretKey);
    }
}
/**
 * An enumeration of valid LookupTableInstructionType's
 */ /**
 * An enumeration of valid address lookup table InstructionType's
 * @internal
 */ const LOOKUP_TABLE_INSTRUCTION_LAYOUTS = Object.freeze({
    CreateLookupTable: {
        index: 0,
        layout: _bufferLayout.struct([
            _bufferLayout.u32("instruction"),
            u64("recentSlot"),
            _bufferLayout.u8("bumpSeed")
        ])
    },
    FreezeLookupTable: {
        index: 1,
        layout: _bufferLayout.struct([
            _bufferLayout.u32("instruction")
        ])
    },
    ExtendLookupTable: {
        index: 2,
        layout: _bufferLayout.struct([
            _bufferLayout.u32("instruction"),
            u64(),
            _bufferLayout.seq(publicKey(), _bufferLayout.offset(_bufferLayout.u32(), -8), "addresses")
        ])
    },
    DeactivateLookupTable: {
        index: 3,
        layout: _bufferLayout.struct([
            _bufferLayout.u32("instruction")
        ])
    },
    CloseLookupTable: {
        index: 4,
        layout: _bufferLayout.struct([
            _bufferLayout.u32("instruction")
        ])
    }
});
class AddressLookupTableInstruction {
    /**
   * @internal
   */ constructor(){}
    static decodeInstructionType(instruction) {
        this.checkProgramId(instruction.programId);
        const instructionTypeLayout = _bufferLayout.u32("instruction");
        const index = instructionTypeLayout.decode(instruction.data);
        let type;
        for (const [layoutType, layout] of Object.entries(LOOKUP_TABLE_INSTRUCTION_LAYOUTS))if (layout.index == index) {
            type = layoutType;
            break;
        }
        if (!type) throw new Error("Invalid Instruction. Should be a LookupTable Instruction");
        return type;
    }
    static decodeCreateLookupTable(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeysLength(instruction.keys, 4);
        const { recentSlot } = decodeData$1(LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CreateLookupTable, instruction.data);
        return {
            authority: instruction.keys[1].pubkey,
            payer: instruction.keys[2].pubkey,
            recentSlot: Number(recentSlot)
        };
    }
    static decodeExtendLookupTable(instruction) {
        this.checkProgramId(instruction.programId);
        if (instruction.keys.length < 2) throw new Error(`invalid instruction; found ${instruction.keys.length} keys, expected at least 2`);
        const { addresses } = decodeData$1(LOOKUP_TABLE_INSTRUCTION_LAYOUTS.ExtendLookupTable, instruction.data);
        return {
            lookupTable: instruction.keys[0].pubkey,
            authority: instruction.keys[1].pubkey,
            payer: instruction.keys.length > 2 ? instruction.keys[2].pubkey : undefined,
            addresses: addresses.map((buffer)=>new PublicKey(buffer))
        };
    }
    static decodeCloseLookupTable(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeysLength(instruction.keys, 3);
        return {
            lookupTable: instruction.keys[0].pubkey,
            authority: instruction.keys[1].pubkey,
            recipient: instruction.keys[2].pubkey
        };
    }
    static decodeFreezeLookupTable(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeysLength(instruction.keys, 2);
        return {
            lookupTable: instruction.keys[0].pubkey,
            authority: instruction.keys[1].pubkey
        };
    }
    static decodeDeactivateLookupTable(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeysLength(instruction.keys, 2);
        return {
            lookupTable: instruction.keys[0].pubkey,
            authority: instruction.keys[1].pubkey
        };
    }
    /**
   * @internal
   */ static checkProgramId(programId) {
        if (!programId.equals(AddressLookupTableProgram.programId)) throw new Error("invalid instruction; programId is not AddressLookupTable Program");
    }
    /**
   * @internal
   */ static checkKeysLength(keys, expectedLength) {
        if (keys.length < expectedLength) throw new Error(`invalid instruction; found ${keys.length} keys, expected at least ${expectedLength}`);
    }
}
class AddressLookupTableProgram {
    /**
   * @internal
   */ constructor(){}
    static createLookupTable(params) {
        const [lookupTableAddress, bumpSeed] = PublicKey.findProgramAddressSync([
            params.authority.toBuffer(),
            (0, _bigintBuffer.toBufferLE)(BigInt(params.recentSlot), 8)
        ], this.programId);
        const type = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CreateLookupTable;
        const data = encodeData(type, {
            recentSlot: BigInt(params.recentSlot),
            bumpSeed: bumpSeed
        });
        const keys = [
            {
                pubkey: lookupTableAddress,
                isSigner: false,
                isWritable: true
            },
            {
                pubkey: params.authority,
                isSigner: true,
                isWritable: false
            },
            {
                pubkey: params.payer,
                isSigner: true,
                isWritable: true
            },
            {
                pubkey: SystemProgram.programId,
                isSigner: false,
                isWritable: false
            }
        ];
        return [
            new TransactionInstruction({
                programId: this.programId,
                keys: keys,
                data: data
            }),
            lookupTableAddress
        ];
    }
    static freezeLookupTable(params) {
        const type = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.FreezeLookupTable;
        const data = encodeData(type);
        const keys = [
            {
                pubkey: params.lookupTable,
                isSigner: false,
                isWritable: true
            },
            {
                pubkey: params.authority,
                isSigner: true,
                isWritable: false
            }
        ];
        return new TransactionInstruction({
            programId: this.programId,
            keys: keys,
            data: data
        });
    }
    static extendLookupTable(params) {
        const type = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.ExtendLookupTable;
        const data = encodeData(type, {
            addresses: params.addresses.map((addr)=>addr.toBytes())
        });
        const keys = [
            {
                pubkey: params.lookupTable,
                isSigner: false,
                isWritable: true
            },
            {
                pubkey: params.authority,
                isSigner: true,
                isWritable: false
            }
        ];
        if (params.payer) keys.push({
            pubkey: params.payer,
            isSigner: true,
            isWritable: true
        }, {
            pubkey: SystemProgram.programId,
            isSigner: false,
            isWritable: false
        });
        return new TransactionInstruction({
            programId: this.programId,
            keys: keys,
            data: data
        });
    }
    static deactivateLookupTable(params) {
        const type = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.DeactivateLookupTable;
        const data = encodeData(type);
        const keys = [
            {
                pubkey: params.lookupTable,
                isSigner: false,
                isWritable: true
            },
            {
                pubkey: params.authority,
                isSigner: true,
                isWritable: false
            }
        ];
        return new TransactionInstruction({
            programId: this.programId,
            keys: keys,
            data: data
        });
    }
    static closeLookupTable(params) {
        const type = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CloseLookupTable;
        const data = encodeData(type);
        const keys = [
            {
                pubkey: params.lookupTable,
                isSigner: false,
                isWritable: true
            },
            {
                pubkey: params.authority,
                isSigner: true,
                isWritable: false
            },
            {
                pubkey: params.recipient,
                isSigner: false,
                isWritable: true
            }
        ];
        return new TransactionInstruction({
            programId: this.programId,
            keys: keys,
            data: data
        });
    }
}
AddressLookupTableProgram.programId = new PublicKey("AddressLookupTab1e1111111111111111111111111");
/**
 * Compute Budget Instruction class
 */ class ComputeBudgetInstruction {
    /**
   * @internal
   */ constructor(){}
    /**
   * Decode a compute budget instruction and retrieve the instruction type.
   */ static decodeInstructionType(instruction) {
        this.checkProgramId(instruction.programId);
        const instructionTypeLayout = _bufferLayout.u8("instruction");
        const typeIndex = instructionTypeLayout.decode(instruction.data);
        let type;
        for (const [ixType, layout] of Object.entries(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS))if (layout.index == typeIndex) {
            type = ixType;
            break;
        }
        if (!type) throw new Error("Instruction type incorrect; not a ComputeBudgetInstruction");
        return type;
    }
    /**
   * Decode request units compute budget instruction and retrieve the instruction params.
   */ static decodeRequestUnits(instruction) {
        this.checkProgramId(instruction.programId);
        const { units, additionalFee } = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestUnits, instruction.data);
        return {
            units,
            additionalFee
        };
    }
    /**
   * Decode request heap frame compute budget instruction and retrieve the instruction params.
   */ static decodeRequestHeapFrame(instruction) {
        this.checkProgramId(instruction.programId);
        const { bytes } = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestHeapFrame, instruction.data);
        return {
            bytes
        };
    }
    /**
   * Decode set compute unit limit compute budget instruction and retrieve the instruction params.
   */ static decodeSetComputeUnitLimit(instruction) {
        this.checkProgramId(instruction.programId);
        const { units } = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitLimit, instruction.data);
        return {
            units
        };
    }
    /**
   * Decode set compute unit price compute budget instruction and retrieve the instruction params.
   */ static decodeSetComputeUnitPrice(instruction) {
        this.checkProgramId(instruction.programId);
        const { microLamports } = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitPrice, instruction.data);
        return {
            microLamports
        };
    }
    /**
   * @internal
   */ static checkProgramId(programId) {
        if (!programId.equals(ComputeBudgetProgram.programId)) throw new Error("invalid instruction; programId is not ComputeBudgetProgram");
    }
}
/**
 * An enumeration of valid ComputeBudgetInstructionType's
 */ /**
 * Request units instruction params
 */ /**
 * Request heap frame instruction params
 */ /**
 * Set compute unit limit instruction params
 */ /**
 * Set compute unit price instruction params
 */ /**
 * An enumeration of valid ComputeBudget InstructionType's
 * @internal
 */ const COMPUTE_BUDGET_INSTRUCTION_LAYOUTS = Object.freeze({
    RequestUnits: {
        index: 0,
        layout: _bufferLayout.struct([
            _bufferLayout.u8("instruction"),
            _bufferLayout.u32("units"),
            _bufferLayout.u32("additionalFee")
        ])
    },
    RequestHeapFrame: {
        index: 1,
        layout: _bufferLayout.struct([
            _bufferLayout.u8("instruction"),
            _bufferLayout.u32("bytes")
        ])
    },
    SetComputeUnitLimit: {
        index: 2,
        layout: _bufferLayout.struct([
            _bufferLayout.u8("instruction"),
            _bufferLayout.u32("units")
        ])
    },
    SetComputeUnitPrice: {
        index: 3,
        layout: _bufferLayout.struct([
            _bufferLayout.u8("instruction"),
            u64("microLamports")
        ])
    }
});
/**
 * Factory class for transaction instructions to interact with the Compute Budget program
 */ class ComputeBudgetProgram {
    /**
   * @internal
   */ constructor(){}
    /**
   * Public key that identifies the Compute Budget program
   */ /**
   * @deprecated Instead, call {@link setComputeUnitLimit} and/or {@link setComputeUnitPrice}
   */ static requestUnits(params) {
        const type = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestUnits;
        const data = encodeData(type, params);
        return new TransactionInstruction({
            keys: [],
            programId: this.programId,
            data
        });
    }
    static requestHeapFrame(params) {
        const type = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestHeapFrame;
        const data = encodeData(type, params);
        return new TransactionInstruction({
            keys: [],
            programId: this.programId,
            data
        });
    }
    static setComputeUnitLimit(params) {
        const type = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitLimit;
        const data = encodeData(type, params);
        return new TransactionInstruction({
            keys: [],
            programId: this.programId,
            data
        });
    }
    static setComputeUnitPrice(params) {
        const type = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitPrice;
        const data = encodeData(type, {
            microLamports: BigInt(params.microLamports)
        });
        return new TransactionInstruction({
            keys: [],
            programId: this.programId,
            data
        });
    }
}
ComputeBudgetProgram.programId = new PublicKey("ComputeBudget111111111111111111111111111111");
const PRIVATE_KEY_BYTES$1 = 64;
const PUBLIC_KEY_BYTES$1 = 32;
const SIGNATURE_BYTES = 64;
/**
 * Params for creating an ed25519 instruction using a public key
 */ /**
 * Params for creating an ed25519 instruction using a private key
 */ const ED25519_INSTRUCTION_LAYOUT = _bufferLayout.struct([
    _bufferLayout.u8("numSignatures"),
    _bufferLayout.u8("padding"),
    _bufferLayout.u16("signatureOffset"),
    _bufferLayout.u16("signatureInstructionIndex"),
    _bufferLayout.u16("publicKeyOffset"),
    _bufferLayout.u16("publicKeyInstructionIndex"),
    _bufferLayout.u16("messageDataOffset"),
    _bufferLayout.u16("messageDataSize"),
    _bufferLayout.u16("messageInstructionIndex")
]);
class Ed25519Program {
    /**
   * @internal
   */ constructor(){}
    /**
   * Public key that identifies the ed25519 program
   */ /**
   * Create an ed25519 instruction with a public key and signature. The
   * public key must be a buffer that is 32 bytes long, and the signature
   * must be a buffer of 64 bytes.
   */ static createInstructionWithPublicKey(params) {
        const { publicKey, message, signature, instructionIndex } = params;
        assert(publicKey.length === PUBLIC_KEY_BYTES$1, `Public Key must be ${PUBLIC_KEY_BYTES$1} bytes but received ${publicKey.length} bytes`);
        assert(signature.length === SIGNATURE_BYTES, `Signature must be ${SIGNATURE_BYTES} bytes but received ${signature.length} bytes`);
        const publicKeyOffset = ED25519_INSTRUCTION_LAYOUT.span;
        const signatureOffset = publicKeyOffset + publicKey.length;
        const messageDataOffset = signatureOffset + signature.length;
        const numSignatures = 1;
        const instructionData = (0, _buffer.Buffer).alloc(messageDataOffset + message.length);
        const index = instructionIndex == null ? 0xffff // An index of `u16::MAX` makes it default to the current instruction.
         : instructionIndex;
        ED25519_INSTRUCTION_LAYOUT.encode({
            numSignatures,
            padding: 0,
            signatureOffset,
            signatureInstructionIndex: index,
            publicKeyOffset,
            publicKeyInstructionIndex: index,
            messageDataOffset,
            messageDataSize: message.length,
            messageInstructionIndex: index
        }, instructionData);
        instructionData.fill(publicKey, publicKeyOffset);
        instructionData.fill(signature, signatureOffset);
        instructionData.fill(message, messageDataOffset);
        return new TransactionInstruction({
            keys: [],
            programId: Ed25519Program.programId,
            data: instructionData
        });
    }
    /**
   * Create an ed25519 instruction with a private key. The private key
   * must be a buffer that is 64 bytes long.
   */ static createInstructionWithPrivateKey(params) {
        const { privateKey, message, instructionIndex } = params;
        assert(privateKey.length === PRIVATE_KEY_BYTES$1, `Private key must be ${PRIVATE_KEY_BYTES$1} bytes but received ${privateKey.length} bytes`);
        try {
            const keypair = Keypair.fromSecretKey(privateKey);
            const publicKey = keypair.publicKey.toBytes();
            const signature = sign(message, keypair.secretKey);
            return this.createInstructionWithPublicKey({
                publicKey,
                message,
                signature,
                instructionIndex
            });
        } catch (error) {
            throw new Error(`Error creating instruction; ${error}`);
        }
    }
}
Ed25519Program.programId = new PublicKey("Ed25519SigVerify111111111111111111111111111");
const ecdsaSign = (msgHash, privKey)=>{
    const signature = (0, _secp256K1.secp256k1).sign(msgHash, privKey);
    return [
        signature.toCompactRawBytes(),
        signature.recovery
    ];
};
(0, _secp256K1.secp256k1).utils.isValidPrivateKey;
const publicKeyCreate = (0, _secp256K1.secp256k1).getPublicKey;
const PRIVATE_KEY_BYTES = 32;
const ETHEREUM_ADDRESS_BYTES = 20;
const PUBLIC_KEY_BYTES = 64;
const SIGNATURE_OFFSETS_SERIALIZED_SIZE = 11;
/**
 * Params for creating an secp256k1 instruction using a public key
 */ /**
 * Params for creating an secp256k1 instruction using an Ethereum address
 */ /**
 * Params for creating an secp256k1 instruction using a private key
 */ const SECP256K1_INSTRUCTION_LAYOUT = _bufferLayout.struct([
    _bufferLayout.u8("numSignatures"),
    _bufferLayout.u16("signatureOffset"),
    _bufferLayout.u8("signatureInstructionIndex"),
    _bufferLayout.u16("ethAddressOffset"),
    _bufferLayout.u8("ethAddressInstructionIndex"),
    _bufferLayout.u16("messageDataOffset"),
    _bufferLayout.u16("messageDataSize"),
    _bufferLayout.u8("messageInstructionIndex"),
    _bufferLayout.blob(20, "ethAddress"),
    _bufferLayout.blob(64, "signature"),
    _bufferLayout.u8("recoveryId")
]);
class Secp256k1Program {
    /**
   * @internal
   */ constructor(){}
    /**
   * Public key that identifies the secp256k1 program
   */ /**
   * Construct an Ethereum address from a secp256k1 public key buffer.
   * @param {Buffer} publicKey a 64 byte secp256k1 public key buffer
   */ static publicKeyToEthAddress(publicKey) {
        assert(publicKey.length === PUBLIC_KEY_BYTES, `Public key must be ${PUBLIC_KEY_BYTES} bytes but received ${publicKey.length} bytes`);
        try {
            return (0, _buffer.Buffer).from((0, _sha3.keccak_256)(toBuffer(publicKey))).slice(-ETHEREUM_ADDRESS_BYTES);
        } catch (error) {
            throw new Error(`Error constructing Ethereum address: ${error}`);
        }
    }
    /**
   * Create an secp256k1 instruction with a public key. The public key
   * must be a buffer that is 64 bytes long.
   */ static createInstructionWithPublicKey(params) {
        const { publicKey, message, signature, recoveryId, instructionIndex } = params;
        return Secp256k1Program.createInstructionWithEthAddress({
            ethAddress: Secp256k1Program.publicKeyToEthAddress(publicKey),
            message,
            signature,
            recoveryId,
            instructionIndex
        });
    }
    /**
   * Create an secp256k1 instruction with an Ethereum address. The address
   * must be a hex string or a buffer that is 20 bytes long.
   */ static createInstructionWithEthAddress(params) {
        const { ethAddress: rawAddress, message, signature, recoveryId, instructionIndex = 0 } = params;
        let ethAddress;
        if (typeof rawAddress === "string") {
            if (rawAddress.startsWith("0x")) ethAddress = (0, _buffer.Buffer).from(rawAddress.substr(2), "hex");
            else ethAddress = (0, _buffer.Buffer).from(rawAddress, "hex");
        } else ethAddress = rawAddress;
        assert(ethAddress.length === ETHEREUM_ADDRESS_BYTES, `Address must be ${ETHEREUM_ADDRESS_BYTES} bytes but received ${ethAddress.length} bytes`);
        const dataStart = 1 + SIGNATURE_OFFSETS_SERIALIZED_SIZE;
        const ethAddressOffset = dataStart;
        const signatureOffset = dataStart + ethAddress.length;
        const messageDataOffset = signatureOffset + signature.length + 1;
        const numSignatures = 1;
        const instructionData = (0, _buffer.Buffer).alloc(SECP256K1_INSTRUCTION_LAYOUT.span + message.length);
        SECP256K1_INSTRUCTION_LAYOUT.encode({
            numSignatures,
            signatureOffset,
            signatureInstructionIndex: instructionIndex,
            ethAddressOffset,
            ethAddressInstructionIndex: instructionIndex,
            messageDataOffset,
            messageDataSize: message.length,
            messageInstructionIndex: instructionIndex,
            signature: toBuffer(signature),
            ethAddress: toBuffer(ethAddress),
            recoveryId
        }, instructionData);
        instructionData.fill(toBuffer(message), SECP256K1_INSTRUCTION_LAYOUT.span);
        return new TransactionInstruction({
            keys: [],
            programId: Secp256k1Program.programId,
            data: instructionData
        });
    }
    /**
   * Create an secp256k1 instruction with a private key. The private key
   * must be a buffer that is 32 bytes long.
   */ static createInstructionWithPrivateKey(params) {
        const { privateKey: pkey, message, instructionIndex } = params;
        assert(pkey.length === PRIVATE_KEY_BYTES, `Private key must be ${PRIVATE_KEY_BYTES} bytes but received ${pkey.length} bytes`);
        try {
            const privateKey = toBuffer(pkey);
            const publicKey = publicKeyCreate(privateKey, false).slice(1); // throw away leading byte
            const messageHash = (0, _buffer.Buffer).from((0, _sha3.keccak_256)(toBuffer(message)));
            const [signature, recoveryId] = ecdsaSign(messageHash, privateKey);
            return this.createInstructionWithPublicKey({
                publicKey,
                message,
                signature,
                recoveryId,
                instructionIndex
            });
        } catch (error) {
            throw new Error(`Error creating instruction; ${error}`);
        }
    }
}
Secp256k1Program.programId = new PublicKey("KeccakSecp256k11111111111111111111111111111");
var _Lockup;
/**
 * Address of the stake config account which configures the rate
 * of stake warmup and cooldown as well as the slashing penalty.
 */ const STAKE_CONFIG_ID = new PublicKey("StakeConfig11111111111111111111111111111111");
/**
 * Stake account authority info
 */ class Authorized {
    /**
   * Create a new Authorized object
   * @param staker the stake authority
   * @param withdrawer the withdraw authority
   */ constructor(staker, withdrawer){
        /** stake authority */ this.staker = void 0;
        /** withdraw authority */ this.withdrawer = void 0;
        this.staker = staker;
        this.withdrawer = withdrawer;
    }
}
/**
 * Stake account lockup info
 */ class Lockup {
    /**
   * Create a new Lockup object
   */ constructor(unixTimestamp, epoch, custodian){
        /** Unix timestamp of lockup expiration */ this.unixTimestamp = void 0;
        /** Epoch of lockup expiration */ this.epoch = void 0;
        /** Lockup custodian authority */ this.custodian = void 0;
        this.unixTimestamp = unixTimestamp;
        this.epoch = epoch;
        this.custodian = custodian;
    }
}
_Lockup = Lockup;
Lockup.default = new _Lockup(0, 0, PublicKey.default);
/**
 * Create stake account transaction params
 */ /**
 * Create stake account with seed transaction params
 */ /**
 * Initialize stake instruction params
 */ /**
 * Delegate stake instruction params
 */ /**
 * Authorize stake instruction params
 */ /**
 * Authorize stake instruction params using a derived key
 */ /**
 * Split stake instruction params
 */ /**
 * Split with seed transaction params
 */ /**
 * Withdraw stake instruction params
 */ /**
 * Deactivate stake instruction params
 */ /**
 * Merge stake instruction params
 */ /**
 * Stake Instruction class
 */ class StakeInstruction {
    /**
   * @internal
   */ constructor(){}
    /**
   * Decode a stake instruction and retrieve the instruction type.
   */ static decodeInstructionType(instruction) {
        this.checkProgramId(instruction.programId);
        const instructionTypeLayout = _bufferLayout.u32("instruction");
        const typeIndex = instructionTypeLayout.decode(instruction.data);
        let type;
        for (const [ixType, layout] of Object.entries(STAKE_INSTRUCTION_LAYOUTS))if (layout.index == typeIndex) {
            type = ixType;
            break;
        }
        if (!type) throw new Error("Instruction type incorrect; not a StakeInstruction");
        return type;
    }
    /**
   * Decode a initialize stake instruction and retrieve the instruction params.
   */ static decodeInitialize(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeyLength(instruction.keys, 2);
        const { authorized, lockup } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Initialize, instruction.data);
        return {
            stakePubkey: instruction.keys[0].pubkey,
            authorized: new Authorized(new PublicKey(authorized.staker), new PublicKey(authorized.withdrawer)),
            lockup: new Lockup(lockup.unixTimestamp, lockup.epoch, new PublicKey(lockup.custodian))
        };
    }
    /**
   * Decode a delegate stake instruction and retrieve the instruction params.
   */ static decodeDelegate(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeyLength(instruction.keys, 6);
        decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Delegate, instruction.data);
        return {
            stakePubkey: instruction.keys[0].pubkey,
            votePubkey: instruction.keys[1].pubkey,
            authorizedPubkey: instruction.keys[5].pubkey
        };
    }
    /**
   * Decode an authorize stake instruction and retrieve the instruction params.
   */ static decodeAuthorize(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeyLength(instruction.keys, 3);
        const { newAuthorized, stakeAuthorizationType } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Authorize, instruction.data);
        const o = {
            stakePubkey: instruction.keys[0].pubkey,
            authorizedPubkey: instruction.keys[2].pubkey,
            newAuthorizedPubkey: new PublicKey(newAuthorized),
            stakeAuthorizationType: {
                index: stakeAuthorizationType
            }
        };
        if (instruction.keys.length > 3) o.custodianPubkey = instruction.keys[3].pubkey;
        return o;
    }
    /**
   * Decode an authorize-with-seed stake instruction and retrieve the instruction params.
   */ static decodeAuthorizeWithSeed(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeyLength(instruction.keys, 2);
        const { newAuthorized, stakeAuthorizationType, authoritySeed, authorityOwner } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed, instruction.data);
        const o = {
            stakePubkey: instruction.keys[0].pubkey,
            authorityBase: instruction.keys[1].pubkey,
            authoritySeed: authoritySeed,
            authorityOwner: new PublicKey(authorityOwner),
            newAuthorizedPubkey: new PublicKey(newAuthorized),
            stakeAuthorizationType: {
                index: stakeAuthorizationType
            }
        };
        if (instruction.keys.length > 3) o.custodianPubkey = instruction.keys[3].pubkey;
        return o;
    }
    /**
   * Decode a split stake instruction and retrieve the instruction params.
   */ static decodeSplit(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeyLength(instruction.keys, 3);
        const { lamports } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Split, instruction.data);
        return {
            stakePubkey: instruction.keys[0].pubkey,
            splitStakePubkey: instruction.keys[1].pubkey,
            authorizedPubkey: instruction.keys[2].pubkey,
            lamports
        };
    }
    /**
   * Decode a merge stake instruction and retrieve the instruction params.
   */ static decodeMerge(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeyLength(instruction.keys, 3);
        decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Merge, instruction.data);
        return {
            stakePubkey: instruction.keys[0].pubkey,
            sourceStakePubKey: instruction.keys[1].pubkey,
            authorizedPubkey: instruction.keys[4].pubkey
        };
    }
    /**
   * Decode a withdraw stake instruction and retrieve the instruction params.
   */ static decodeWithdraw(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeyLength(instruction.keys, 5);
        const { lamports } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Withdraw, instruction.data);
        const o = {
            stakePubkey: instruction.keys[0].pubkey,
            toPubkey: instruction.keys[1].pubkey,
            authorizedPubkey: instruction.keys[4].pubkey,
            lamports
        };
        if (instruction.keys.length > 5) o.custodianPubkey = instruction.keys[5].pubkey;
        return o;
    }
    /**
   * Decode a deactivate stake instruction and retrieve the instruction params.
   */ static decodeDeactivate(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeyLength(instruction.keys, 3);
        decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Deactivate, instruction.data);
        return {
            stakePubkey: instruction.keys[0].pubkey,
            authorizedPubkey: instruction.keys[2].pubkey
        };
    }
    /**
   * @internal
   */ static checkProgramId(programId) {
        if (!programId.equals(StakeProgram.programId)) throw new Error("invalid instruction; programId is not StakeProgram");
    }
    /**
   * @internal
   */ static checkKeyLength(keys, expectedLength) {
        if (keys.length < expectedLength) throw new Error(`invalid instruction; found ${keys.length} keys, expected at least ${expectedLength}`);
    }
}
/**
 * An enumeration of valid StakeInstructionType's
 */ /**
 * An enumeration of valid stake InstructionType's
 * @internal
 */ const STAKE_INSTRUCTION_LAYOUTS = Object.freeze({
    Initialize: {
        index: 0,
        layout: _bufferLayout.struct([
            _bufferLayout.u32("instruction"),
            authorized(),
            lockup()
        ])
    },
    Authorize: {
        index: 1,
        layout: _bufferLayout.struct([
            _bufferLayout.u32("instruction"),
            publicKey("newAuthorized"),
            _bufferLayout.u32("stakeAuthorizationType")
        ])
    },
    Delegate: {
        index: 2,
        layout: _bufferLayout.struct([
            _bufferLayout.u32("instruction")
        ])
    },
    Split: {
        index: 3,
        layout: _bufferLayout.struct([
            _bufferLayout.u32("instruction"),
            _bufferLayout.ns64("lamports")
        ])
    },
    Withdraw: {
        index: 4,
        layout: _bufferLayout.struct([
            _bufferLayout.u32("instruction"),
            _bufferLayout.ns64("lamports")
        ])
    },
    Deactivate: {
        index: 5,
        layout: _bufferLayout.struct([
            _bufferLayout.u32("instruction")
        ])
    },
    Merge: {
        index: 7,
        layout: _bufferLayout.struct([
            _bufferLayout.u32("instruction")
        ])
    },
    AuthorizeWithSeed: {
        index: 8,
        layout: _bufferLayout.struct([
            _bufferLayout.u32("instruction"),
            publicKey("newAuthorized"),
            _bufferLayout.u32("stakeAuthorizationType"),
            rustString("authoritySeed"),
            publicKey("authorityOwner")
        ])
    }
});
/**
 * Stake authorization type
 */ /**
 * An enumeration of valid StakeAuthorizationLayout's
 */ const StakeAuthorizationLayout = Object.freeze({
    Staker: {
        index: 0
    },
    Withdrawer: {
        index: 1
    }
});
/**
 * Factory class for transactions to interact with the Stake program
 */ class StakeProgram {
    /**
   * @internal
   */ constructor(){}
    /**
   * Public key that identifies the Stake program
   */ /**
   * Generate an Initialize instruction to add to a Stake Create transaction
   */ static initialize(params) {
        const { stakePubkey, authorized, lockup: maybeLockup } = params;
        const lockup = maybeLockup || Lockup.default;
        const type = STAKE_INSTRUCTION_LAYOUTS.Initialize;
        const data = encodeData(type, {
            authorized: {
                staker: toBuffer(authorized.staker.toBuffer()),
                withdrawer: toBuffer(authorized.withdrawer.toBuffer())
            },
            lockup: {
                unixTimestamp: lockup.unixTimestamp,
                epoch: lockup.epoch,
                custodian: toBuffer(lockup.custodian.toBuffer())
            }
        });
        const instructionData = {
            keys: [
                {
                    pubkey: stakePubkey,
                    isSigner: false,
                    isWritable: true
                },
                {
                    pubkey: SYSVAR_RENT_PUBKEY,
                    isSigner: false,
                    isWritable: false
                }
            ],
            programId: this.programId,
            data
        };
        return new TransactionInstruction(instructionData);
    }
    /**
   * Generate a Transaction that creates a new Stake account at
   *   an address generated with `from`, a seed, and the Stake programId
   */ static createAccountWithSeed(params) {
        const transaction = new Transaction();
        transaction.add(SystemProgram.createAccountWithSeed({
            fromPubkey: params.fromPubkey,
            newAccountPubkey: params.stakePubkey,
            basePubkey: params.basePubkey,
            seed: params.seed,
            lamports: params.lamports,
            space: this.space,
            programId: this.programId
        }));
        const { stakePubkey, authorized, lockup } = params;
        return transaction.add(this.initialize({
            stakePubkey,
            authorized,
            lockup
        }));
    }
    /**
   * Generate a Transaction that creates a new Stake account
   */ static createAccount(params) {
        const transaction = new Transaction();
        transaction.add(SystemProgram.createAccount({
            fromPubkey: params.fromPubkey,
            newAccountPubkey: params.stakePubkey,
            lamports: params.lamports,
            space: this.space,
            programId: this.programId
        }));
        const { stakePubkey, authorized, lockup } = params;
        return transaction.add(this.initialize({
            stakePubkey,
            authorized,
            lockup
        }));
    }
    /**
   * Generate a Transaction that delegates Stake tokens to a validator
   * Vote PublicKey. This transaction can also be used to redelegate Stake
   * to a new validator Vote PublicKey.
   */ static delegate(params) {
        const { stakePubkey, authorizedPubkey, votePubkey } = params;
        const type = STAKE_INSTRUCTION_LAYOUTS.Delegate;
        const data = encodeData(type);
        return new Transaction().add({
            keys: [
                {
                    pubkey: stakePubkey,
                    isSigner: false,
                    isWritable: true
                },
                {
                    pubkey: votePubkey,
                    isSigner: false,
                    isWritable: false
                },
                {
                    pubkey: SYSVAR_CLOCK_PUBKEY,
                    isSigner: false,
                    isWritable: false
                },
                {
                    pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,
                    isSigner: false,
                    isWritable: false
                },
                {
                    pubkey: STAKE_CONFIG_ID,
                    isSigner: false,
                    isWritable: false
                },
                {
                    pubkey: authorizedPubkey,
                    isSigner: true,
                    isWritable: false
                }
            ],
            programId: this.programId,
            data
        });
    }
    /**
   * Generate a Transaction that authorizes a new PublicKey as Staker
   * or Withdrawer on the Stake account.
   */ static authorize(params) {
        const { stakePubkey, authorizedPubkey, newAuthorizedPubkey, stakeAuthorizationType, custodianPubkey } = params;
        const type = STAKE_INSTRUCTION_LAYOUTS.Authorize;
        const data = encodeData(type, {
            newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),
            stakeAuthorizationType: stakeAuthorizationType.index
        });
        const keys = [
            {
                pubkey: stakePubkey,
                isSigner: false,
                isWritable: true
            },
            {
                pubkey: SYSVAR_CLOCK_PUBKEY,
                isSigner: false,
                isWritable: true
            },
            {
                pubkey: authorizedPubkey,
                isSigner: true,
                isWritable: false
            }
        ];
        if (custodianPubkey) keys.push({
            pubkey: custodianPubkey,
            isSigner: true,
            isWritable: false
        });
        return new Transaction().add({
            keys,
            programId: this.programId,
            data
        });
    }
    /**
   * Generate a Transaction that authorizes a new PublicKey as Staker
   * or Withdrawer on the Stake account.
   */ static authorizeWithSeed(params) {
        const { stakePubkey, authorityBase, authoritySeed, authorityOwner, newAuthorizedPubkey, stakeAuthorizationType, custodianPubkey } = params;
        const type = STAKE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed;
        const data = encodeData(type, {
            newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),
            stakeAuthorizationType: stakeAuthorizationType.index,
            authoritySeed: authoritySeed,
            authorityOwner: toBuffer(authorityOwner.toBuffer())
        });
        const keys = [
            {
                pubkey: stakePubkey,
                isSigner: false,
                isWritable: true
            },
            {
                pubkey: authorityBase,
                isSigner: true,
                isWritable: false
            },
            {
                pubkey: SYSVAR_CLOCK_PUBKEY,
                isSigner: false,
                isWritable: false
            }
        ];
        if (custodianPubkey) keys.push({
            pubkey: custodianPubkey,
            isSigner: true,
            isWritable: false
        });
        return new Transaction().add({
            keys,
            programId: this.programId,
            data
        });
    }
    /**
   * @internal
   */ static splitInstruction(params) {
        const { stakePubkey, authorizedPubkey, splitStakePubkey, lamports } = params;
        const type = STAKE_INSTRUCTION_LAYOUTS.Split;
        const data = encodeData(type, {
            lamports
        });
        return new TransactionInstruction({
            keys: [
                {
                    pubkey: stakePubkey,
                    isSigner: false,
                    isWritable: true
                },
                {
                    pubkey: splitStakePubkey,
                    isSigner: false,
                    isWritable: true
                },
                {
                    pubkey: authorizedPubkey,
                    isSigner: true,
                    isWritable: false
                }
            ],
            programId: this.programId,
            data
        });
    }
    /**
   * Generate a Transaction that splits Stake tokens into another stake account
   */ static split(params, // Compute the cost of allocating the new stake account in lamports
    rentExemptReserve) {
        const transaction = new Transaction();
        transaction.add(SystemProgram.createAccount({
            fromPubkey: params.authorizedPubkey,
            newAccountPubkey: params.splitStakePubkey,
            lamports: rentExemptReserve,
            space: this.space,
            programId: this.programId
        }));
        return transaction.add(this.splitInstruction(params));
    }
    /**
   * Generate a Transaction that splits Stake tokens into another account
   * derived from a base public key and seed
   */ static splitWithSeed(params, // If this stake account is new, compute the cost of allocating it in lamports
    rentExemptReserve) {
        const { stakePubkey, authorizedPubkey, splitStakePubkey, basePubkey, seed, lamports } = params;
        const transaction = new Transaction();
        transaction.add(SystemProgram.allocate({
            accountPubkey: splitStakePubkey,
            basePubkey,
            seed,
            space: this.space,
            programId: this.programId
        }));
        if (rentExemptReserve && rentExemptReserve > 0) transaction.add(SystemProgram.transfer({
            fromPubkey: params.authorizedPubkey,
            toPubkey: splitStakePubkey,
            lamports: rentExemptReserve
        }));
        return transaction.add(this.splitInstruction({
            stakePubkey,
            authorizedPubkey,
            splitStakePubkey,
            lamports
        }));
    }
    /**
   * Generate a Transaction that merges Stake accounts.
   */ static merge(params) {
        const { stakePubkey, sourceStakePubKey, authorizedPubkey } = params;
        const type = STAKE_INSTRUCTION_LAYOUTS.Merge;
        const data = encodeData(type);
        return new Transaction().add({
            keys: [
                {
                    pubkey: stakePubkey,
                    isSigner: false,
                    isWritable: true
                },
                {
                    pubkey: sourceStakePubKey,
                    isSigner: false,
                    isWritable: true
                },
                {
                    pubkey: SYSVAR_CLOCK_PUBKEY,
                    isSigner: false,
                    isWritable: false
                },
                {
                    pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,
                    isSigner: false,
                    isWritable: false
                },
                {
                    pubkey: authorizedPubkey,
                    isSigner: true,
                    isWritable: false
                }
            ],
            programId: this.programId,
            data
        });
    }
    /**
   * Generate a Transaction that withdraws deactivated Stake tokens.
   */ static withdraw(params) {
        const { stakePubkey, authorizedPubkey, toPubkey, lamports, custodianPubkey } = params;
        const type = STAKE_INSTRUCTION_LAYOUTS.Withdraw;
        const data = encodeData(type, {
            lamports
        });
        const keys = [
            {
                pubkey: stakePubkey,
                isSigner: false,
                isWritable: true
            },
            {
                pubkey: toPubkey,
                isSigner: false,
                isWritable: true
            },
            {
                pubkey: SYSVAR_CLOCK_PUBKEY,
                isSigner: false,
                isWritable: false
            },
            {
                pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,
                isSigner: false,
                isWritable: false
            },
            {
                pubkey: authorizedPubkey,
                isSigner: true,
                isWritable: false
            }
        ];
        if (custodianPubkey) keys.push({
            pubkey: custodianPubkey,
            isSigner: true,
            isWritable: false
        });
        return new Transaction().add({
            keys,
            programId: this.programId,
            data
        });
    }
    /**
   * Generate a Transaction that deactivates Stake tokens.
   */ static deactivate(params) {
        const { stakePubkey, authorizedPubkey } = params;
        const type = STAKE_INSTRUCTION_LAYOUTS.Deactivate;
        const data = encodeData(type);
        return new Transaction().add({
            keys: [
                {
                    pubkey: stakePubkey,
                    isSigner: false,
                    isWritable: true
                },
                {
                    pubkey: SYSVAR_CLOCK_PUBKEY,
                    isSigner: false,
                    isWritable: false
                },
                {
                    pubkey: authorizedPubkey,
                    isSigner: true,
                    isWritable: false
                }
            ],
            programId: this.programId,
            data
        });
    }
}
StakeProgram.programId = new PublicKey("Stake11111111111111111111111111111111111111");
/**
 * Max space of a Stake account
 *
 * This is generated from the solana-stake-program StakeState struct as
 * `StakeStateV2::size_of()`:
 * https://docs.rs/solana-stake-program/latest/solana_stake_program/stake_state/enum.StakeStateV2.html
 */ StakeProgram.space = 200;
/**
 * Vote account info
 */ class VoteInit {
    /** [0, 100] */ constructor(nodePubkey, authorizedVoter, authorizedWithdrawer, commission){
        this.nodePubkey = void 0;
        this.authorizedVoter = void 0;
        this.authorizedWithdrawer = void 0;
        this.commission = void 0;
        this.nodePubkey = nodePubkey;
        this.authorizedVoter = authorizedVoter;
        this.authorizedWithdrawer = authorizedWithdrawer;
        this.commission = commission;
    }
}
/**
 * Create vote account transaction params
 */ /**
 * InitializeAccount instruction params
 */ /**
 * Authorize instruction params
 */ /**
 * AuthorizeWithSeed instruction params
 */ /**
 * Withdraw from vote account transaction params
 */ /**
 * Update validator identity (node pubkey) vote account instruction params.
 */ /**
 * Vote Instruction class
 */ class VoteInstruction {
    /**
   * @internal
   */ constructor(){}
    /**
   * Decode a vote instruction and retrieve the instruction type.
   */ static decodeInstructionType(instruction) {
        this.checkProgramId(instruction.programId);
        const instructionTypeLayout = _bufferLayout.u32("instruction");
        const typeIndex = instructionTypeLayout.decode(instruction.data);
        let type;
        for (const [ixType, layout] of Object.entries(VOTE_INSTRUCTION_LAYOUTS))if (layout.index == typeIndex) {
            type = ixType;
            break;
        }
        if (!type) throw new Error("Instruction type incorrect; not a VoteInstruction");
        return type;
    }
    /**
   * Decode an initialize vote instruction and retrieve the instruction params.
   */ static decodeInitializeAccount(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeyLength(instruction.keys, 4);
        const { voteInit } = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.InitializeAccount, instruction.data);
        return {
            votePubkey: instruction.keys[0].pubkey,
            nodePubkey: instruction.keys[3].pubkey,
            voteInit: new VoteInit(new PublicKey(voteInit.nodePubkey), new PublicKey(voteInit.authorizedVoter), new PublicKey(voteInit.authorizedWithdrawer), voteInit.commission)
        };
    }
    /**
   * Decode an authorize instruction and retrieve the instruction params.
   */ static decodeAuthorize(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeyLength(instruction.keys, 3);
        const { newAuthorized, voteAuthorizationType } = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.Authorize, instruction.data);
        return {
            votePubkey: instruction.keys[0].pubkey,
            authorizedPubkey: instruction.keys[2].pubkey,
            newAuthorizedPubkey: new PublicKey(newAuthorized),
            voteAuthorizationType: {
                index: voteAuthorizationType
            }
        };
    }
    /**
   * Decode an authorize instruction and retrieve the instruction params.
   */ static decodeAuthorizeWithSeed(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeyLength(instruction.keys, 3);
        const { voteAuthorizeWithSeedArgs: { currentAuthorityDerivedKeyOwnerPubkey, currentAuthorityDerivedKeySeed, newAuthorized, voteAuthorizationType } } = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed, instruction.data);
        return {
            currentAuthorityDerivedKeyBasePubkey: instruction.keys[2].pubkey,
            currentAuthorityDerivedKeyOwnerPubkey: new PublicKey(currentAuthorityDerivedKeyOwnerPubkey),
            currentAuthorityDerivedKeySeed: currentAuthorityDerivedKeySeed,
            newAuthorizedPubkey: new PublicKey(newAuthorized),
            voteAuthorizationType: {
                index: voteAuthorizationType
            },
            votePubkey: instruction.keys[0].pubkey
        };
    }
    /**
   * Decode a withdraw instruction and retrieve the instruction params.
   */ static decodeWithdraw(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeyLength(instruction.keys, 3);
        const { lamports } = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.Withdraw, instruction.data);
        return {
            votePubkey: instruction.keys[0].pubkey,
            authorizedWithdrawerPubkey: instruction.keys[2].pubkey,
            lamports,
            toPubkey: instruction.keys[1].pubkey
        };
    }
    /**
   * @internal
   */ static checkProgramId(programId) {
        if (!programId.equals(VoteProgram.programId)) throw new Error("invalid instruction; programId is not VoteProgram");
    }
    /**
   * @internal
   */ static checkKeyLength(keys, expectedLength) {
        if (keys.length < expectedLength) throw new Error(`invalid instruction; found ${keys.length} keys, expected at least ${expectedLength}`);
    }
}
/**
 * An enumeration of valid VoteInstructionType's
 */ /** @internal */ const VOTE_INSTRUCTION_LAYOUTS = Object.freeze({
    InitializeAccount: {
        index: 0,
        layout: _bufferLayout.struct([
            _bufferLayout.u32("instruction"),
            voteInit()
        ])
    },
    Authorize: {
        index: 1,
        layout: _bufferLayout.struct([
            _bufferLayout.u32("instruction"),
            publicKey("newAuthorized"),
            _bufferLayout.u32("voteAuthorizationType")
        ])
    },
    Withdraw: {
        index: 3,
        layout: _bufferLayout.struct([
            _bufferLayout.u32("instruction"),
            _bufferLayout.ns64("lamports")
        ])
    },
    UpdateValidatorIdentity: {
        index: 4,
        layout: _bufferLayout.struct([
            _bufferLayout.u32("instruction")
        ])
    },
    AuthorizeWithSeed: {
        index: 10,
        layout: _bufferLayout.struct([
            _bufferLayout.u32("instruction"),
            voteAuthorizeWithSeedArgs()
        ])
    }
});
/**
 * VoteAuthorize type
 */ /**
 * An enumeration of valid VoteAuthorization layouts.
 */ const VoteAuthorizationLayout = Object.freeze({
    Voter: {
        index: 0
    },
    Withdrawer: {
        index: 1
    }
});
/**
 * Factory class for transactions to interact with the Vote program
 */ class VoteProgram {
    /**
   * @internal
   */ constructor(){}
    /**
   * Public key that identifies the Vote program
   */ /**
   * Generate an Initialize instruction.
   */ static initializeAccount(params) {
        const { votePubkey, nodePubkey, voteInit } = params;
        const type = VOTE_INSTRUCTION_LAYOUTS.InitializeAccount;
        const data = encodeData(type, {
            voteInit: {
                nodePubkey: toBuffer(voteInit.nodePubkey.toBuffer()),
                authorizedVoter: toBuffer(voteInit.authorizedVoter.toBuffer()),
                authorizedWithdrawer: toBuffer(voteInit.authorizedWithdrawer.toBuffer()),
                commission: voteInit.commission
            }
        });
        const instructionData = {
            keys: [
                {
                    pubkey: votePubkey,
                    isSigner: false,
                    isWritable: true
                },
                {
                    pubkey: SYSVAR_RENT_PUBKEY,
                    isSigner: false,
                    isWritable: false
                },
                {
                    pubkey: SYSVAR_CLOCK_PUBKEY,
                    isSigner: false,
                    isWritable: false
                },
                {
                    pubkey: nodePubkey,
                    isSigner: true,
                    isWritable: false
                }
            ],
            programId: this.programId,
            data
        };
        return new TransactionInstruction(instructionData);
    }
    /**
   * Generate a transaction that creates a new Vote account.
   */ static createAccount(params) {
        const transaction = new Transaction();
        transaction.add(SystemProgram.createAccount({
            fromPubkey: params.fromPubkey,
            newAccountPubkey: params.votePubkey,
            lamports: params.lamports,
            space: this.space,
            programId: this.programId
        }));
        return transaction.add(this.initializeAccount({
            votePubkey: params.votePubkey,
            nodePubkey: params.voteInit.nodePubkey,
            voteInit: params.voteInit
        }));
    }
    /**
   * Generate a transaction that authorizes a new Voter or Withdrawer on the Vote account.
   */ static authorize(params) {
        const { votePubkey, authorizedPubkey, newAuthorizedPubkey, voteAuthorizationType } = params;
        const type = VOTE_INSTRUCTION_LAYOUTS.Authorize;
        const data = encodeData(type, {
            newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),
            voteAuthorizationType: voteAuthorizationType.index
        });
        const keys = [
            {
                pubkey: votePubkey,
                isSigner: false,
                isWritable: true
            },
            {
                pubkey: SYSVAR_CLOCK_PUBKEY,
                isSigner: false,
                isWritable: false
            },
            {
                pubkey: authorizedPubkey,
                isSigner: true,
                isWritable: false
            }
        ];
        return new Transaction().add({
            keys,
            programId: this.programId,
            data
        });
    }
    /**
   * Generate a transaction that authorizes a new Voter or Withdrawer on the Vote account
   * where the current Voter or Withdrawer authority is a derived key.
   */ static authorizeWithSeed(params) {
        const { currentAuthorityDerivedKeyBasePubkey, currentAuthorityDerivedKeyOwnerPubkey, currentAuthorityDerivedKeySeed, newAuthorizedPubkey, voteAuthorizationType, votePubkey } = params;
        const type = VOTE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed;
        const data = encodeData(type, {
            voteAuthorizeWithSeedArgs: {
                currentAuthorityDerivedKeyOwnerPubkey: toBuffer(currentAuthorityDerivedKeyOwnerPubkey.toBuffer()),
                currentAuthorityDerivedKeySeed: currentAuthorityDerivedKeySeed,
                newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),
                voteAuthorizationType: voteAuthorizationType.index
            }
        });
        const keys = [
            {
                pubkey: votePubkey,
                isSigner: false,
                isWritable: true
            },
            {
                pubkey: SYSVAR_CLOCK_PUBKEY,
                isSigner: false,
                isWritable: false
            },
            {
                pubkey: currentAuthorityDerivedKeyBasePubkey,
                isSigner: true,
                isWritable: false
            }
        ];
        return new Transaction().add({
            keys,
            programId: this.programId,
            data
        });
    }
    /**
   * Generate a transaction to withdraw from a Vote account.
   */ static withdraw(params) {
        const { votePubkey, authorizedWithdrawerPubkey, lamports, toPubkey } = params;
        const type = VOTE_INSTRUCTION_LAYOUTS.Withdraw;
        const data = encodeData(type, {
            lamports
        });
        const keys = [
            {
                pubkey: votePubkey,
                isSigner: false,
                isWritable: true
            },
            {
                pubkey: toPubkey,
                isSigner: false,
                isWritable: true
            },
            {
                pubkey: authorizedWithdrawerPubkey,
                isSigner: true,
                isWritable: false
            }
        ];
        return new Transaction().add({
            keys,
            programId: this.programId,
            data
        });
    }
    /**
   * Generate a transaction to withdraw safely from a Vote account.
   *
   * This function was created as a safeguard for vote accounts running validators, `safeWithdraw`
   * checks that the withdraw amount will not exceed the specified balance while leaving enough left
   * to cover rent. If you wish to close the vote account by withdrawing the full amount, call the
   * `withdraw` method directly.
   */ static safeWithdraw(params, currentVoteAccountBalance, rentExemptMinimum) {
        if (params.lamports > currentVoteAccountBalance - rentExemptMinimum) throw new Error("Withdraw will leave vote account with insufficient funds.");
        return VoteProgram.withdraw(params);
    }
    /**
   * Generate a transaction to update the validator identity (node pubkey) of a Vote account.
   */ static updateValidatorIdentity(params) {
        const { votePubkey, authorizedWithdrawerPubkey, nodePubkey } = params;
        const type = VOTE_INSTRUCTION_LAYOUTS.UpdateValidatorIdentity;
        const data = encodeData(type);
        const keys = [
            {
                pubkey: votePubkey,
                isSigner: false,
                isWritable: true
            },
            {
                pubkey: nodePubkey,
                isSigner: true,
                isWritable: false
            },
            {
                pubkey: authorizedWithdrawerPubkey,
                isSigner: true,
                isWritable: false
            }
        ];
        return new Transaction().add({
            keys,
            programId: this.programId,
            data
        });
    }
}
VoteProgram.programId = new PublicKey("Vote111111111111111111111111111111111111111");
/**
 * Max space of a Vote account
 *
 * This is generated from the solana-vote-program VoteState struct as
 * `VoteState::size_of()`:
 * https://docs.rs/solana-vote-program/1.9.5/solana_vote_program/vote_state/struct.VoteState.html#method.size_of
 *
 * KEEP IN SYNC WITH `VoteState::size_of()` in https://github.com/solana-labs/solana/blob/a474cb24b9238f5edcc982f65c0b37d4a1046f7e/sdk/program/src/vote/state/mod.rs#L340-L342
 */ VoteProgram.space = 3762;
const VALIDATOR_INFO_KEY = new PublicKey("Va1idator1nfo111111111111111111111111111111");
/**
 * @internal
 */ /**
 * Info used to identity validators.
 */ const InfoString = (0, _superstruct.type)({
    name: (0, _superstruct.string)(),
    website: (0, _superstruct.optional)((0, _superstruct.string)()),
    details: (0, _superstruct.optional)((0, _superstruct.string)()),
    iconUrl: (0, _superstruct.optional)((0, _superstruct.string)()),
    keybaseUsername: (0, _superstruct.optional)((0, _superstruct.string)())
});
/**
 * ValidatorInfo class
 */ class ValidatorInfo {
    /**
   * Construct a valid ValidatorInfo
   *
   * @param key validator public key
   * @param info validator information
   */ constructor(key, info){
        /**
     * validator public key
     */ this.key = void 0;
        /**
     * validator information
     */ this.info = void 0;
        this.key = key;
        this.info = info;
    }
    /**
   * Deserialize ValidatorInfo from the config account data. Exactly two config
   * keys are required in the data.
   *
   * @param buffer config account data
   * @return null if info was not found
   */ static fromConfigData(buffer) {
        let byteArray = [
            ...buffer
        ];
        const configKeyCount = decodeLength(byteArray);
        if (configKeyCount !== 2) return null;
        const configKeys = [];
        for(let i = 0; i < 2; i++){
            const publicKey = new PublicKey(guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH));
            const isSigner = guardedShift(byteArray) === 1;
            configKeys.push({
                publicKey,
                isSigner
            });
        }
        if (configKeys[0].publicKey.equals(VALIDATOR_INFO_KEY)) {
            if (configKeys[1].isSigner) {
                const rawInfo = rustString().decode((0, _buffer.Buffer).from(byteArray));
                const info = JSON.parse(rawInfo);
                (0, _superstruct.assert)(info, InfoString);
                return new ValidatorInfo(configKeys[1].publicKey, info);
            }
        }
        return null;
    }
}
const VOTE_PROGRAM_ID = new PublicKey("Vote111111111111111111111111111111111111111");
/**
 * History of how many credits earned by the end of each epoch
 */ /**
 * See https://github.com/solana-labs/solana/blob/8a12ed029cfa38d4a45400916c2463fb82bbec8c/programs/vote_api/src/vote_state.rs#L68-L88
 *
 * @internal
 */ const VoteAccountLayout = _bufferLayout.struct([
    publicKey("nodePubkey"),
    publicKey("authorizedWithdrawer"),
    _bufferLayout.u8("commission"),
    _bufferLayout.nu64(),
    // votes.length
    _bufferLayout.seq(_bufferLayout.struct([
        _bufferLayout.nu64("slot"),
        _bufferLayout.u32("confirmationCount")
    ]), _bufferLayout.offset(_bufferLayout.u32(), -8), "votes"),
    _bufferLayout.u8("rootSlotValid"),
    _bufferLayout.nu64("rootSlot"),
    _bufferLayout.nu64(),
    // authorizedVoters.length
    _bufferLayout.seq(_bufferLayout.struct([
        _bufferLayout.nu64("epoch"),
        publicKey("authorizedVoter")
    ]), _bufferLayout.offset(_bufferLayout.u32(), -8), "authorizedVoters"),
    _bufferLayout.struct([
        _bufferLayout.seq(_bufferLayout.struct([
            publicKey("authorizedPubkey"),
            _bufferLayout.nu64("epochOfLastAuthorizedSwitch"),
            _bufferLayout.nu64("targetEpoch")
        ]), 32, "buf"),
        _bufferLayout.nu64("idx"),
        _bufferLayout.u8("isEmpty")
    ], "priorVoters"),
    _bufferLayout.nu64(),
    // epochCredits.length
    _bufferLayout.seq(_bufferLayout.struct([
        _bufferLayout.nu64("epoch"),
        _bufferLayout.nu64("credits"),
        _bufferLayout.nu64("prevCredits")
    ]), _bufferLayout.offset(_bufferLayout.u32(), -8), "epochCredits"),
    _bufferLayout.struct([
        _bufferLayout.nu64("slot"),
        _bufferLayout.nu64("timestamp")
    ], "lastTimestamp")
]);
/**
 * VoteAccount class
 */ class VoteAccount {
    /**
   * @internal
   */ constructor(args){
        this.nodePubkey = void 0;
        this.authorizedWithdrawer = void 0;
        this.commission = void 0;
        this.rootSlot = void 0;
        this.votes = void 0;
        this.authorizedVoters = void 0;
        this.priorVoters = void 0;
        this.epochCredits = void 0;
        this.lastTimestamp = void 0;
        this.nodePubkey = args.nodePubkey;
        this.authorizedWithdrawer = args.authorizedWithdrawer;
        this.commission = args.commission;
        this.rootSlot = args.rootSlot;
        this.votes = args.votes;
        this.authorizedVoters = args.authorizedVoters;
        this.priorVoters = args.priorVoters;
        this.epochCredits = args.epochCredits;
        this.lastTimestamp = args.lastTimestamp;
    }
    /**
   * Deserialize VoteAccount from the account data.
   *
   * @param buffer account data
   * @return VoteAccount
   */ static fromAccountData(buffer) {
        const versionOffset = 4;
        const va = VoteAccountLayout.decode(toBuffer(buffer), versionOffset);
        let rootSlot = va.rootSlot;
        if (!va.rootSlotValid) rootSlot = null;
        return new VoteAccount({
            nodePubkey: new PublicKey(va.nodePubkey),
            authorizedWithdrawer: new PublicKey(va.authorizedWithdrawer),
            commission: va.commission,
            votes: va.votes,
            rootSlot,
            authorizedVoters: va.authorizedVoters.map(parseAuthorizedVoter),
            priorVoters: getPriorVoters(va.priorVoters),
            epochCredits: va.epochCredits,
            lastTimestamp: va.lastTimestamp
        });
    }
}
function parseAuthorizedVoter({ authorizedVoter, epoch }) {
    return {
        epoch,
        authorizedVoter: new PublicKey(authorizedVoter)
    };
}
function parsePriorVoters({ authorizedPubkey, epochOfLastAuthorizedSwitch, targetEpoch }) {
    return {
        authorizedPubkey: new PublicKey(authorizedPubkey),
        epochOfLastAuthorizedSwitch,
        targetEpoch
    };
}
function getPriorVoters({ buf, idx, isEmpty }) {
    if (isEmpty) return [];
    return [
        ...buf.slice(idx + 1).map(parsePriorVoters),
        ...buf.slice(0, idx).map(parsePriorVoters)
    ];
}
const endpoint = {
    http: {
        devnet: "http://api.devnet.solana.com",
        testnet: "http://api.testnet.solana.com",
        "mainnet-beta": "http://api.mainnet-beta.solana.com/"
    },
    https: {
        devnet: "https://api.devnet.solana.com",
        testnet: "https://api.testnet.solana.com",
        "mainnet-beta": "https://api.mainnet-beta.solana.com/"
    }
};
/**
 * Retrieves the RPC API URL for the specified cluster
 * @param {Cluster} [cluster="devnet"] - The cluster name of the RPC API URL to use. Possible options: 'devnet' | 'testnet' | 'mainnet-beta'
 * @param {boolean} [tls="http"] - Use TLS when connecting to cluster.
 *
 * @returns {string} URL string of the RPC endpoint
 */ function clusterApiUrl(cluster, tls) {
    const key = tls === false ? "http" : "https";
    if (!cluster) return endpoint[key]["devnet"];
    const url = endpoint[key][cluster];
    if (!url) throw new Error(`Unknown ${key} cluster: ${cluster}`);
    return url;
}
/**
 * Send and confirm a raw transaction
 *
 * If `commitment` option is not specified, defaults to 'max' commitment.
 *
 * @param {Connection} connection
 * @param {Buffer} rawTransaction
 * @param {TransactionConfirmationStrategy} confirmationStrategy
 * @param {ConfirmOptions} [options]
 * @returns {Promise<TransactionSignature>}
 */ /**
 * @deprecated Calling `sendAndConfirmRawTransaction()` without a `confirmationStrategy`
 * is no longer supported and will be removed in a future version.
 */ // eslint-disable-next-line no-redeclare
// eslint-disable-next-line no-redeclare
async function sendAndConfirmRawTransaction(connection, rawTransaction, confirmationStrategyOrConfirmOptions, maybeConfirmOptions) {
    let confirmationStrategy;
    let options;
    if (confirmationStrategyOrConfirmOptions && Object.prototype.hasOwnProperty.call(confirmationStrategyOrConfirmOptions, "lastValidBlockHeight")) {
        confirmationStrategy = confirmationStrategyOrConfirmOptions;
        options = maybeConfirmOptions;
    } else if (confirmationStrategyOrConfirmOptions && Object.prototype.hasOwnProperty.call(confirmationStrategyOrConfirmOptions, "nonceValue")) {
        confirmationStrategy = confirmationStrategyOrConfirmOptions;
        options = maybeConfirmOptions;
    } else options = confirmationStrategyOrConfirmOptions;
    const sendOptions = options && {
        skipPreflight: options.skipPreflight,
        preflightCommitment: options.preflightCommitment || options.commitment,
        minContextSlot: options.minContextSlot
    };
    const signature = await connection.sendRawTransaction(rawTransaction, sendOptions);
    const commitment = options && options.commitment;
    const confirmationPromise = confirmationStrategy ? connection.confirmTransaction(confirmationStrategy, commitment) : connection.confirmTransaction(signature, commitment);
    const status = (await confirmationPromise).value;
    if (status.err) {
        if (signature != null) throw new SendTransactionError({
            action: sendOptions?.skipPreflight ? "send" : "simulate",
            signature: signature,
            transactionMessage: `Status: (${JSON.stringify(status)})`
        });
        throw new Error(`Raw transaction ${signature} failed (${JSON.stringify(status)})`);
    }
    return signature;
}
/**
 * There are 1-billion lamports in one SOL
 */ const LAMPORTS_PER_SOL = 1000000000;

},{"buffer":"fCgem","@noble/curves/ed25519":"f6cMq","bn.js":"VopIn","bs58":"4ji3p","@noble/hashes/sha256":"JjjO8","borsh":"4JCmN","@solana/buffer-layout":"jD9A8","bigint-buffer":"b5EGn","superstruct":"lC06T","jayson/lib/client/browser":"ckwy4","rpc-websockets":"261rv","@noble/hashes/sha3":"7YJSg","@noble/curves/secp256k1":"9sjVG","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fCgem":[function(require,module,exports) {
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */ /* eslint-disable no-proto */ "use strict";
const base64 = require("9c62938f1dccc73c");
const ieee754 = require("aceacb6a4531a9d2");
const customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" // eslint-disable-line dot-notation
 ? Symbol["for"]("nodejs.util.inspect.custom") // eslint-disable-line dot-notation
 : null;
exports.Buffer = Buffer;
exports.SlowBuffer = SlowBuffer;
exports.INSPECT_MAX_BYTES = 50;
const K_MAX_LENGTH = 0x7fffffff;
exports.kMaxLength = K_MAX_LENGTH;
/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */ Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();
if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
function typedArraySupport() {
    // Can typed array instances can be augmented?
    try {
        const arr = new Uint8Array(1);
        const proto = {
            foo: function() {
                return 42;
            }
        };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
    } catch (e) {
        return false;
    }
}
Object.defineProperty(Buffer.prototype, "parent", {
    enumerable: true,
    get: function() {
        if (!Buffer.isBuffer(this)) return undefined;
        return this.buffer;
    }
});
Object.defineProperty(Buffer.prototype, "offset", {
    enumerable: true,
    get: function() {
        if (!Buffer.isBuffer(this)) return undefined;
        return this.byteOffset;
    }
});
function createBuffer(length) {
    if (length > K_MAX_LENGTH) throw new RangeError('The value "' + length + '" is invalid for option "size"');
    // Return an augmented `Uint8Array` instance
    const buf = new Uint8Array(length);
    Object.setPrototypeOf(buf, Buffer.prototype);
    return buf;
}
/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */ function Buffer(arg, encodingOrOffset, length) {
    // Common case.
    if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") throw new TypeError('The "string" argument must be of type string. Received type number');
        return allocUnsafe(arg);
    }
    return from(arg, encodingOrOffset, length);
}
Buffer.poolSize = 8192 // not used by this implementation
;
function from(value, encodingOrOffset, length) {
    if (typeof value === "string") return fromString(value, encodingOrOffset);
    if (ArrayBuffer.isView(value)) return fromArrayView(value);
    if (value == null) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
    if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) return fromArrayBuffer(value, encodingOrOffset, length);
    if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) return fromArrayBuffer(value, encodingOrOffset, length);
    if (typeof value === "number") throw new TypeError('The "value" argument must not be of type number. Received type number');
    const valueOf = value.valueOf && value.valueOf();
    if (valueOf != null && valueOf !== value) return Buffer.from(valueOf, encodingOrOffset, length);
    const b = fromObject(value);
    if (b) return b;
    if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") return Buffer.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
}
/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/ Buffer.from = function(value, encodingOrOffset, length) {
    return from(value, encodingOrOffset, length);
};
// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);
Object.setPrototypeOf(Buffer, Uint8Array);
function assertSize(size) {
    if (typeof size !== "number") throw new TypeError('"size" argument must be of type number');
    else if (size < 0) throw new RangeError('The value "' + size + '" is invalid for option "size"');
}
function alloc(size, fill, encoding) {
    assertSize(size);
    if (size <= 0) return createBuffer(size);
    if (fill !== undefined) // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpreted as a start offset.
    return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
    return createBuffer(size);
}
/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/ Buffer.alloc = function(size, fill, encoding) {
    return alloc(size, fill, encoding);
};
function allocUnsafe(size) {
    assertSize(size);
    return createBuffer(size < 0 ? 0 : checked(size) | 0);
}
/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */ Buffer.allocUnsafe = function(size) {
    return allocUnsafe(size);
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */ Buffer.allocUnsafeSlow = function(size) {
    return allocUnsafe(size);
};
function fromString(string, encoding) {
    if (typeof encoding !== "string" || encoding === "") encoding = "utf8";
    if (!Buffer.isEncoding(encoding)) throw new TypeError("Unknown encoding: " + encoding);
    const length = byteLength(string, encoding) | 0;
    let buf = createBuffer(length);
    const actual = buf.write(string, encoding);
    if (actual !== length) // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual);
    return buf;
}
function fromArrayLike(array) {
    const length = array.length < 0 ? 0 : checked(array.length) | 0;
    const buf = createBuffer(length);
    for(let i = 0; i < length; i += 1)buf[i] = array[i] & 255;
    return buf;
}
function fromArrayView(arrayView) {
    if (isInstance(arrayView, Uint8Array)) {
        const copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
    }
    return fromArrayLike(arrayView);
}
function fromArrayBuffer(array, byteOffset, length) {
    if (byteOffset < 0 || array.byteLength < byteOffset) throw new RangeError('"offset" is outside of buffer bounds');
    if (array.byteLength < byteOffset + (length || 0)) throw new RangeError('"length" is outside of buffer bounds');
    let buf;
    if (byteOffset === undefined && length === undefined) buf = new Uint8Array(array);
    else if (length === undefined) buf = new Uint8Array(array, byteOffset);
    else buf = new Uint8Array(array, byteOffset, length);
    // Return an augmented `Uint8Array` instance
    Object.setPrototypeOf(buf, Buffer.prototype);
    return buf;
}
function fromObject(obj) {
    if (Buffer.isBuffer(obj)) {
        const len = checked(obj.length) | 0;
        const buf = createBuffer(len);
        if (buf.length === 0) return buf;
        obj.copy(buf, 0, 0, len);
        return buf;
    }
    if (obj.length !== undefined) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) return createBuffer(0);
        return fromArrayLike(obj);
    }
    if (obj.type === "Buffer" && Array.isArray(obj.data)) return fromArrayLike(obj.data);
}
function checked(length) {
    // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
    // length is NaN (which is otherwise coerced to zero.)
    if (length >= K_MAX_LENGTH) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
    return length | 0;
}
function SlowBuffer(length) {
    if (+length != length) length = 0;
    return Buffer.alloc(+length);
}
Buffer.isBuffer = function isBuffer(b) {
    return b != null && b._isBuffer === true && b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
    ;
};
Buffer.compare = function compare(a, b) {
    if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength);
    if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength);
    if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    if (a === b) return 0;
    let x = a.length;
    let y = b.length;
    for(let i = 0, len = Math.min(x, y); i < len; ++i)if (a[i] !== b[i]) {
        x = a[i];
        y = b[i];
        break;
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
};
Buffer.isEncoding = function isEncoding(encoding) {
    switch(String(encoding).toLowerCase()){
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return true;
        default:
            return false;
    }
};
Buffer.concat = function concat(list, length) {
    if (!Array.isArray(list)) throw new TypeError('"list" argument must be an Array of Buffers');
    if (list.length === 0) return Buffer.alloc(0);
    let i;
    if (length === undefined) {
        length = 0;
        for(i = 0; i < list.length; ++i)length += list[i].length;
    }
    const buffer = Buffer.allocUnsafe(length);
    let pos = 0;
    for(i = 0; i < list.length; ++i){
        let buf = list[i];
        if (isInstance(buf, Uint8Array)) {
            if (pos + buf.length > buffer.length) {
                if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf);
                buf.copy(buffer, pos);
            } else Uint8Array.prototype.set.call(buffer, buf, pos);
        } else if (!Buffer.isBuffer(buf)) throw new TypeError('"list" argument must be an Array of Buffers');
        else buf.copy(buffer, pos);
        pos += buf.length;
    }
    return buffer;
};
function byteLength(string, encoding) {
    if (Buffer.isBuffer(string)) return string.length;
    if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) return string.byteLength;
    if (typeof string !== "string") throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string);
    const len = string.length;
    const mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len === 0) return 0;
    // Use a for loop to avoid recursion
    let loweredCase = false;
    for(;;)switch(encoding){
        case "ascii":
        case "latin1":
        case "binary":
            return len;
        case "utf8":
        case "utf-8":
            return utf8ToBytes(string).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return len * 2;
        case "hex":
            return len >>> 1;
        case "base64":
            return base64ToBytes(string).length;
        default:
            if (loweredCase) return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
            ;
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
    }
}
Buffer.byteLength = byteLength;
function slowToString(encoding, start, end) {
    let loweredCase = false;
    // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
    // property of a typed array.
    // This behaves neither like String nor Uint8Array in that we set start/end
    // to their upper/lower bounds if the value passed is out of range.
    // undefined is handled specially as per ECMA-262 6th Edition,
    // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
    if (start === undefined || start < 0) start = 0;
    // Return early if start > this.length. Done here to prevent potential uint32
    // coercion fail below.
    if (start > this.length) return "";
    if (end === undefined || end > this.length) end = this.length;
    if (end <= 0) return "";
    // Force coercion to uint32. This will also coerce falsey/NaN values to 0.
    end >>>= 0;
    start >>>= 0;
    if (end <= start) return "";
    if (!encoding) encoding = "utf8";
    while(true)switch(encoding){
        case "hex":
            return hexSlice(this, start, end);
        case "utf8":
        case "utf-8":
            return utf8Slice(this, start, end);
        case "ascii":
            return asciiSlice(this, start, end);
        case "latin1":
        case "binary":
            return latin1Slice(this, start, end);
        case "base64":
            return base64Slice(this, start, end);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return utf16leSlice(this, start, end);
        default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
    }
}
// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true;
function swap(b, n, m) {
    const i = b[n];
    b[n] = b[m];
    b[m] = i;
}
Buffer.prototype.swap16 = function swap16() {
    const len = this.length;
    if (len % 2 !== 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
    for(let i = 0; i < len; i += 2)swap(this, i, i + 1);
    return this;
};
Buffer.prototype.swap32 = function swap32() {
    const len = this.length;
    if (len % 4 !== 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
    for(let i = 0; i < len; i += 4){
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
    }
    return this;
};
Buffer.prototype.swap64 = function swap64() {
    const len = this.length;
    if (len % 8 !== 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
    for(let i = 0; i < len; i += 8){
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
    }
    return this;
};
Buffer.prototype.toString = function toString() {
    const length = this.length;
    if (length === 0) return "";
    if (arguments.length === 0) return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
};
Buffer.prototype.toLocaleString = Buffer.prototype.toString;
Buffer.prototype.equals = function equals(b) {
    if (!Buffer.isBuffer(b)) throw new TypeError("Argument must be a Buffer");
    if (this === b) return true;
    return Buffer.compare(this, b) === 0;
};
Buffer.prototype.inspect = function inspect() {
    let str = "";
    const max = exports.INSPECT_MAX_BYTES;
    str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
    if (this.length > max) str += " ... ";
    return "<Buffer " + str + ">";
};
if (customInspectSymbol) Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect;
Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array)) target = Buffer.from(target, target.offset, target.byteLength);
    if (!Buffer.isBuffer(target)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);
    if (start === undefined) start = 0;
    if (end === undefined) end = target ? target.length : 0;
    if (thisStart === undefined) thisStart = 0;
    if (thisEnd === undefined) thisEnd = this.length;
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) throw new RangeError("out of range index");
    if (thisStart >= thisEnd && start >= end) return 0;
    if (thisStart >= thisEnd) return -1;
    if (start >= end) return 1;
    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target) return 0;
    let x = thisEnd - thisStart;
    let y = end - start;
    const len = Math.min(x, y);
    const thisCopy = this.slice(thisStart, thisEnd);
    const targetCopy = target.slice(start, end);
    for(let i = 0; i < len; ++i)if (thisCopy[i] !== targetCopy[i]) {
        x = thisCopy[i];
        y = targetCopy[i];
        break;
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
};
// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
    // Empty buffer means no match
    if (buffer.length === 0) return -1;
    // Normalize byteOffset
    if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
    } else if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff;
    else if (byteOffset < -2147483648) byteOffset = -2147483648;
    byteOffset = +byteOffset // Coerce to Number.
    ;
    if (numberIsNaN(byteOffset)) // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : buffer.length - 1;
    // Normalize byteOffset: negative offsets start from the end of the buffer
    if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
    if (byteOffset >= buffer.length) {
        if (dir) return -1;
        else byteOffset = buffer.length - 1;
    } else if (byteOffset < 0) {
        if (dir) byteOffset = 0;
        else return -1;
    }
    // Normalize val
    if (typeof val === "string") val = Buffer.from(val, encoding);
    // Finally, search either indexOf (if dir is true) or lastIndexOf
    if (Buffer.isBuffer(val)) {
        // Special case: looking for empty string/buffer always fails
        if (val.length === 0) return -1;
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
    } else if (typeof val === "number") {
        val = val & 0xFF // Search for a byte value [0-255]
        ;
        if (typeof Uint8Array.prototype.indexOf === "function") {
            if (dir) return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
            else return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
        }
        return arrayIndexOf(buffer, [
            val
        ], byteOffset, encoding, dir);
    }
    throw new TypeError("val must be string, number or Buffer");
}
function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    let indexSize = 1;
    let arrLength = arr.length;
    let valLength = val.length;
    if (encoding !== undefined) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
            if (arr.length < 2 || val.length < 2) return -1;
            indexSize = 2;
            arrLength /= 2;
            valLength /= 2;
            byteOffset /= 2;
        }
    }
    function read(buf, i) {
        if (indexSize === 1) return buf[i];
        else return buf.readUInt16BE(i * indexSize);
    }
    let i;
    if (dir) {
        let foundIndex = -1;
        for(i = byteOffset; i < arrLength; i++)if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1) foundIndex = i;
            if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
        } else {
            if (foundIndex !== -1) i -= i - foundIndex;
            foundIndex = -1;
        }
    } else {
        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
        for(i = byteOffset; i >= 0; i--){
            let found = true;
            for(let j = 0; j < valLength; j++)if (read(arr, i + j) !== read(val, j)) {
                found = false;
                break;
            }
            if (found) return i;
        }
    }
    return -1;
}
Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
};
Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};
Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};
function hexWrite(buf, string, offset, length) {
    offset = Number(offset) || 0;
    const remaining = buf.length - offset;
    if (!length) length = remaining;
    else {
        length = Number(length);
        if (length > remaining) length = remaining;
    }
    const strLen = string.length;
    if (length > strLen / 2) length = strLen / 2;
    let i;
    for(i = 0; i < length; ++i){
        const parsed = parseInt(string.substr(i * 2, 2), 16);
        if (numberIsNaN(parsed)) return i;
        buf[offset + i] = parsed;
    }
    return i;
}
function utf8Write(buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
}
function asciiWrite(buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length);
}
function base64Write(buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length);
}
function ucs2Write(buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}
Buffer.prototype.write = function write(string, offset, length, encoding) {
    // Buffer#write(string)
    if (offset === undefined) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
    // Buffer#write(string, encoding)
    } else if (length === undefined && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
    // Buffer#write(string, offset[, length][, encoding])
    } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
            length = length >>> 0;
            if (encoding === undefined) encoding = "utf8";
        } else {
            encoding = length;
            length = undefined;
        }
    } else throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
    const remaining = this.length - offset;
    if (length === undefined || length > remaining) length = remaining;
    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) throw new RangeError("Attempt to write outside buffer bounds");
    if (!encoding) encoding = "utf8";
    let loweredCase = false;
    for(;;)switch(encoding){
        case "hex":
            return hexWrite(this, string, offset, length);
        case "utf8":
        case "utf-8":
            return utf8Write(this, string, offset, length);
        case "ascii":
        case "latin1":
        case "binary":
            return asciiWrite(this, string, offset, length);
        case "base64":
            // Warning: maxLength not taken into account in base64Write
            return base64Write(this, string, offset, length);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return ucs2Write(this, string, offset, length);
        default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
    }
};
Buffer.prototype.toJSON = function toJSON() {
    return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
    };
};
function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) return base64.fromByteArray(buf);
    else return base64.fromByteArray(buf.slice(start, end));
}
function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    const res = [];
    let i = start;
    while(i < end){
        const firstByte = buf[i];
        let codePoint = null;
        let bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;
        if (i + bytesPerSequence <= end) {
            let secondByte, thirdByte, fourthByte, tempCodePoint;
            switch(bytesPerSequence){
                case 1:
                    if (firstByte < 0x80) codePoint = firstByte;
                    break;
                case 2:
                    secondByte = buf[i + 1];
                    if ((secondByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;
                        if (tempCodePoint > 0x7F) codePoint = tempCodePoint;
                    }
                    break;
                case 3:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;
                        if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) codePoint = tempCodePoint;
                    }
                    break;
                case 4:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    fourthByte = buf[i + 3];
                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;
                        if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) codePoint = tempCodePoint;
                    }
            }
        }
        if (codePoint === null) {
            // we did not generate a valid codePoint so insert a
            // replacement char (U+FFFD) and advance only 1 byte
            codePoint = 0xFFFD;
            bytesPerSequence = 1;
        } else if (codePoint > 0xFFFF) {
            // encode to utf16 (surrogate pair dance)
            codePoint -= 0x10000;
            res.push(codePoint >>> 10 & 0x3FF | 0xD800);
            codePoint = 0xDC00 | codePoint & 0x3FF;
        }
        res.push(codePoint);
        i += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
}
// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
const MAX_ARGUMENTS_LENGTH = 0x1000;
function decodeCodePointsArray(codePoints) {
    const len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
    ;
    // Decode in chunks to avoid "call stack size exceeded".
    let res = "";
    let i = 0;
    while(i < len)res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
    return res;
}
function asciiSlice(buf, start, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for(let i = start; i < end; ++i)ret += String.fromCharCode(buf[i] & 0x7F);
    return ret;
}
function latin1Slice(buf, start, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for(let i = start; i < end; ++i)ret += String.fromCharCode(buf[i]);
    return ret;
}
function hexSlice(buf, start, end) {
    const len = buf.length;
    if (!start || start < 0) start = 0;
    if (!end || end < 0 || end > len) end = len;
    let out = "";
    for(let i = start; i < end; ++i)out += hexSliceLookupTable[buf[i]];
    return out;
}
function utf16leSlice(buf, start, end) {
    const bytes = buf.slice(start, end);
    let res = "";
    // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)
    for(let i = 0; i < bytes.length - 1; i += 2)res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    return res;
}
Buffer.prototype.slice = function slice(start, end) {
    const len = this.length;
    start = ~~start;
    end = end === undefined ? len : ~~end;
    if (start < 0) {
        start += len;
        if (start < 0) start = 0;
    } else if (start > len) start = len;
    if (end < 0) {
        end += len;
        if (end < 0) end = 0;
    } else if (end > len) end = len;
    if (end < start) end = start;
    const newBuf = this.subarray(start, end);
    // Return an augmented `Uint8Array` instance
    Object.setPrototypeOf(newBuf, Buffer.prototype);
    return newBuf;
};
/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */ function checkOffset(offset, ext, length) {
    if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
    if (offset + ext > length) throw new RangeError("Trying to access beyond buffer length");
}
Buffer.prototype.readUintLE = Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    let val = this[offset];
    let mul = 1;
    let i = 0;
    while(++i < byteLength && (mul *= 0x100))val += this[offset + i] * mul;
    return val;
};
Buffer.prototype.readUintBE = Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    let val = this[offset + --byteLength];
    let mul = 1;
    while(byteLength > 0 && (mul *= 0x100))val += this[offset + --byteLength] * mul;
    return val;
};
Buffer.prototype.readUint8 = Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    return this[offset];
};
Buffer.prototype.readUint16LE = Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
};
Buffer.prototype.readUint16BE = Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
};
Buffer.prototype.readUint32LE = Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
};
Buffer.prototype.readUint32BE = Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
};
Buffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === undefined || last === undefined) boundsError(offset, this.length - 8);
    const lo = first + this[++offset] * 256 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
    const hi = this[++offset] + this[++offset] * 256 + this[++offset] * 2 ** 16 + last * 2 ** 24;
    return BigInt(lo) + (BigInt(hi) << BigInt(32));
});
Buffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === undefined || last === undefined) boundsError(offset, this.length - 8);
    const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 256 + this[++offset];
    const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 256 + last;
    return (BigInt(hi) << BigInt(32)) + BigInt(lo);
});
Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    let val = this[offset];
    let mul = 1;
    let i = 0;
    while(++i < byteLength && (mul *= 0x100))val += this[offset + i] * mul;
    mul *= 0x80;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength);
    return val;
};
Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    let i = byteLength;
    let mul = 1;
    let val = this[offset + --i];
    while(i > 0 && (mul *= 0x100))val += this[offset + --i] * mul;
    mul *= 0x80;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength);
    return val;
};
Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    if (!(this[offset] & 0x80)) return this[offset];
    return (0xff - this[offset] + 1) * -1;
};
Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    const val = this[offset] | this[offset + 1] << 8;
    return val & 0x8000 ? val | 0xFFFF0000 : val;
};
Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    const val = this[offset + 1] | this[offset] << 8;
    return val & 0x8000 ? val | 0xFFFF0000 : val;
};
Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
};
Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
};
Buffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === undefined || last === undefined) boundsError(offset, this.length - 8);
    const val = this[offset + 4] + this[offset + 5] * 256 + this[offset + 6] * 2 ** 16 + (last << 24 // Overflow
    );
    return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 256 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
});
Buffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === undefined || last === undefined) boundsError(offset, this.length - 8);
    const val = (first << 24) + // Overflow
    this[++offset] * 2 ** 16 + this[++offset] * 256 + this[++offset];
    return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 256 + last);
});
Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, true, 23, 4);
};
Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, false, 23, 4);
};
Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, true, 52, 8);
};
Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, false, 52, 8);
};
function checkInt(buf, value, offset, ext, max, min) {
    if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf.length) throw new RangeError("Index out of range");
}
Buffer.prototype.writeUintLE = Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt(this, value, offset, byteLength, maxBytes, 0);
    }
    let mul = 1;
    let i = 0;
    this[offset] = value & 0xFF;
    while(++i < byteLength && (mul *= 0x100))this[offset + i] = value / mul & 0xFF;
    return offset + byteLength;
};
Buffer.prototype.writeUintBE = Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt(this, value, offset, byteLength, maxBytes, 0);
    }
    let i = byteLength - 1;
    let mul = 1;
    this[offset + i] = value & 0xFF;
    while(--i >= 0 && (mul *= 0x100))this[offset + i] = value / mul & 0xFF;
    return offset + byteLength;
};
Buffer.prototype.writeUint8 = Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
    this[offset] = value & 0xff;
    return offset + 1;
};
Buffer.prototype.writeUint16LE = Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    return offset + 2;
};
Buffer.prototype.writeUint16BE = Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
    return offset + 2;
};
Buffer.prototype.writeUint32LE = Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 0xff;
    return offset + 4;
};
Buffer.prototype.writeUint32BE = Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
    return offset + 4;
};
function wrtBigUInt64LE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(0xffffffff));
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(0xffffffff));
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    return offset;
}
function wrtBigUInt64BE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(0xffffffff));
    buf[offset + 7] = lo;
    lo = lo >> 8;
    buf[offset + 6] = lo;
    lo = lo >> 8;
    buf[offset + 5] = lo;
    lo = lo >> 8;
    buf[offset + 4] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(0xffffffff));
    buf[offset + 3] = hi;
    hi = hi >> 8;
    buf[offset + 2] = hi;
    hi = hi >> 8;
    buf[offset + 1] = hi;
    hi = hi >> 8;
    buf[offset] = hi;
    return offset + 8;
}
Buffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
});
Buffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
});
Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength - 1);
        checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }
    let i = 0;
    let mul = 1;
    let sub = 0;
    this[offset] = value & 0xFF;
    while(++i < byteLength && (mul *= 0x100)){
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) sub = 1;
        this[offset + i] = (value / mul >> 0) - sub & 0xFF;
    }
    return offset + byteLength;
};
Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength - 1);
        checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }
    let i = byteLength - 1;
    let mul = 1;
    let sub = 0;
    this[offset + i] = value & 0xFF;
    while(--i >= 0 && (mul *= 0x100)){
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) sub = 1;
        this[offset + i] = (value / mul >> 0) - sub & 0xFF;
    }
    return offset + byteLength;
};
Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -128);
    if (value < 0) value = 0xff + value + 1;
    this[offset] = value & 0xff;
    return offset + 1;
};
Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -32768);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    return offset + 2;
};
Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -32768);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
    return offset + 2;
};
Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -2147483648);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
    return offset + 4;
};
Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -2147483648);
    if (value < 0) value = 0xffffffff + value + 1;
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
    return offset + 4;
};
Buffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
});
Buffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
});
function checkIEEE754(buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length) throw new RangeError("Index out of range");
    if (offset < 0) throw new RangeError("Index out of range");
}
function writeFloat(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -340282346638528860000000000000000000000);
    ieee754.write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
}
Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
};
Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
};
function writeDouble(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000);
    ieee754.write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
}
Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
};
Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
};
// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy(target, targetStart, start, end) {
    if (!Buffer.isBuffer(target)) throw new TypeError("argument should be a Buffer");
    if (!start) start = 0;
    if (!end && end !== 0) end = this.length;
    if (targetStart >= target.length) targetStart = target.length;
    if (!targetStart) targetStart = 0;
    if (end > 0 && end < start) end = start;
    // Copy 0 bytes; we're done
    if (end === start) return 0;
    if (target.length === 0 || this.length === 0) return 0;
    // Fatal error conditions
    if (targetStart < 0) throw new RangeError("targetStart out of bounds");
    if (start < 0 || start >= this.length) throw new RangeError("Index out of range");
    if (end < 0) throw new RangeError("sourceEnd out of bounds");
    // Are we oob?
    if (end > this.length) end = this.length;
    if (target.length - targetStart < end - start) end = target.length - targetStart + start;
    const len = end - start;
    if (this === target && typeof Uint8Array.prototype.copyWithin === "function") // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end);
    else Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
    return len;
};
// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill(val, start, end, encoding) {
    // Handle string cases:
    if (typeof val === "string") {
        if (typeof start === "string") {
            encoding = start;
            start = 0;
            end = this.length;
        } else if (typeof end === "string") {
            encoding = end;
            end = this.length;
        }
        if (encoding !== undefined && typeof encoding !== "string") throw new TypeError("encoding must be a string");
        if (typeof encoding === "string" && !Buffer.isEncoding(encoding)) throw new TypeError("Unknown encoding: " + encoding);
        if (val.length === 1) {
            const code = val.charCodeAt(0);
            if (encoding === "utf8" && code < 128 || encoding === "latin1") // Fast path: If `val` fits into a single byte, use that numeric value.
            val = code;
        }
    } else if (typeof val === "number") val = val & 255;
    else if (typeof val === "boolean") val = Number(val);
    // Invalid ranges are not set to a default, so can range check early.
    if (start < 0 || this.length < start || this.length < end) throw new RangeError("Out of range index");
    if (end <= start) return this;
    start = start >>> 0;
    end = end === undefined ? this.length : end >>> 0;
    if (!val) val = 0;
    let i;
    if (typeof val === "number") for(i = start; i < end; ++i)this[i] = val;
    else {
        const bytes = Buffer.isBuffer(val) ? val : Buffer.from(val, encoding);
        const len = bytes.length;
        if (len === 0) throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        for(i = 0; i < end - start; ++i)this[i + start] = bytes[i % len];
    }
    return this;
};
// CUSTOM ERRORS
// =============
// Simplified versions from Node, changed for Buffer-only usage
const errors = {};
function E(sym, getMessage, Base) {
    errors[sym] = class NodeError extends Base {
        constructor(){
            super();
            Object.defineProperty(this, "message", {
                value: getMessage.apply(this, arguments),
                writable: true,
                configurable: true
            });
            // Add the error code to the name to include it in the stack trace.
            this.name = `${this.name} [${sym}]`;
            // Access the stack to generate the error message including the error code
            // from the name.
            this.stack // eslint-disable-line no-unused-expressions
            ;
            // Reset the name to the actual name.
            delete this.name;
        }
        get code() {
            return sym;
        }
        set code(value) {
            Object.defineProperty(this, "code", {
                configurable: true,
                enumerable: true,
                value,
                writable: true
            });
        }
        toString() {
            return `${this.name} [${sym}]: ${this.message}`;
        }
    };
}
E("ERR_BUFFER_OUT_OF_BOUNDS", function(name) {
    if (name) return `${name} is outside of buffer bounds`;
    return "Attempt to access memory outside buffer bounds";
}, RangeError);
E("ERR_INVALID_ARG_TYPE", function(name, actual) {
    return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
}, TypeError);
E("ERR_OUT_OF_RANGE", function(str, range, input) {
    let msg = `The value of "${str}" is out of range.`;
    let received = input;
    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) received = addNumericalSeparator(String(input));
    else if (typeof input === "bigint") {
        received = String(input);
        if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) received = addNumericalSeparator(received);
        received += "n";
    }
    msg += ` It must be ${range}. Received ${received}`;
    return msg;
}, RangeError);
function addNumericalSeparator(val) {
    let res = "";
    let i = val.length;
    const start = val[0] === "-" ? 1 : 0;
    for(; i >= start + 4; i -= 3)res = `_${val.slice(i - 3, i)}${res}`;
    return `${val.slice(0, i)}${res}`;
}
// CHECK FUNCTIONS
// ===============
function checkBounds(buf, offset, byteLength) {
    validateNumber(offset, "offset");
    if (buf[offset] === undefined || buf[offset + byteLength] === undefined) boundsError(offset, buf.length - (byteLength + 1));
}
function checkIntBI(value, min, max, buf, offset, byteLength) {
    if (value > max || value < min) {
        const n = typeof min === "bigint" ? "n" : "";
        let range;
        if (byteLength > 3) {
            if (min === 0 || min === BigInt(0)) range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`;
            else range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` + `${(byteLength + 1) * 8 - 1}${n}`;
        } else range = `>= ${min}${n} and <= ${max}${n}`;
        throw new errors.ERR_OUT_OF_RANGE("value", range, value);
    }
    checkBounds(buf, offset, byteLength);
}
function validateNumber(value, name) {
    if (typeof value !== "number") throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
}
function boundsError(value, length, type) {
    if (Math.floor(value) !== value) {
        validateNumber(value, type);
        throw new errors.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
    }
    if (length < 0) throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
    throw new errors.ERR_OUT_OF_RANGE(type || "offset", `>= ${type ? 1 : 0} and <= ${length}`, value);
}
// HELPER FUNCTIONS
// ================
const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
function base64clean(str) {
    // Node takes equal signs as end of the Base64 encoding
    str = str.split("=")[0];
    // Node strips out invalid characters like \n and \t from the string, base64-js does not
    str = str.trim().replace(INVALID_BASE64_RE, "");
    // Node converts strings with length < 2 to ''
    if (str.length < 2) return "";
    // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
    while(str.length % 4 !== 0)str = str + "=";
    return str;
}
function utf8ToBytes(string, units) {
    units = units || Infinity;
    let codePoint;
    const length = string.length;
    let leadSurrogate = null;
    const bytes = [];
    for(let i = 0; i < length; ++i){
        codePoint = string.charCodeAt(i);
        // is surrogate component
        if (codePoint > 0xD7FF && codePoint < 0xE000) {
            // last char was a lead
            if (!leadSurrogate) {
                // no lead yet
                if (codePoint > 0xDBFF) {
                    // unexpected trail
                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                    continue;
                } else if (i + 1 === length) {
                    // unpaired lead
                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                    continue;
                }
                // valid lead
                leadSurrogate = codePoint;
                continue;
            }
            // 2 leads in a row
            if (codePoint < 0xDC00) {
                if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                leadSurrogate = codePoint;
                continue;
            }
            // valid surrogate pair
            codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
        } else if (leadSurrogate) // valid bmp char, but last char was a lead
        {
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        }
        leadSurrogate = null;
        // encode utf8
        if (codePoint < 0x80) {
            if ((units -= 1) < 0) break;
            bytes.push(codePoint);
        } else if (codePoint < 0x800) {
            if ((units -= 2) < 0) break;
            bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
        } else if (codePoint < 0x10000) {
            if ((units -= 3) < 0) break;
            bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
        } else if (codePoint < 0x110000) {
            if ((units -= 4) < 0) break;
            bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
        } else throw new Error("Invalid code point");
    }
    return bytes;
}
function asciiToBytes(str) {
    const byteArray = [];
    for(let i = 0; i < str.length; ++i)// Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF);
    return byteArray;
}
function utf16leToBytes(str, units) {
    let c, hi, lo;
    const byteArray = [];
    for(let i = 0; i < str.length; ++i){
        if ((units -= 2) < 0) break;
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
    }
    return byteArray;
}
function base64ToBytes(str) {
    return base64.toByteArray(base64clean(str));
}
function blitBuffer(src, dst, offset, length) {
    let i;
    for(i = 0; i < length; ++i){
        if (i + offset >= dst.length || i >= src.length) break;
        dst[i + offset] = src[i];
    }
    return i;
}
// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance(obj, type) {
    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
}
function numberIsNaN(obj) {
    // For IE11 support
    return obj !== obj // eslint-disable-line no-self-compare
    ;
}
// Create lookup table for `toString('hex')`
// See: https://github.com/feross/buffer/issues/219
const hexSliceLookupTable = function() {
    const alphabet = "0123456789abcdef";
    const table = new Array(256);
    for(let i = 0; i < 16; ++i){
        const i16 = i * 16;
        for(let j = 0; j < 16; ++j)table[i16 + j] = alphabet[i] + alphabet[j];
    }
    return table;
}();
// Return not function with Error if BigInt not supported
function defineBigIntMethod(fn) {
    return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
}
function BufferBigIntNotDefined() {
    throw new Error("BigInt not supported");
}

},{"9c62938f1dccc73c":"eIiSV","aceacb6a4531a9d2":"cO95r"}],"eIiSV":[function(require,module,exports) {
"use strict";
exports.byteLength = byteLength;
exports.toByteArray = toByteArray;
exports.fromByteArray = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for(var i = 0, len = code.length; i < len; ++i){
    lookup[i] = code[i];
    revLookup[code.charCodeAt(i)] = i;
}
// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup["-".charCodeAt(0)] = 62;
revLookup["_".charCodeAt(0)] = 63;
function getLens(b64) {
    var len = b64.length;
    if (len % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
    // Trim off extra bytes after placeholder bytes are found
    // See: https://github.com/beatgammit/base64-js/issues/42
    var validLen = b64.indexOf("=");
    if (validLen === -1) validLen = len;
    var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
    return [
        validLen,
        placeHoldersLen
    ];
}
// base64 is 4/3 + up to two characters of the original data
function byteLength(b64) {
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function _byteLength(b64, validLen, placeHoldersLen) {
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function toByteArray(b64) {
    var tmp;
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
    var curByte = 0;
    // if there are placeholders, only get up to the last complete 4 chars
    var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
    var i;
    for(i = 0; i < len; i += 4){
        tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
        arr[curByte++] = tmp >> 16 & 0xFF;
        arr[curByte++] = tmp >> 8 & 0xFF;
        arr[curByte++] = tmp & 0xFF;
    }
    if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
        arr[curByte++] = tmp & 0xFF;
    }
    if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 0xFF;
        arr[curByte++] = tmp & 0xFF;
    }
    return arr;
}
function tripletToBase64(num) {
    return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
}
function encodeChunk(uint8, start, end) {
    var tmp;
    var output = [];
    for(var i = start; i < end; i += 3){
        tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);
        output.push(tripletToBase64(tmp));
    }
    return output.join("");
}
function fromByteArray(uint8) {
    var tmp;
    var len = uint8.length;
    var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
    ;
    var parts = [];
    var maxChunkLength = 16383 // must be multiple of 3
    ;
    // go through the array every three bytes, we'll deal with trailing stuff later
    for(var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength)parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
    // pad the end with zeros, but make sure to not forget the extra bytes
    if (extraBytes === 1) {
        tmp = uint8[len - 1];
        parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 0x3F] + "==");
    } else if (extraBytes === 2) {
        tmp = (uint8[len - 2] << 8) + uint8[len - 1];
        parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 0x3F] + lookup[tmp << 2 & 0x3F] + "=");
    }
    return parts.join("");
}

},{}],"cO95r":[function(require,module,exports) {
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */ exports.read = function(buffer, offset, isLE, mLen, nBytes) {
    var e, m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? nBytes - 1 : 0;
    var d = isLE ? -1 : 1;
    var s = buffer[offset + i];
    i += d;
    e = s & (1 << -nBits) - 1;
    s >>= -nBits;
    nBits += eLen;
    for(; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);
    m = e & (1 << -nBits) - 1;
    e >>= -nBits;
    nBits += mLen;
    for(; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);
    if (e === 0) e = 1 - eBias;
    else if (e === eMax) return m ? NaN : (s ? -1 : 1) * Infinity;
    else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};
exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
    var e, m, c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i = isLE ? 0 : nBytes - 1;
    var d = isLE ? 1 : -1;
    var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
    } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
            e--;
            c *= 2;
        }
        if (e + eBias >= 1) value += rt / c;
        else value += rt * Math.pow(2, 1 - eBias);
        if (value * c >= 2) {
            e++;
            c /= 2;
        }
        if (e + eBias >= eMax) {
            m = 0;
            e = eMax;
        } else if (e + eBias >= 1) {
            m = (value * c - 1) * Math.pow(2, mLen);
            e = e + eBias;
        } else {
            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e = 0;
        }
    }
    for(; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);
    e = e << mLen | m;
    eLen += mLen;
    for(; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);
    buffer[offset + i - d] |= s * 128;
};

},{}],"f6cMq":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.hash_to_ristretto255 = exports.hashToRistretto255 = exports.RistrettoPoint = exports.encodeToCurve = exports.hashToCurve = exports.edwardsToMontgomery = exports.x25519 = exports.ed25519ph = exports.ed25519ctx = exports.ed25519 = exports.ED25519_TORSION_SUBGROUP = void 0;
exports.edwardsToMontgomeryPub = edwardsToMontgomeryPub;
exports.edwardsToMontgomeryPriv = edwardsToMontgomeryPriv;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const sha512_1 = require("e1d8ae49624bb2b6");
const utils_1 = require("b762bec9164f6cb8");
const edwards_js_1 = require("8204d40c15abc71d");
const hash_to_curve_js_1 = require("59425f280fcf046f");
const modular_js_1 = require("e20cbf22035770bd");
const montgomery_js_1 = require("efe43c4320fa6488");
const utils_js_1 = require("bbee43b360c61430");
/**
 * ed25519 Twisted Edwards curve with following addons:
 * - X25519 ECDH
 * - Ristretto cofactor elimination
 * - Elligator hash-to-group / point indistinguishability
 */ const ED25519_P = BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949");
// (-1) aka (a) aka 2^((p-1)/4)
const ED25519_SQRT_M1 = /* @__PURE__ */ BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
// prettier-ignore
const _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3);
// prettier-ignore
const _5n = BigInt(5), _8n = BigInt(8);
function ed25519_pow_2_252_3(x) {
    // prettier-ignore
    const _10n = BigInt(10), _20n = BigInt(20), _40n = BigInt(40), _80n = BigInt(80);
    const P = ED25519_P;
    const x2 = x * x % P;
    const b2 = x2 * x % P; // x^3, 11
    const b4 = (0, modular_js_1.pow2)(b2, _2n, P) * b2 % P; // x^15, 1111
    const b5 = (0, modular_js_1.pow2)(b4, _1n, P) * x % P; // x^31
    const b10 = (0, modular_js_1.pow2)(b5, _5n, P) * b5 % P;
    const b20 = (0, modular_js_1.pow2)(b10, _10n, P) * b10 % P;
    const b40 = (0, modular_js_1.pow2)(b20, _20n, P) * b20 % P;
    const b80 = (0, modular_js_1.pow2)(b40, _40n, P) * b40 % P;
    const b160 = (0, modular_js_1.pow2)(b80, _80n, P) * b80 % P;
    const b240 = (0, modular_js_1.pow2)(b160, _80n, P) * b80 % P;
    const b250 = (0, modular_js_1.pow2)(b240, _10n, P) * b10 % P;
    const pow_p_5_8 = (0, modular_js_1.pow2)(b250, _2n, P) * x % P;
    // ^ To pow to (p+3)/8, multiply it by x.
    return {
        pow_p_5_8,
        b2
    };
}
function adjustScalarBytes(bytes) {
    // Section 5: For X25519, in order to decode 32 random bytes as an integer scalar,
    // set the three least significant bits of the first byte
    bytes[0] &= 248; // 0b1111_1000
    // and the most significant bit of the last to zero,
    bytes[31] &= 127; // 0b0111_1111
    // set the second most significant bit of the last byte to 1
    bytes[31] |= 64; // 0b0100_0000
    return bytes;
}
// sqrt(u/v)
function uvRatio(u, v) {
    const P = ED25519_P;
    const v3 = (0, modular_js_1.mod)(v * v * v, P); // v
    const v7 = (0, modular_js_1.mod)(v3 * v3 * v, P); // v
    // (p+3)/8 and (p-5)/8
    const pow = ed25519_pow_2_252_3(u * v7).pow_p_5_8;
    let x = (0, modular_js_1.mod)(u * v3 * pow, P); // (uv)(uv)^(p-5)/8
    const vx2 = (0, modular_js_1.mod)(v * x * x, P); // vx
    const root1 = x; // First root candidate
    const root2 = (0, modular_js_1.mod)(x * ED25519_SQRT_M1, P); // Second root candidate
    const useRoot1 = vx2 === u; // If vx = u (mod p), x is a square root
    const useRoot2 = vx2 === (0, modular_js_1.mod)(-u, P); // If vx = -u, set x <-- x * 2^((p-1)/4)
    const noRoot = vx2 === (0, modular_js_1.mod)(-u * ED25519_SQRT_M1, P); // There is no valid root, vx = -u(-1)
    if (useRoot1) x = root1;
    if (useRoot2 || noRoot) x = root2; // We return root2 anyway, for const-time
    if ((0, modular_js_1.isNegativeLE)(x, P)) x = (0, modular_js_1.mod)(-x, P);
    return {
        isValid: useRoot1 || useRoot2,
        value: x
    };
}
// Just in case
exports.ED25519_TORSION_SUBGROUP = [
    "0100000000000000000000000000000000000000000000000000000000000000",
    "c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a",
    "0000000000000000000000000000000000000000000000000000000000000080",
    "26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05",
    "ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f",
    "26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85",
    "0000000000000000000000000000000000000000000000000000000000000000",
    "c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa"
];
const Fp = /* @__PURE__ */ (()=>(0, modular_js_1.Field)(ED25519_P, undefined, true))();
const ed25519Defaults = /* @__PURE__ */ (()=>({
        // Param: a
        a: BigInt(-1),
        // d is equal to -121665/121666 over finite field.
        // Negative number is P - number, and division is invert(number, P)
        d: BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),
        // Finite field p over which we'll do calculations; 2n**255n - 19n
        Fp,
        // Subgroup order: how many points curve has
        // 2n**252n + 27742317777372353535851937790883648493n;
        n: BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),
        // Cofactor
        h: _8n,
        // Base point (x, y) aka generator point
        Gx: BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),
        Gy: BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"),
        hash: sha512_1.sha512,
        randomBytes: utils_1.randomBytes,
        adjustScalarBytes,
        // dom2
        // Ratio of u to v. Allows us to combine inversion and square root. Uses algo from RFC8032 5.1.3.
        // Constant-time, u/v
        uvRatio
    }))();
/**
 * ed25519 curve with EdDSA signatures.
 */ exports.ed25519 = (()=>(0, edwards_js_1.twistedEdwards)(ed25519Defaults))();
function ed25519_domain(data, ctx, phflag) {
    if (ctx.length > 255) throw new Error("Context is too big");
    return (0, utils_1.concatBytes)((0, utils_1.utf8ToBytes)("SigEd25519 no Ed25519 collisions"), new Uint8Array([
        phflag ? 1 : 0,
        ctx.length
    ]), ctx, data);
}
exports.ed25519ctx = (()=>(0, edwards_js_1.twistedEdwards)({
        ...ed25519Defaults,
        domain: ed25519_domain
    }))();
exports.ed25519ph = (()=>(0, edwards_js_1.twistedEdwards)(Object.assign({}, ed25519Defaults, {
        domain: ed25519_domain,
        prehash: sha512_1.sha512
    })))();
exports.x25519 = (()=>(0, montgomery_js_1.montgomery)({
        P: ED25519_P,
        a: BigInt(486662),
        montgomeryBits: 255,
        nByteLength: 32,
        Gu: BigInt(9),
        powPminus2: (x)=>{
            const P = ED25519_P;
            // x^(p-2) aka x^(2^255-21)
            const { pow_p_5_8, b2 } = ed25519_pow_2_252_3(x);
            return (0, modular_js_1.mod)((0, modular_js_1.pow2)(pow_p_5_8, _3n, P) * b2, P);
        },
        adjustScalarBytes,
        randomBytes: utils_1.randomBytes
    }))();
/**
 * Converts ed25519 public key to x25519 public key. Uses formula:
 * * `(u, v) = ((1+y)/(1-y), sqrt(-486664)*u/x)`
 * * `(x, y) = (sqrt(-486664)*u/v, (u-1)/(u+1))`
 * @example
 *   const someonesPub = ed25519.getPublicKey(ed25519.utils.randomPrivateKey());
 *   const aPriv = x25519.utils.randomPrivateKey();
 *   x25519.getSharedSecret(aPriv, edwardsToMontgomeryPub(someonesPub))
 */ function edwardsToMontgomeryPub(edwardsPub) {
    const { y } = exports.ed25519.ExtendedPoint.fromHex(edwardsPub);
    const _1n = BigInt(1);
    return Fp.toBytes(Fp.create((_1n + y) * Fp.inv(_1n - y)));
}
exports.edwardsToMontgomery = edwardsToMontgomeryPub; // deprecated
/**
 * Converts ed25519 secret key to x25519 secret key.
 * @example
 *   const someonesPub = x25519.getPublicKey(x25519.utils.randomPrivateKey());
 *   const aPriv = ed25519.utils.randomPrivateKey();
 *   x25519.getSharedSecret(edwardsToMontgomeryPriv(aPriv), someonesPub)
 */ function edwardsToMontgomeryPriv(edwardsPriv) {
    const hashed = ed25519Defaults.hash(edwardsPriv.subarray(0, 32));
    return ed25519Defaults.adjustScalarBytes(hashed).subarray(0, 32);
}
// Hash To Curve Elligator2 Map (NOTE: different from ristretto255 elligator)
// NOTE: very important part is usage of FpSqrtEven for ELL2_C1_EDWARDS, since
// SageMath returns different root first and everything falls apart
const ELL2_C1 = /* @__PURE__ */ (()=>(Fp.ORDER + _3n) / _8n)(); // 1. c1 = (q + 3) / 8       # Integer arithmetic
const ELL2_C2 = /* @__PURE__ */ (()=>Fp.pow(_2n, ELL2_C1))(); // 2. c2 = 2^c1
const ELL2_C3 = /* @__PURE__ */ (()=>Fp.sqrt(Fp.neg(Fp.ONE)))(); // 3. c3 = sqrt(-1)
// prettier-ignore
function map_to_curve_elligator2_curve25519(u) {
    const ELL2_C4 = (Fp.ORDER - _5n) / _8n; // 4. c4 = (q - 5) / 8       # Integer arithmetic
    const ELL2_J = BigInt(486662);
    let tv1 = Fp.sqr(u); //  1.  tv1 = u^2
    tv1 = Fp.mul(tv1, _2n); //  2.  tv1 = 2 * tv1
    let xd = Fp.add(tv1, Fp.ONE); //  3.   xd = tv1 + 1         # Nonzero: -1 is square (mod p), tv1 is not
    let x1n = Fp.neg(ELL2_J); //  4.  x1n = -J              # x1 = x1n / xd = -J / (1 + 2 * u^2)
    let tv2 = Fp.sqr(xd); //  5.  tv2 = xd^2
    let gxd = Fp.mul(tv2, xd); //  6.  gxd = tv2 * xd        # gxd = xd^3
    let gx1 = Fp.mul(tv1, ELL2_J); //  7.  gx1 = J * tv1         # x1n + J * xd
    gx1 = Fp.mul(gx1, x1n); //  8.  gx1 = gx1 * x1n       # x1n^2 + J * x1n * xd
    gx1 = Fp.add(gx1, tv2); //  9.  gx1 = gx1 + tv2       # x1n^2 + J * x1n * xd + xd^2
    gx1 = Fp.mul(gx1, x1n); //  10. gx1 = gx1 * x1n       # x1n^3 + J * x1n^2 * xd + x1n * xd^2
    let tv3 = Fp.sqr(gxd); //  11. tv3 = gxd^2
    tv2 = Fp.sqr(tv3); //  12. tv2 = tv3^2           # gxd^4
    tv3 = Fp.mul(tv3, gxd); //  13. tv3 = tv3 * gxd       # gxd^3
    tv3 = Fp.mul(tv3, gx1); //  14. tv3 = tv3 * gx1       # gx1 * gxd^3
    tv2 = Fp.mul(tv2, tv3); //  15. tv2 = tv2 * tv3       # gx1 * gxd^7
    let y11 = Fp.pow(tv2, ELL2_C4); //  16. y11 = tv2^c4        # (gx1 * gxd^7)^((p - 5) / 8)
    y11 = Fp.mul(y11, tv3); //  17. y11 = y11 * tv3       # gx1*gxd^3*(gx1*gxd^7)^((p-5)/8)
    let y12 = Fp.mul(y11, ELL2_C3); //  18. y12 = y11 * c3
    tv2 = Fp.sqr(y11); //  19. tv2 = y11^2
    tv2 = Fp.mul(tv2, gxd); //  20. tv2 = tv2 * gxd
    let e1 = Fp.eql(tv2, gx1); //  21.  e1 = tv2 == gx1
    let y1 = Fp.cmov(y12, y11, e1); //  22.  y1 = CMOV(y12, y11, e1)  # If g(x1) is square, this is its sqrt
    let x2n = Fp.mul(x1n, tv1); //  23. x2n = x1n * tv1       # x2 = x2n / xd = 2 * u^2 * x1n / xd
    let y21 = Fp.mul(y11, u); //  24. y21 = y11 * u
    y21 = Fp.mul(y21, ELL2_C2); //  25. y21 = y21 * c2
    let y22 = Fp.mul(y21, ELL2_C3); //  26. y22 = y21 * c3
    let gx2 = Fp.mul(gx1, tv1); //  27. gx2 = gx1 * tv1       # g(x2) = gx2 / gxd = 2 * u^2 * g(x1)
    tv2 = Fp.sqr(y21); //  28. tv2 = y21^2
    tv2 = Fp.mul(tv2, gxd); //  29. tv2 = tv2 * gxd
    let e2 = Fp.eql(tv2, gx2); //  30.  e2 = tv2 == gx2
    let y2 = Fp.cmov(y22, y21, e2); //  31.  y2 = CMOV(y22, y21, e2)  # If g(x2) is square, this is its sqrt
    tv2 = Fp.sqr(y1); //  32. tv2 = y1^2
    tv2 = Fp.mul(tv2, gxd); //  33. tv2 = tv2 * gxd
    let e3 = Fp.eql(tv2, gx1); //  34.  e3 = tv2 == gx1
    let xn = Fp.cmov(x2n, x1n, e3); //  35.  xn = CMOV(x2n, x1n, e3)  # If e3, x = x1, else x = x2
    let y = Fp.cmov(y2, y1, e3); //  36.   y = CMOV(y2, y1, e3)    # If e3, y = y1, else y = y2
    let e4 = Fp.isOdd(y); //  37.  e4 = sgn0(y) == 1        # Fix sign of y
    y = Fp.cmov(y, Fp.neg(y), e3 !== e4); //  38.   y = CMOV(y, -y, e3 XOR e4)
    return {
        xMn: xn,
        xMd: xd,
        yMn: y,
        yMd: _1n
    }; //  39. return (xn, xd, y, 1)
}
const ELL2_C1_EDWARDS = /* @__PURE__ */ (()=>(0, modular_js_1.FpSqrtEven)(Fp, Fp.neg(BigInt(486664))))(); // sgn0(c1) MUST equal 0
function map_to_curve_elligator2_edwards25519(u) {
    const { xMn, xMd, yMn, yMd } = map_to_curve_elligator2_curve25519(u); //  1.  (xMn, xMd, yMn, yMd) =
    // map_to_curve_elligator2_curve25519(u)
    let xn = Fp.mul(xMn, yMd); //  2.  xn = xMn * yMd
    xn = Fp.mul(xn, ELL2_C1_EDWARDS); //  3.  xn = xn * c1
    let xd = Fp.mul(xMd, yMn); //  4.  xd = xMd * yMn    # xn / xd = c1 * xM / yM
    let yn = Fp.sub(xMn, xMd); //  5.  yn = xMn - xMd
    let yd = Fp.add(xMn, xMd); //  6.  yd = xMn + xMd    # (n / d - 1) / (n / d + 1) = (n - d) / (n + d)
    let tv1 = Fp.mul(xd, yd); //  7. tv1 = xd * yd
    let e = Fp.eql(tv1, Fp.ZERO); //  8.   e = tv1 == 0
    xn = Fp.cmov(xn, Fp.ZERO, e); //  9.  xn = CMOV(xn, 0, e)
    xd = Fp.cmov(xd, Fp.ONE, e); //  10. xd = CMOV(xd, 1, e)
    yn = Fp.cmov(yn, Fp.ONE, e); //  11. yn = CMOV(yn, 1, e)
    yd = Fp.cmov(yd, Fp.ONE, e); //  12. yd = CMOV(yd, 1, e)
    const inv = Fp.invertBatch([
        xd,
        yd
    ]); // batch division
    return {
        x: Fp.mul(xn, inv[0]),
        y: Fp.mul(yn, inv[1])
    }; //  13. return (xn, xd, yn, yd)
}
const htf = /* @__PURE__ */ (()=>(0, hash_to_curve_js_1.createHasher)(exports.ed25519.ExtendedPoint, (scalars)=>map_to_curve_elligator2_edwards25519(scalars[0]), {
        DST: "edwards25519_XMD:SHA-512_ELL2_RO_",
        encodeDST: "edwards25519_XMD:SHA-512_ELL2_NU_",
        p: Fp.ORDER,
        m: 1,
        k: 128,
        expand: "xmd",
        hash: sha512_1.sha512
    }))();
exports.hashToCurve = (()=>htf.hashToCurve)();
exports.encodeToCurve = (()=>htf.encodeToCurve)();
function assertRstPoint(other) {
    if (!(other instanceof RistPoint)) throw new Error("RistrettoPoint expected");
}
// (-1) aka (a) aka 2^((p-1)/4)
const SQRT_M1 = ED25519_SQRT_M1;
// (ad - 1)
const SQRT_AD_MINUS_ONE = /* @__PURE__ */ BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235");
// 1 / (a-d)
const INVSQRT_A_MINUS_D = /* @__PURE__ */ BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578");
// 1-d
const ONE_MINUS_D_SQ = /* @__PURE__ */ BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838");
// (d-1)
const D_MINUS_ONE_SQ = /* @__PURE__ */ BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952");
// Calculates 1/(number)
const invertSqrt = (number)=>uvRatio(_1n, number);
const MAX_255B = /* @__PURE__ */ BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
const bytes255ToNumberLE = (bytes)=>exports.ed25519.CURVE.Fp.create((0, utils_js_1.bytesToNumberLE)(bytes) & MAX_255B);
// Computes Elligator map for Ristretto
// https://ristretto.group/formulas/elligator.html
function calcElligatorRistrettoMap(r0) {
    const { d } = exports.ed25519.CURVE;
    const P = exports.ed25519.CURVE.Fp.ORDER;
    const mod = exports.ed25519.CURVE.Fp.create;
    const r = mod(SQRT_M1 * r0 * r0); // 1
    const Ns = mod((r + _1n) * ONE_MINUS_D_SQ); // 2
    let c = BigInt(-1); // 3
    const D = mod((c - d * r) * mod(r + d)); // 4
    let { isValid: Ns_D_is_sq, value: s } = uvRatio(Ns, D); // 5
    let s_ = mod(s * r0); // 6
    if (!(0, modular_js_1.isNegativeLE)(s_, P)) s_ = mod(-s_);
    if (!Ns_D_is_sq) s = s_; // 7
    if (!Ns_D_is_sq) c = r; // 8
    const Nt = mod(c * (r - _1n) * D_MINUS_ONE_SQ - D); // 9
    const s2 = s * s;
    const W0 = mod((s + s) * D); // 10
    const W1 = mod(Nt * SQRT_AD_MINUS_ONE); // 11
    const W2 = mod(_1n - s2); // 12
    const W3 = mod(_1n + s2); // 13
    return new exports.ed25519.ExtendedPoint(mod(W0 * W3), mod(W2 * W1), mod(W1 * W3), mod(W0 * W2));
}
/**
 * Each ed25519/ExtendedPoint has 8 different equivalent points. This can be
 * a source of bugs for protocols like ring signatures. Ristretto was created to solve this.
 * Ristretto point operates in X:Y:Z:T extended coordinates like ExtendedPoint,
 * but it should work in its own namespace: do not combine those two.
 * https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-ristretto255-decaf448
 */ class RistPoint {
    // Private property to discourage combining ExtendedPoint + RistrettoPoint
    // Always use Ristretto encoding/decoding instead.
    constructor(ep){
        this.ep = ep;
    }
    static fromAffine(ap) {
        return new RistPoint(exports.ed25519.ExtendedPoint.fromAffine(ap));
    }
    /**
     * Takes uniform output of 64-byte hash function like sha512 and converts it to `RistrettoPoint`.
     * The hash-to-group operation applies Elligator twice and adds the results.
     * **Note:** this is one-way map, there is no conversion from point to hash.
     * https://ristretto.group/formulas/elligator.html
     * @param hex 64-byte output of a hash function
     */ static hashToCurve(hex) {
        hex = (0, utils_js_1.ensureBytes)("ristrettoHash", hex, 64);
        const r1 = bytes255ToNumberLE(hex.slice(0, 32));
        const R1 = calcElligatorRistrettoMap(r1);
        const r2 = bytes255ToNumberLE(hex.slice(32, 64));
        const R2 = calcElligatorRistrettoMap(r2);
        return new RistPoint(R1.add(R2));
    }
    /**
     * Converts ristretto-encoded string to ristretto point.
     * https://ristretto.group/formulas/decoding.html
     * @param hex Ristretto-encoded 32 bytes. Not every 32-byte string is valid ristretto encoding
     */ static fromHex(hex) {
        hex = (0, utils_js_1.ensureBytes)("ristrettoHex", hex, 32);
        const { a, d } = exports.ed25519.CURVE;
        const P = exports.ed25519.CURVE.Fp.ORDER;
        const mod = exports.ed25519.CURVE.Fp.create;
        const emsg = "RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint";
        const s = bytes255ToNumberLE(hex);
        // 1. Check that s_bytes is the canonical encoding of a field element, or else abort.
        // 3. Check that s is non-negative, or else abort
        if (!(0, utils_js_1.equalBytes)((0, utils_js_1.numberToBytesLE)(s, 32), hex) || (0, modular_js_1.isNegativeLE)(s, P)) throw new Error(emsg);
        const s2 = mod(s * s);
        const u1 = mod(_1n + a * s2); // 4 (a is -1)
        const u2 = mod(_1n - a * s2); // 5
        const u1_2 = mod(u1 * u1);
        const u2_2 = mod(u2 * u2);
        const v = mod(a * d * u1_2 - u2_2); // 6
        const { isValid, value: I } = invertSqrt(mod(v * u2_2)); // 7
        const Dx = mod(I * u2); // 8
        const Dy = mod(I * Dx * v); // 9
        let x = mod((s + s) * Dx); // 10
        if ((0, modular_js_1.isNegativeLE)(x, P)) x = mod(-x); // 10
        const y = mod(u1 * Dy); // 11
        const t = mod(x * y); // 12
        if (!isValid || (0, modular_js_1.isNegativeLE)(t, P) || y === _0n) throw new Error(emsg);
        return new RistPoint(new exports.ed25519.ExtendedPoint(x, y, _1n, t));
    }
    /**
     * Encodes ristretto point to Uint8Array.
     * https://ristretto.group/formulas/encoding.html
     */ toRawBytes() {
        let { ex: x, ey: y, ez: z, et: t } = this.ep;
        const P = exports.ed25519.CURVE.Fp.ORDER;
        const mod = exports.ed25519.CURVE.Fp.create;
        const u1 = mod(mod(z + y) * mod(z - y)); // 1
        const u2 = mod(x * y); // 2
        // Square root always exists
        const u2sq = mod(u2 * u2);
        const { value: invsqrt } = invertSqrt(mod(u1 * u2sq)); // 3
        const D1 = mod(invsqrt * u1); // 4
        const D2 = mod(invsqrt * u2); // 5
        const zInv = mod(D1 * D2 * t); // 6
        let D; // 7
        if ((0, modular_js_1.isNegativeLE)(t * zInv, P)) {
            let _x = mod(y * SQRT_M1);
            let _y = mod(x * SQRT_M1);
            x = _x;
            y = _y;
            D = mod(D1 * INVSQRT_A_MINUS_D);
        } else D = D2; // 8
        if ((0, modular_js_1.isNegativeLE)(x * zInv, P)) y = mod(-y); // 9
        let s = mod((z - y) * D); // 10 (check footer's note, no sqrt(-a))
        if ((0, modular_js_1.isNegativeLE)(s, P)) s = mod(-s);
        return (0, utils_js_1.numberToBytesLE)(s, 32); // 11
    }
    toHex() {
        return (0, utils_js_1.bytesToHex)(this.toRawBytes());
    }
    toString() {
        return this.toHex();
    }
    // Compare one point to another.
    equals(other) {
        assertRstPoint(other);
        const { ex: X1, ey: Y1 } = this.ep;
        const { ex: X2, ey: Y2 } = other.ep;
        const mod = exports.ed25519.CURVE.Fp.create;
        // (x1 * y2 == y1 * x2) | (y1 * y2 == x1 * x2)
        const one = mod(X1 * Y2) === mod(Y1 * X2);
        const two = mod(Y1 * Y2) === mod(X1 * X2);
        return one || two;
    }
    add(other) {
        assertRstPoint(other);
        return new RistPoint(this.ep.add(other.ep));
    }
    subtract(other) {
        assertRstPoint(other);
        return new RistPoint(this.ep.subtract(other.ep));
    }
    multiply(scalar) {
        return new RistPoint(this.ep.multiply(scalar));
    }
    multiplyUnsafe(scalar) {
        return new RistPoint(this.ep.multiplyUnsafe(scalar));
    }
    double() {
        return new RistPoint(this.ep.double());
    }
    negate() {
        return new RistPoint(this.ep.negate());
    }
}
exports.RistrettoPoint = (()=>{
    if (!RistPoint.BASE) RistPoint.BASE = new RistPoint(exports.ed25519.ExtendedPoint.BASE);
    if (!RistPoint.ZERO) RistPoint.ZERO = new RistPoint(exports.ed25519.ExtendedPoint.ZERO);
    return RistPoint;
})();
// Hashing to ristretto255. https://www.rfc-editor.org/rfc/rfc9380#appendix-B
const hashToRistretto255 = (msg, options)=>{
    const d = options.DST;
    const DST = typeof d === "string" ? (0, utils_1.utf8ToBytes)(d) : d;
    const uniform_bytes = (0, hash_to_curve_js_1.expand_message_xmd)(msg, DST, 64, sha512_1.sha512);
    const P = RistPoint.hashToCurve(uniform_bytes);
    return P;
};
exports.hashToRistretto255 = hashToRistretto255;
exports.hash_to_ristretto255 = exports.hashToRistretto255; // legacy

},{"e1d8ae49624bb2b6":"jlH7E","b762bec9164f6cb8":"2ehgp","8204d40c15abc71d":"hYY6w","59425f280fcf046f":"2yuJj","e20cbf22035770bd":"cB5Z5","efe43c4320fa6488":"kbKg4","bbee43b360c61430":"cBmkf"}],"jlH7E":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.sha384 = exports.sha512_256 = exports.sha512_224 = exports.sha512 = exports.SHA384 = exports.SHA512_256 = exports.SHA512_224 = exports.SHA512 = void 0;
const _md_js_1 = require("7560457f92e48ccb");
const _u64_js_1 = require("eda9289ed6a1f5f2");
const utils_js_1 = require("f18acd6c798648cc");
// Round contants (first 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409):
// prettier-ignore
const [SHA512_Kh, SHA512_Kl] = /* @__PURE__ */ (()=>_u64_js_1.default.split([
        "0x428a2f98d728ae22",
        "0x7137449123ef65cd",
        "0xb5c0fbcfec4d3b2f",
        "0xe9b5dba58189dbbc",
        "0x3956c25bf348b538",
        "0x59f111f1b605d019",
        "0x923f82a4af194f9b",
        "0xab1c5ed5da6d8118",
        "0xd807aa98a3030242",
        "0x12835b0145706fbe",
        "0x243185be4ee4b28c",
        "0x550c7dc3d5ffb4e2",
        "0x72be5d74f27b896f",
        "0x80deb1fe3b1696b1",
        "0x9bdc06a725c71235",
        "0xc19bf174cf692694",
        "0xe49b69c19ef14ad2",
        "0xefbe4786384f25e3",
        "0x0fc19dc68b8cd5b5",
        "0x240ca1cc77ac9c65",
        "0x2de92c6f592b0275",
        "0x4a7484aa6ea6e483",
        "0x5cb0a9dcbd41fbd4",
        "0x76f988da831153b5",
        "0x983e5152ee66dfab",
        "0xa831c66d2db43210",
        "0xb00327c898fb213f",
        "0xbf597fc7beef0ee4",
        "0xc6e00bf33da88fc2",
        "0xd5a79147930aa725",
        "0x06ca6351e003826f",
        "0x142929670a0e6e70",
        "0x27b70a8546d22ffc",
        "0x2e1b21385c26c926",
        "0x4d2c6dfc5ac42aed",
        "0x53380d139d95b3df",
        "0x650a73548baf63de",
        "0x766a0abb3c77b2a8",
        "0x81c2c92e47edaee6",
        "0x92722c851482353b",
        "0xa2bfe8a14cf10364",
        "0xa81a664bbc423001",
        "0xc24b8b70d0f89791",
        "0xc76c51a30654be30",
        "0xd192e819d6ef5218",
        "0xd69906245565a910",
        "0xf40e35855771202a",
        "0x106aa07032bbd1b8",
        "0x19a4c116b8d2d0c8",
        "0x1e376c085141ab53",
        "0x2748774cdf8eeb99",
        "0x34b0bcb5e19b48a8",
        "0x391c0cb3c5c95a63",
        "0x4ed8aa4ae3418acb",
        "0x5b9cca4f7763e373",
        "0x682e6ff3d6b2b8a3",
        "0x748f82ee5defb2fc",
        "0x78a5636f43172f60",
        "0x84c87814a1f0ab72",
        "0x8cc702081a6439ec",
        "0x90befffa23631e28",
        "0xa4506cebde82bde9",
        "0xbef9a3f7b2c67915",
        "0xc67178f2e372532b",
        "0xca273eceea26619c",
        "0xd186b8c721c0c207",
        "0xeada7dd6cde0eb1e",
        "0xf57d4f7fee6ed178",
        "0x06f067aa72176fba",
        "0x0a637dc5a2c898a6",
        "0x113f9804bef90dae",
        "0x1b710b35131c471b",
        "0x28db77f523047d84",
        "0x32caab7b40c72493",
        "0x3c9ebe0a15c9bebc",
        "0x431d67c49c100d4c",
        "0x4cc5d4becb3e42b6",
        "0x597f299cfc657e2a",
        "0x5fcb6fab3ad6faec",
        "0x6c44198c4a475817"
    ].map((n)=>BigInt(n))))();
// Temporary buffer, not used to store anything between runs
const SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);
const SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);
class SHA512 extends _md_js_1.HashMD {
    constructor(){
        super(128, 64, 16, false);
        // We cannot use array here since array allows indexing by variable which means optimizer/compiler cannot use registers.
        // Also looks cleaner and easier to verify with spec.
        // Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):
        // h -- high 32 bits, l -- low 32 bits
        this.Ah = 1779033703;
        this.Al = -205731576;
        this.Bh = -1150833019;
        this.Bl = -2067093701;
        this.Ch = 1013904242;
        this.Cl = -23791573;
        this.Dh = -1521486534;
        this.Dl = 1595750129;
        this.Eh = 1359893119;
        this.El = -1377402159;
        this.Fh = -1694144372;
        this.Fl = 725511199;
        this.Gh = 528734635;
        this.Gl = -79577749;
        this.Hh = 1541459225;
        this.Hl = 327033209;
    }
    // prettier-ignore
    get() {
        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
        return [
            Ah,
            Al,
            Bh,
            Bl,
            Ch,
            Cl,
            Dh,
            Dl,
            Eh,
            El,
            Fh,
            Fl,
            Gh,
            Gl,
            Hh,
            Hl
        ];
    }
    // prettier-ignore
    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
        this.Ah = Ah | 0;
        this.Al = Al | 0;
        this.Bh = Bh | 0;
        this.Bl = Bl | 0;
        this.Ch = Ch | 0;
        this.Cl = Cl | 0;
        this.Dh = Dh | 0;
        this.Dl = Dl | 0;
        this.Eh = Eh | 0;
        this.El = El | 0;
        this.Fh = Fh | 0;
        this.Fl = Fl | 0;
        this.Gh = Gh | 0;
        this.Gl = Gl | 0;
        this.Hh = Hh | 0;
        this.Hl = Hl | 0;
    }
    process(view, offset) {
        // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array
        for(let i = 0; i < 16; i++, offset += 4){
            SHA512_W_H[i] = view.getUint32(offset);
            SHA512_W_L[i] = view.getUint32(offset += 4);
        }
        for(let i = 16; i < 80; i++){
            // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)
            const W15h = SHA512_W_H[i - 15] | 0;
            const W15l = SHA512_W_L[i - 15] | 0;
            const s0h = _u64_js_1.default.rotrSH(W15h, W15l, 1) ^ _u64_js_1.default.rotrSH(W15h, W15l, 8) ^ _u64_js_1.default.shrSH(W15h, W15l, 7);
            const s0l = _u64_js_1.default.rotrSL(W15h, W15l, 1) ^ _u64_js_1.default.rotrSL(W15h, W15l, 8) ^ _u64_js_1.default.shrSL(W15h, W15l, 7);
            // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)
            const W2h = SHA512_W_H[i - 2] | 0;
            const W2l = SHA512_W_L[i - 2] | 0;
            const s1h = _u64_js_1.default.rotrSH(W2h, W2l, 19) ^ _u64_js_1.default.rotrBH(W2h, W2l, 61) ^ _u64_js_1.default.shrSH(W2h, W2l, 6);
            const s1l = _u64_js_1.default.rotrSL(W2h, W2l, 19) ^ _u64_js_1.default.rotrBL(W2h, W2l, 61) ^ _u64_js_1.default.shrSL(W2h, W2l, 6);
            // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];
            const SUMl = _u64_js_1.default.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);
            const SUMh = _u64_js_1.default.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);
            SHA512_W_H[i] = SUMh | 0;
            SHA512_W_L[i] = SUMl | 0;
        }
        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
        // Compression function main loop, 80 rounds
        for(let i = 0; i < 80; i++){
            // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)
            const sigma1h = _u64_js_1.default.rotrSH(Eh, El, 14) ^ _u64_js_1.default.rotrSH(Eh, El, 18) ^ _u64_js_1.default.rotrBH(Eh, El, 41);
            const sigma1l = _u64_js_1.default.rotrSL(Eh, El, 14) ^ _u64_js_1.default.rotrSL(Eh, El, 18) ^ _u64_js_1.default.rotrBL(Eh, El, 41);
            //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;
            const CHIh = Eh & Fh ^ ~Eh & Gh;
            const CHIl = El & Fl ^ ~El & Gl;
            // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]
            // prettier-ignore
            const T1ll = _u64_js_1.default.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);
            const T1h = _u64_js_1.default.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);
            const T1l = T1ll | 0;
            // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)
            const sigma0h = _u64_js_1.default.rotrSH(Ah, Al, 28) ^ _u64_js_1.default.rotrBH(Ah, Al, 34) ^ _u64_js_1.default.rotrBH(Ah, Al, 39);
            const sigma0l = _u64_js_1.default.rotrSL(Ah, Al, 28) ^ _u64_js_1.default.rotrBL(Ah, Al, 34) ^ _u64_js_1.default.rotrBL(Ah, Al, 39);
            const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
            const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
            Hh = Gh | 0;
            Hl = Gl | 0;
            Gh = Fh | 0;
            Gl = Fl | 0;
            Fh = Eh | 0;
            Fl = El | 0;
            ({ h: Eh, l: El } = _u64_js_1.default.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
            Dh = Ch | 0;
            Dl = Cl | 0;
            Ch = Bh | 0;
            Cl = Bl | 0;
            Bh = Ah | 0;
            Bl = Al | 0;
            const All = _u64_js_1.default.add3L(T1l, sigma0l, MAJl);
            Ah = _u64_js_1.default.add3H(All, T1h, sigma0h, MAJh);
            Al = All | 0;
        }
        // Add the compressed chunk to the current hash value
        ({ h: Ah, l: Al } = _u64_js_1.default.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
        ({ h: Bh, l: Bl } = _u64_js_1.default.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
        ({ h: Ch, l: Cl } = _u64_js_1.default.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
        ({ h: Dh, l: Dl } = _u64_js_1.default.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
        ({ h: Eh, l: El } = _u64_js_1.default.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
        ({ h: Fh, l: Fl } = _u64_js_1.default.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
        ({ h: Gh, l: Gl } = _u64_js_1.default.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
        ({ h: Hh, l: Hl } = _u64_js_1.default.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
    }
    roundClean() {
        SHA512_W_H.fill(0);
        SHA512_W_L.fill(0);
    }
    destroy() {
        this.buffer.fill(0);
        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    }
}
exports.SHA512 = SHA512;
class SHA512_224 extends SHA512 {
    constructor(){
        super();
        // h -- high 32 bits, l -- low 32 bits
        this.Ah = -1942145080;
        this.Al = 424955298;
        this.Bh = 1944164710;
        this.Bl = -1982016298;
        this.Ch = 502970286;
        this.Cl = 855612546;
        this.Dh = 1738396948;
        this.Dl = 1479516111;
        this.Eh = 258812777;
        this.El = 2077511080;
        this.Fh = 2011393907;
        this.Fl = 79989058;
        this.Gh = 1067287976;
        this.Gl = 1780299464;
        this.Hh = 286451373;
        this.Hl = -1848208735;
        this.outputLen = 28;
    }
}
exports.SHA512_224 = SHA512_224;
class SHA512_256 extends SHA512 {
    constructor(){
        super();
        // h -- high 32 bits, l -- low 32 bits
        this.Ah = 573645204;
        this.Al = -64227540;
        this.Bh = -1621794909;
        this.Bl = -934517566;
        this.Ch = 596883563;
        this.Cl = 1867755857;
        this.Dh = -1774684391;
        this.Dl = 1497426621;
        this.Eh = -1775747358;
        this.El = -1467023389;
        this.Fh = -1101128155;
        this.Fl = 1401305490;
        this.Gh = 721525244;
        this.Gl = 746961066;
        this.Hh = 246885852;
        this.Hl = -2117784414;
        this.outputLen = 32;
    }
}
exports.SHA512_256 = SHA512_256;
class SHA384 extends SHA512 {
    constructor(){
        super();
        // h -- high 32 bits, l -- low 32 bits
        this.Ah = -876896931;
        this.Al = -1056596264;
        this.Bh = 1654270250;
        this.Bl = 914150663;
        this.Ch = -1856437926;
        this.Cl = 812702999;
        this.Dh = 355462360;
        this.Dl = -150054599;
        this.Eh = 1731405415;
        this.El = -4191439;
        this.Fh = -1900787065;
        this.Fl = 1750603025;
        this.Gh = -619958771;
        this.Gl = 1694076839;
        this.Hh = 1203062813;
        this.Hl = -1090891868;
        this.outputLen = 48;
    }
}
exports.SHA384 = SHA384;
exports.sha512 = (0, utils_js_1.wrapConstructor)(()=>new SHA512());
exports.sha512_224 = (0, utils_js_1.wrapConstructor)(()=>new SHA512_224());
exports.sha512_256 = (0, utils_js_1.wrapConstructor)(()=>new SHA512_256());
exports.sha384 = (0, utils_js_1.wrapConstructor)(()=>new SHA384());

},{"7560457f92e48ccb":"4Doa0","eda9289ed6a1f5f2":"8TbxJ","f18acd6c798648cc":"2ehgp"}],"4Doa0":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.HashMD = exports.Maj = exports.Chi = void 0;
const _assert_js_1 = require("444c341b278547c6");
const utils_js_1 = require("e667c0fa26fe74b7");
/**
 * Polyfill for Safari 14
 */ function setBigUint64(view, byteOffset, value, isLE) {
    if (typeof view.setBigUint64 === "function") return view.setBigUint64(byteOffset, value, isLE);
    const _32n = BigInt(32);
    const _u32_max = BigInt(0xffffffff);
    const wh = Number(value >> _32n & _u32_max);
    const wl = Number(value & _u32_max);
    const h = isLE ? 4 : 0;
    const l = isLE ? 0 : 4;
    view.setUint32(byteOffset + h, wh, isLE);
    view.setUint32(byteOffset + l, wl, isLE);
}
/**
 * Choice: a ? b : c
 */ const Chi = (a, b, c)=>a & b ^ ~a & c;
exports.Chi = Chi;
/**
 * Majority function, true if any two inputs is true
 */ const Maj = (a, b, c)=>a & b ^ a & c ^ b & c;
exports.Maj = Maj;
/**
 * Merkle-Damgard hash construction base class.
 * Could be used to create MD5, RIPEMD, SHA1, SHA2.
 */ class HashMD extends utils_js_1.Hash {
    constructor(blockLen, outputLen, padOffset, isLE){
        super();
        this.blockLen = blockLen;
        this.outputLen = outputLen;
        this.padOffset = padOffset;
        this.isLE = isLE;
        this.finished = false;
        this.length = 0;
        this.pos = 0;
        this.destroyed = false;
        this.buffer = new Uint8Array(blockLen);
        this.view = (0, utils_js_1.createView)(this.buffer);
    }
    update(data) {
        (0, _assert_js_1.exists)(this);
        const { view, buffer, blockLen } = this;
        data = (0, utils_js_1.toBytes)(data);
        const len = data.length;
        for(let pos = 0; pos < len;){
            const take = Math.min(blockLen - this.pos, len - pos);
            // Fast path: we have at least one block in input, cast it to view and process
            if (take === blockLen) {
                const dataView = (0, utils_js_1.createView)(data);
                for(; blockLen <= len - pos; pos += blockLen)this.process(dataView, pos);
                continue;
            }
            buffer.set(data.subarray(pos, pos + take), this.pos);
            this.pos += take;
            pos += take;
            if (this.pos === blockLen) {
                this.process(view, 0);
                this.pos = 0;
            }
        }
        this.length += data.length;
        this.roundClean();
        return this;
    }
    digestInto(out) {
        (0, _assert_js_1.exists)(this);
        (0, _assert_js_1.output)(out, this);
        this.finished = true;
        // Padding
        // We can avoid allocation of buffer for padding completely if it
        // was previously not allocated here. But it won't change performance.
        const { buffer, view, blockLen, isLE } = this;
        let { pos } = this;
        // append the bit '1' to the message
        buffer[pos++] = 128;
        this.buffer.subarray(pos).fill(0);
        // we have less than padOffset left in buffer, so we cannot put length in
        // current block, need process it and pad again
        if (this.padOffset > blockLen - pos) {
            this.process(view, 0);
            pos = 0;
        }
        // Pad until full block byte with zeros
        for(let i = pos; i < blockLen; i++)buffer[i] = 0;
        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that
        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.
        // So we just write lowest 64 bits of that value.
        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
        this.process(view, 0);
        const oview = (0, utils_js_1.createView)(out);
        const len = this.outputLen;
        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT
        if (len % 4) throw new Error("_sha2: outputLen should be aligned to 32bit");
        const outLen = len / 4;
        const state = this.get();
        if (outLen > state.length) throw new Error("_sha2: outputLen bigger than state");
        for(let i = 0; i < outLen; i++)oview.setUint32(4 * i, state[i], isLE);
    }
    digest() {
        const { buffer, outputLen } = this;
        this.digestInto(buffer);
        const res = buffer.slice(0, outputLen);
        this.destroy();
        return res;
    }
    _cloneInto(to) {
        to || (to = new this.constructor());
        to.set(...this.get());
        const { blockLen, buffer, length, finished, destroyed, pos } = this;
        to.length = length;
        to.pos = pos;
        to.finished = finished;
        to.destroyed = destroyed;
        if (length % blockLen) to.buffer.set(buffer);
        return to;
    }
}
exports.HashMD = HashMD;

},{"444c341b278547c6":"BFdql","e667c0fa26fe74b7":"2ehgp"}],"BFdql":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isBytes = isBytes;
exports.number = number;
exports.bool = bool;
exports.bytes = bytes;
exports.hash = hash;
exports.exists = exists;
exports.output = output;
function number(n) {
    if (!Number.isSafeInteger(n) || n < 0) throw new Error(`positive integer expected, not ${n}`);
}
function bool(b) {
    if (typeof b !== "boolean") throw new Error(`boolean expected, not ${b}`);
}
// copied from utils
function isBytes(a) {
    return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
}
function bytes(b, ...lengths) {
    if (!isBytes(b)) throw new Error("Uint8Array expected");
    if (lengths.length > 0 && !lengths.includes(b.length)) throw new Error(`Uint8Array expected of length ${lengths}, not of length=${b.length}`);
}
function hash(h) {
    if (typeof h !== "function" || typeof h.create !== "function") throw new Error("Hash should be wrapped by utils.wrapConstructor");
    number(h.outputLen);
    number(h.blockLen);
}
function exists(instance, checkFinished = true) {
    if (instance.destroyed) throw new Error("Hash instance has been destroyed");
    if (checkFinished && instance.finished) throw new Error("Hash#digest() has already been called");
}
function output(out, instance) {
    bytes(out);
    const min = instance.outputLen;
    if (out.length < min) throw new Error(`digestInto() expects output buffer of length at least ${min}`);
}
const assert = {
    number,
    bool,
    bytes,
    hash,
    exists,
    output
};
exports.default = assert;

},{}],"2ehgp":[function(require,module,exports) {
"use strict";
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Hash = exports.nextTick = exports.byteSwapIfBE = exports.byteSwap = exports.isLE = exports.rotl = exports.rotr = exports.createView = exports.u32 = exports.u8 = void 0;
exports.isBytes = isBytes;
exports.byteSwap32 = byteSwap32;
exports.bytesToHex = bytesToHex;
exports.hexToBytes = hexToBytes;
exports.asyncLoop = asyncLoop;
exports.utf8ToBytes = utf8ToBytes;
exports.toBytes = toBytes;
exports.concatBytes = concatBytes;
exports.checkOpts = checkOpts;
exports.wrapConstructor = wrapConstructor;
exports.wrapConstructorWithOpts = wrapConstructorWithOpts;
exports.wrapXOFConstructorWithOpts = wrapXOFConstructorWithOpts;
exports.randomBytes = randomBytes;
// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.
// node.js versions earlier than v19 don't declare it in global scope.
// For node.js, package.json#exports field mapping rewrites import
// from `crypto` to `cryptoNode`, which imports native module.
// Makes the utils un-importable in browsers without a bundler.
// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.
const crypto_1 = require("308a0f9b8753b4af");
const _assert_js_1 = require("f33264417aee0570");
// export { isBytes } from './_assert.js';
// We can't reuse isBytes from _assert, because somehow this causes huge perf issues
function isBytes(a) {
    return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
}
// Cast array to different type
const u8 = (arr)=>new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
exports.u8 = u8;
const u32 = (arr)=>new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
exports.u32 = u32;
// Cast array to view
const createView = (arr)=>new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
exports.createView = createView;
// The rotate right (circular right shift) operation for uint32
const rotr = (word, shift)=>word << 32 - shift | word >>> shift;
exports.rotr = rotr;
// The rotate left (circular left shift) operation for uint32
const rotl = (word, shift)=>word << shift | word >>> 32 - shift >>> 0;
exports.rotl = rotl;
exports.isLE = new Uint8Array(new Uint32Array([
    0x11223344
]).buffer)[0] === 0x44;
// The byte swap operation for uint32
const byteSwap = (word)=>word << 24 & 0xff000000 | word << 8 & 0xff0000 | word >>> 8 & 0xff00 | word >>> 24 & 0xff;
exports.byteSwap = byteSwap;
// Conditionally byte swap if on a big-endian platform
exports.byteSwapIfBE = exports.isLE ? (n)=>n : (n)=>(0, exports.byteSwap)(n);
// In place byte swap for Uint32Array
function byteSwap32(arr) {
    for(let i = 0; i < arr.length; i++)arr[i] = (0, exports.byteSwap)(arr[i]);
}
// Array where index 0xf0 (240) is mapped to string 'f0'
const hexes = /* @__PURE__ */ Array.from({
    length: 256
}, (_, i)=>i.toString(16).padStart(2, "0"));
/**
 * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'
 */ function bytesToHex(bytes) {
    (0, _assert_js_1.bytes)(bytes);
    // pre-caching improves the speed 6x
    let hex = "";
    for(let i = 0; i < bytes.length; i++)hex += hexes[bytes[i]];
    return hex;
}
// We use optimized technique to convert hex string to byte array
const asciis = {
    _0: 48,
    _9: 57,
    _A: 65,
    _F: 70,
    _a: 97,
    _f: 102
};
function asciiToBase16(char) {
    if (char >= asciis._0 && char <= asciis._9) return char - asciis._0;
    if (char >= asciis._A && char <= asciis._F) return char - (asciis._A - 10);
    if (char >= asciis._a && char <= asciis._f) return char - (asciis._a - 10);
    return;
}
/**
 * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])
 */ function hexToBytes(hex) {
    if (typeof hex !== "string") throw new Error("hex string expected, got " + typeof hex);
    const hl = hex.length;
    const al = hl / 2;
    if (hl % 2) throw new Error("padded hex string expected, got unpadded hex of length " + hl);
    const array = new Uint8Array(al);
    for(let ai = 0, hi = 0; ai < al; ai++, hi += 2){
        const n1 = asciiToBase16(hex.charCodeAt(hi));
        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
        if (n1 === undefined || n2 === undefined) {
            const char = hex[hi] + hex[hi + 1];
            throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
        }
        array[ai] = n1 * 16 + n2;
    }
    return array;
}
// There is no setImmediate in browser and setTimeout is slow.
// call of async fn will return Promise, which will be fullfiled only on
// next scheduler queue processing step and this is exactly what we need.
const nextTick = async ()=>{};
exports.nextTick = nextTick;
// Returns control to thread each 'tick' ms to avoid blocking
async function asyncLoop(iters, tick, cb) {
    let ts = Date.now();
    for(let i = 0; i < iters; i++){
        cb(i);
        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too
        const diff = Date.now() - ts;
        if (diff >= 0 && diff < tick) continue;
        await (0, exports.nextTick)();
        ts += diff;
    }
}
/**
 * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])
 */ function utf8ToBytes(str) {
    if (typeof str !== "string") throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809
}
/**
 * Normalizes (non-hex) string or Uint8Array to Uint8Array.
 * Warning: when Uint8Array is passed, it would NOT get copied.
 * Keep in mind for future mutable operations.
 */ function toBytes(data) {
    if (typeof data === "string") data = utf8ToBytes(data);
    (0, _assert_js_1.bytes)(data);
    return data;
}
/**
 * Copies several Uint8Arrays into one.
 */ function concatBytes(...arrays) {
    let sum = 0;
    for(let i = 0; i < arrays.length; i++){
        const a = arrays[i];
        (0, _assert_js_1.bytes)(a);
        sum += a.length;
    }
    const res = new Uint8Array(sum);
    for(let i = 0, pad = 0; i < arrays.length; i++){
        const a = arrays[i];
        res.set(a, pad);
        pad += a.length;
    }
    return res;
}
// For runtime check if class implements interface
class Hash {
    // Safe version that clones internal state
    clone() {
        return this._cloneInto();
    }
}
exports.Hash = Hash;
const toStr = {}.toString;
function checkOpts(defaults, opts) {
    if (opts !== undefined && toStr.call(opts) !== "[object Object]") throw new Error("Options should be object or undefined");
    const merged = Object.assign(defaults, opts);
    return merged;
}
function wrapConstructor(hashCons) {
    const hashC = (msg)=>hashCons().update(toBytes(msg)).digest();
    const tmp = hashCons();
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = ()=>hashCons();
    return hashC;
}
function wrapConstructorWithOpts(hashCons) {
    const hashC = (msg, opts)=>hashCons(opts).update(toBytes(msg)).digest();
    const tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (opts)=>hashCons(opts);
    return hashC;
}
function wrapXOFConstructorWithOpts(hashCons) {
    const hashC = (msg, opts)=>hashCons(opts).update(toBytes(msg)).digest();
    const tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (opts)=>hashCons(opts);
    return hashC;
}
/**
 * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.
 */ function randomBytes(bytesLength = 32) {
    if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === "function") return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
    // Legacy Node.js compatibility
    if (crypto_1.crypto && typeof crypto_1.crypto.randomBytes === "function") return crypto_1.crypto.randomBytes(bytesLength);
    throw new Error("crypto.getRandomValues must be defined");
}

},{"308a0f9b8753b4af":"85XD8","f33264417aee0570":"BFdql"}],"85XD8":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.crypto = void 0;
exports.crypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : undefined;

},{}],"8TbxJ":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.add5L = exports.add5H = exports.add4H = exports.add4L = exports.add3H = exports.add3L = exports.rotlBL = exports.rotlBH = exports.rotlSL = exports.rotlSH = exports.rotr32L = exports.rotr32H = exports.rotrBL = exports.rotrBH = exports.rotrSL = exports.rotrSH = exports.shrSL = exports.shrSH = exports.toBig = void 0;
exports.fromBig = fromBig;
exports.split = split;
exports.add = add;
const U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
const _32n = /* @__PURE__ */ BigInt(32);
// We are not using BigUint64Array, because they are extremely slow as per 2022
function fromBig(n, le = false) {
    if (le) return {
        h: Number(n & U32_MASK64),
        l: Number(n >> _32n & U32_MASK64)
    };
    return {
        h: Number(n >> _32n & U32_MASK64) | 0,
        l: Number(n & U32_MASK64) | 0
    };
}
function split(lst, le = false) {
    let Ah = new Uint32Array(lst.length);
    let Al = new Uint32Array(lst.length);
    for(let i = 0; i < lst.length; i++){
        const { h, l } = fromBig(lst[i], le);
        [Ah[i], Al[i]] = [
            h,
            l
        ];
    }
    return [
        Ah,
        Al
    ];
}
const toBig = (h, l)=>BigInt(h >>> 0) << _32n | BigInt(l >>> 0);
exports.toBig = toBig;
// for Shift in [0, 32)
const shrSH = (h, _l, s)=>h >>> s;
exports.shrSH = shrSH;
const shrSL = (h, l, s)=>h << 32 - s | l >>> s;
exports.shrSL = shrSL;
// Right rotate for Shift in [1, 32)
const rotrSH = (h, l, s)=>h >>> s | l << 32 - s;
exports.rotrSH = rotrSH;
const rotrSL = (h, l, s)=>h << 32 - s | l >>> s;
exports.rotrSL = rotrSL;
// Right rotate for Shift in (32, 64), NOTE: 32 is special case.
const rotrBH = (h, l, s)=>h << 64 - s | l >>> s - 32;
exports.rotrBH = rotrBH;
const rotrBL = (h, l, s)=>h >>> s - 32 | l << 64 - s;
exports.rotrBL = rotrBL;
// Right rotate for shift===32 (just swaps l&h)
const rotr32H = (_h, l)=>l;
exports.rotr32H = rotr32H;
const rotr32L = (h, _l)=>h;
exports.rotr32L = rotr32L;
// Left rotate for Shift in [1, 32)
const rotlSH = (h, l, s)=>h << s | l >>> 32 - s;
exports.rotlSH = rotlSH;
const rotlSL = (h, l, s)=>l << s | h >>> 32 - s;
exports.rotlSL = rotlSL;
// Left rotate for Shift in (32, 64), NOTE: 32 is special case.
const rotlBH = (h, l, s)=>l << s - 32 | h >>> 64 - s;
exports.rotlBH = rotlBH;
const rotlBL = (h, l, s)=>h << s - 32 | l >>> 64 - s;
exports.rotlBL = rotlBL;
// JS uses 32-bit signed integers for bitwise operations which means we cannot
// simple take carry out of low bit sum by shift, we need to use division.
function add(Ah, Al, Bh, Bl) {
    const l = (Al >>> 0) + (Bl >>> 0);
    return {
        h: Ah + Bh + (l / 2 ** 32 | 0) | 0,
        l: l | 0
    };
}
// Addition with more than 2 elements
const add3L = (Al, Bl, Cl)=>(Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
exports.add3L = add3L;
const add3H = (low, Ah, Bh, Ch)=>Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
exports.add3H = add3H;
const add4L = (Al, Bl, Cl, Dl)=>(Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
exports.add4L = add4L;
const add4H = (low, Ah, Bh, Ch, Dh)=>Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
exports.add4H = add4H;
const add5L = (Al, Bl, Cl, Dl, El)=>(Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
exports.add5L = add5L;
const add5H = (low, Ah, Bh, Ch, Dh, Eh)=>Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
exports.add5H = add5H;
// prettier-ignore
const u64 = {
    fromBig,
    split,
    toBig,
    shrSH,
    shrSL,
    rotrSH,
    rotrSL,
    rotrBH,
    rotrBL,
    rotr32H,
    rotr32L,
    rotlSH,
    rotlSL,
    rotlBH,
    rotlBL,
    add,
    add3L,
    add3H,
    add4L,
    add4H,
    add5H,
    add5L
};
exports.default = u64;

},{}],"hYY6w":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.twistedEdwards = twistedEdwards;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ // Twisted Edwards curve. The formula is: ax + y = 1 + dxy
const curve_js_1 = require("1f0d1b1cd4a4a1c6");
const modular_js_1 = require("9dc554786fdce90a");
const ut = require("e8b53bd0c0c12029");
const utils_js_1 = require("e8b53bd0c0c12029");
// Be friendly to bad ECMAScript parsers by not using bigint literals
// prettier-ignore
const _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _8n = BigInt(8);
// verification rule is either zip215 or rfc8032 / nist186-5. Consult fromHex:
const VERIFY_DEFAULT = {
    zip215: true
};
function validateOpts(curve) {
    const opts = (0, curve_js_1.validateBasic)(curve);
    ut.validateObject(curve, {
        hash: "function",
        a: "bigint",
        d: "bigint",
        randomBytes: "function"
    }, {
        adjustScalarBytes: "function",
        domain: "function",
        uvRatio: "function",
        mapToCurve: "function"
    });
    // Set defaults
    return Object.freeze({
        ...opts
    });
}
/**
 * Creates Twisted Edwards curve with EdDSA signatures.
 * @example
 * import { Field } from '@noble/curves/abstract/modular';
 * // Before that, define BigInt-s: a, d, p, n, Gx, Gy, h
 * const curve = twistedEdwards({ a, d, Fp: Field(p), n, Gx, Gy, h })
 */ function twistedEdwards(curveDef) {
    const CURVE = validateOpts(curveDef);
    const { Fp, n: CURVE_ORDER, prehash: prehash, hash: cHash, randomBytes, nByteLength, h: cofactor } = CURVE;
    const MASK = _2n << BigInt(nByteLength * 8) - _1n;
    const modP = Fp.create; // Function overrides
    const Fn = (0, modular_js_1.Field)(CURVE.n, CURVE.nBitLength);
    // sqrt(u/v)
    const uvRatio = CURVE.uvRatio || ((u, v)=>{
        try {
            return {
                isValid: true,
                value: Fp.sqrt(u * Fp.inv(v))
            };
        } catch (e) {
            return {
                isValid: false,
                value: _0n
            };
        }
    });
    const adjustScalarBytes = CURVE.adjustScalarBytes || ((bytes)=>bytes); // NOOP
    const domain = CURVE.domain || ((data, ctx, phflag)=>{
        (0, utils_js_1.abool)("phflag", phflag);
        if (ctx.length || phflag) throw new Error("Contexts/pre-hash are not supported");
        return data;
    }); // NOOP
    // 0 <= n < MASK
    // Coordinates larger than Fp.ORDER are allowed for zip215
    function aCoordinate(title, n) {
        ut.aInRange("coordinate " + title, n, _0n, MASK);
    }
    function assertPoint(other) {
        if (!(other instanceof Point)) throw new Error("ExtendedPoint expected");
    }
    // Converts Extended point to default (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    const toAffineMemo = (0, utils_js_1.memoized)((p, iz)=>{
        const { ex: x, ey: y, ez: z } = p;
        const is0 = p.is0();
        if (iz == null) iz = is0 ? _8n : Fp.inv(z); // 8 was chosen arbitrarily
        const ax = modP(x * iz);
        const ay = modP(y * iz);
        const zz = modP(z * iz);
        if (is0) return {
            x: _0n,
            y: _1n
        };
        if (zz !== _1n) throw new Error("invZ was invalid");
        return {
            x: ax,
            y: ay
        };
    });
    const assertValidMemo = (0, utils_js_1.memoized)((p)=>{
        const { a, d } = CURVE;
        if (p.is0()) throw new Error("bad point: ZERO"); // TODO: optimize, with vars below?
        // Equation in affine coordinates: ax + y = 1 + dxy
        // Equation in projective coordinates (X/Z, Y/Z, Z):  (aX + Y)Z = Z + dXY
        const { ex: X, ey: Y, ez: Z, et: T } = p;
        const X2 = modP(X * X); // X
        const Y2 = modP(Y * Y); // Y
        const Z2 = modP(Z * Z); // Z
        const Z4 = modP(Z2 * Z2); // Z
        const aX2 = modP(X2 * a); // aX
        const left = modP(Z2 * modP(aX2 + Y2)); // (aX + Y)Z
        const right = modP(Z4 + modP(d * modP(X2 * Y2))); // Z + dXY
        if (left !== right) throw new Error("bad point: equation left != right (1)");
        // In Extended coordinates we also have T, which is x*y=T/Z: check X*Y == Z*T
        const XY = modP(X * Y);
        const ZT = modP(Z * T);
        if (XY !== ZT) throw new Error("bad point: equation left != right (2)");
        return true;
    });
    // Extended Point works in extended coordinates: (x, y, z, t)  (x=x/z, y=y/z, t=xy).
    // https://en.wikipedia.org/wiki/Twisted_Edwards_curve#Extended_coordinates
    class Point {
        constructor(ex, ey, ez, et){
            this.ex = ex;
            this.ey = ey;
            this.ez = ez;
            this.et = et;
            aCoordinate("x", ex);
            aCoordinate("y", ey);
            aCoordinate("z", ez);
            aCoordinate("t", et);
            Object.freeze(this);
        }
        get x() {
            return this.toAffine().x;
        }
        get y() {
            return this.toAffine().y;
        }
        static fromAffine(p) {
            if (p instanceof Point) throw new Error("extended point not allowed");
            const { x, y } = p || {};
            aCoordinate("x", x);
            aCoordinate("y", y);
            return new Point(x, y, _1n, modP(x * y));
        }
        static normalizeZ(points) {
            const toInv = Fp.invertBatch(points.map((p)=>p.ez));
            return points.map((p, i)=>p.toAffine(toInv[i])).map(Point.fromAffine);
        }
        // Multiscalar Multiplication
        static msm(points, scalars) {
            return (0, curve_js_1.pippenger)(Point, Fn, points, scalars);
        }
        // "Private method", don't use it directly
        _setWindowSize(windowSize) {
            wnaf.setWindowSize(this, windowSize);
        }
        // Not required for fromHex(), which always creates valid points.
        // Could be useful for fromAffine().
        assertValidity() {
            assertValidMemo(this);
        }
        // Compare one point to another.
        equals(other) {
            assertPoint(other);
            const { ex: X1, ey: Y1, ez: Z1 } = this;
            const { ex: X2, ey: Y2, ez: Z2 } = other;
            const X1Z2 = modP(X1 * Z2);
            const X2Z1 = modP(X2 * Z1);
            const Y1Z2 = modP(Y1 * Z2);
            const Y2Z1 = modP(Y2 * Z1);
            return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;
        }
        is0() {
            return this.equals(Point.ZERO);
        }
        negate() {
            // Flips point sign to a negative one (-x, y in affine coords)
            return new Point(modP(-this.ex), this.ey, this.ez, modP(-this.et));
        }
        // Fast algo for doubling Extended Point.
        // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd
        // Cost: 4M + 4S + 1*a + 6add + 1*2.
        double() {
            const { a } = CURVE;
            const { ex: X1, ey: Y1, ez: Z1 } = this;
            const A = modP(X1 * X1); // A = X12
            const B = modP(Y1 * Y1); // B = Y12
            const C = modP(_2n * modP(Z1 * Z1)); // C = 2*Z12
            const D = modP(a * A); // D = a*A
            const x1y1 = X1 + Y1;
            const E = modP(modP(x1y1 * x1y1) - A - B); // E = (X1+Y1)2-A-B
            const G = D + B; // G = D+B
            const F = G - C; // F = G-C
            const H = D - B; // H = D-B
            const X3 = modP(E * F); // X3 = E*F
            const Y3 = modP(G * H); // Y3 = G*H
            const T3 = modP(E * H); // T3 = E*H
            const Z3 = modP(F * G); // Z3 = F*G
            return new Point(X3, Y3, Z3, T3);
        }
        // Fast algo for adding 2 Extended Points.
        // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd
        // Cost: 9M + 1*a + 1*d + 7add.
        add(other) {
            assertPoint(other);
            const { a, d } = CURVE;
            const { ex: X1, ey: Y1, ez: Z1, et: T1 } = this;
            const { ex: X2, ey: Y2, ez: Z2, et: T2 } = other;
            // Faster algo for adding 2 Extended Points when curve's a=-1.
            // http://hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html#addition-add-2008-hwcd-4
            // Cost: 8M + 8add + 2*2.
            // Note: It does not check whether the `other` point is valid.
            if (a === BigInt(-1)) {
                const A = modP((Y1 - X1) * (Y2 + X2));
                const B = modP((Y1 + X1) * (Y2 - X2));
                const F = modP(B - A);
                if (F === _0n) return this.double(); // Same point. Tests say it doesn't affect timing
                const C = modP(Z1 * _2n * T2);
                const D = modP(T1 * _2n * Z2);
                const E = D + C;
                const G = B + A;
                const H = D - C;
                const X3 = modP(E * F);
                const Y3 = modP(G * H);
                const T3 = modP(E * H);
                const Z3 = modP(F * G);
                return new Point(X3, Y3, Z3, T3);
            }
            const A = modP(X1 * X2); // A = X1*X2
            const B = modP(Y1 * Y2); // B = Y1*Y2
            const C = modP(T1 * d * T2); // C = T1*d*T2
            const D = modP(Z1 * Z2); // D = Z1*Z2
            const E = modP((X1 + Y1) * (X2 + Y2) - A - B); // E = (X1+Y1)*(X2+Y2)-A-B
            const F = D - C; // F = D-C
            const G = D + C; // G = D+C
            const H = modP(B - a * A); // H = B-a*A
            const X3 = modP(E * F); // X3 = E*F
            const Y3 = modP(G * H); // Y3 = G*H
            const T3 = modP(E * H); // T3 = E*H
            const Z3 = modP(F * G); // Z3 = F*G
            return new Point(X3, Y3, Z3, T3);
        }
        subtract(other) {
            return this.add(other.negate());
        }
        wNAF(n) {
            return wnaf.wNAFCached(this, n, Point.normalizeZ);
        }
        // Constant-time multiplication.
        multiply(scalar) {
            const n = scalar;
            ut.aInRange("scalar", n, _1n, CURVE_ORDER); // 1 <= scalar < L
            const { p, f } = this.wNAF(n);
            return Point.normalizeZ([
                p,
                f
            ])[0];
        }
        // Non-constant-time multiplication. Uses double-and-add algorithm.
        // It's faster, but should only be used when you don't care about
        // an exposed private key e.g. sig verification.
        // Does NOT allow scalars higher than CURVE.n.
        multiplyUnsafe(scalar) {
            const n = scalar;
            ut.aInRange("scalar", n, _0n, CURVE_ORDER); // 0 <= scalar < L
            if (n === _0n) return I;
            if (this.equals(I) || n === _1n) return this;
            if (this.equals(G)) return this.wNAF(n).p;
            return wnaf.unsafeLadder(this, n);
        }
        // Checks if point is of small order.
        // If you add something to small order point, you will have "dirty"
        // point with torsion component.
        // Multiplies point by cofactor and checks if the result is 0.
        isSmallOrder() {
            return this.multiplyUnsafe(cofactor).is0();
        }
        // Multiplies point by curve order and checks if the result is 0.
        // Returns `false` is the point is dirty.
        isTorsionFree() {
            return wnaf.unsafeLadder(this, CURVE_ORDER).is0();
        }
        // Converts Extended point to default (x, y) coordinates.
        // Can accept precomputed Z^-1 - for example, from invertBatch.
        toAffine(iz) {
            return toAffineMemo(this, iz);
        }
        clearCofactor() {
            const { h: cofactor } = CURVE;
            if (cofactor === _1n) return this;
            return this.multiplyUnsafe(cofactor);
        }
        // Converts hash string or Uint8Array to Point.
        // Uses algo from RFC8032 5.1.3.
        static fromHex(hex, zip215 = false) {
            const { d, a } = CURVE;
            const len = Fp.BYTES;
            hex = (0, utils_js_1.ensureBytes)("pointHex", hex, len); // copy hex to a new array
            (0, utils_js_1.abool)("zip215", zip215);
            const normed = hex.slice(); // copy again, we'll manipulate it
            const lastByte = hex[len - 1]; // select last byte
            normed[len - 1] = lastByte & -129; // clear last bit
            const y = ut.bytesToNumberLE(normed);
            // RFC8032 prohibits >= p, but ZIP215 doesn't
            // zip215=true:  0 <= y < MASK (2^256 for ed25519)
            // zip215=false: 0 <= y < P (2^255-19 for ed25519)
            const max = zip215 ? MASK : Fp.ORDER;
            ut.aInRange("pointHex.y", y, _0n, max);
            // Ed25519: x = (y-1)/(dy+1) mod p. Ed448: x = (y-1)/(dy-1) mod p. Generic case:
            // ax+y=1+dxy => y-1=dxy-ax => y-1=x(dy-a) => x=(y-1)/(dy-a)
            const y2 = modP(y * y); // denominator is always non-0 mod p.
            const u = modP(y2 - _1n); // u = y - 1
            const v = modP(d * y2 - a); // v = d y + 1.
            let { isValid, value: x } = uvRatio(u, v); // (u/v)
            if (!isValid) throw new Error("Point.fromHex: invalid y coordinate");
            const isXOdd = (x & _1n) === _1n; // There are 2 square roots. Use x_0 bit to select proper
            const isLastByteOdd = (lastByte & 0x80) !== 0; // x_0, last bit
            if (!zip215 && x === _0n && isLastByteOdd) // if x=0 and x_0 = 1, fail
            throw new Error("Point.fromHex: x=0 and x_0=1");
            if (isLastByteOdd !== isXOdd) x = modP(-x); // if x_0 != x mod 2, set x = p-x
            return Point.fromAffine({
                x,
                y
            });
        }
        static fromPrivateKey(privKey) {
            return getExtendedPublicKey(privKey).point;
        }
        toRawBytes() {
            const { x, y } = this.toAffine();
            const bytes = ut.numberToBytesLE(y, Fp.BYTES); // each y has 2 x values (x, -y)
            bytes[bytes.length - 1] |= x & _1n ? 0x80 : 0; // when compressing, it's enough to store y
            return bytes; // and use the last byte to encode sign of x
        }
        toHex() {
            return ut.bytesToHex(this.toRawBytes()); // Same as toRawBytes, but returns string.
        }
    }
    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, _1n, modP(CURVE.Gx * CURVE.Gy));
    Point.ZERO = new Point(_0n, _1n, _1n, _0n); // 0, 1, 1, 0
    const { BASE: G, ZERO: I } = Point;
    const wnaf = (0, curve_js_1.wNAF)(Point, nByteLength * 8);
    function modN(a) {
        return (0, modular_js_1.mod)(a, CURVE_ORDER);
    }
    // Little-endian SHA512 with modulo n
    function modN_LE(hash) {
        return modN(ut.bytesToNumberLE(hash));
    }
    /** Convenience method that creates public key and other stuff. RFC8032 5.1.5 */ function getExtendedPublicKey(key) {
        const len = nByteLength;
        key = (0, utils_js_1.ensureBytes)("private key", key, len);
        // Hash private key with curve's hash function to produce uniformingly random input
        // Check byte lengths: ensure(64, h(ensure(32, key)))
        const hashed = (0, utils_js_1.ensureBytes)("hashed private key", cHash(key), 2 * len);
        const head = adjustScalarBytes(hashed.slice(0, len)); // clear first half bits, produce FE
        const prefix = hashed.slice(len, 2 * len); // second half is called key prefix (5.1.6)
        const scalar = modN_LE(head); // The actual private scalar
        const point = G.multiply(scalar); // Point on Edwards curve aka public key
        const pointBytes = point.toRawBytes(); // Uint8Array representation
        return {
            head,
            prefix,
            scalar,
            point,
            pointBytes
        };
    }
    // Calculates EdDSA pub key. RFC8032 5.1.5. Privkey is hashed. Use first half with 3 bits cleared
    function getPublicKey(privKey) {
        return getExtendedPublicKey(privKey).pointBytes;
    }
    // int('LE', SHA512(dom2(F, C) || msgs)) mod N
    function hashDomainToScalar(context = new Uint8Array(), ...msgs) {
        const msg = ut.concatBytes(...msgs);
        return modN_LE(cHash(domain(msg, (0, utils_js_1.ensureBytes)("context", context), !!prehash)));
    }
    /** Signs message with privateKey. RFC8032 5.1.6 */ function sign(msg, privKey, options = {}) {
        msg = (0, utils_js_1.ensureBytes)("message", msg);
        if (prehash) msg = prehash(msg); // for ed25519ph etc.
        const { prefix, scalar, pointBytes } = getExtendedPublicKey(privKey);
        const r = hashDomainToScalar(options.context, prefix, msg); // r = dom2(F, C) || prefix || PH(M)
        const R = G.multiply(r).toRawBytes(); // R = rG
        const k = hashDomainToScalar(options.context, R, pointBytes, msg); // R || A || PH(M)
        const s = modN(r + k * scalar); // S = (r + k * s) mod L
        ut.aInRange("signature.s", s, _0n, CURVE_ORDER); // 0 <= s < l
        const res = ut.concatBytes(R, ut.numberToBytesLE(s, Fp.BYTES));
        return (0, utils_js_1.ensureBytes)("result", res, nByteLength * 2); // 64-byte signature
    }
    const verifyOpts = VERIFY_DEFAULT;
    function verify(sig, msg, publicKey, options = verifyOpts) {
        const { context, zip215 } = options;
        const len = Fp.BYTES; // Verifies EdDSA signature against message and public key. RFC8032 5.1.7.
        sig = (0, utils_js_1.ensureBytes)("signature", sig, 2 * len); // An extended group equation is checked.
        msg = (0, utils_js_1.ensureBytes)("message", msg);
        if (zip215 !== undefined) (0, utils_js_1.abool)("zip215", zip215);
        if (prehash) msg = prehash(msg); // for ed25519ph, etc
        const s = ut.bytesToNumberLE(sig.slice(len, 2 * len));
        // zip215: true is good for consensus-critical apps and allows points < 2^256
        // zip215: false follows RFC8032 / NIST186-5 and restricts points to CURVE.p
        let A, R, SB;
        try {
            A = Point.fromHex(publicKey, zip215);
            R = Point.fromHex(sig.slice(0, len), zip215);
            SB = G.multiplyUnsafe(s); // 0 <= s < l is done inside
        } catch (error) {
            return false;
        }
        if (!zip215 && A.isSmallOrder()) return false;
        const k = hashDomainToScalar(context, R.toRawBytes(), A.toRawBytes(), msg);
        const RkA = R.add(A.multiplyUnsafe(k));
        // [8][S]B = [8]R + [8][k]A'
        return RkA.subtract(SB).clearCofactor().equals(Point.ZERO);
    }
    G._setWindowSize(8); // Enable precomputes. Slows down first publicKey computation by 20ms.
    const utils = {
        getExtendedPublicKey,
        // ed25519 private keys are uniform 32b. No need to check for modulo bias, like in secp256k1.
        randomPrivateKey: ()=>randomBytes(Fp.BYTES),
        /**
         * We're doing scalar multiplication (used in getPublicKey etc) with precomputed BASE_POINT
         * values. This slows down first getPublicKey() by milliseconds (see Speed section),
         * but allows to speed-up subsequent getPublicKey() calls up to 20x.
         * @param windowSize 2, 4, 8, 16
         */ precompute (windowSize = 8, point = Point.BASE) {
            point._setWindowSize(windowSize);
            point.multiply(BigInt(3));
            return point;
        }
    };
    return {
        CURVE,
        getPublicKey,
        sign,
        verify,
        ExtendedPoint: Point,
        utils
    };
}

},{"1f0d1b1cd4a4a1c6":"etkeY","9dc554786fdce90a":"cB5Z5","e8b53bd0c0c12029":"cBmkf"}],"etkeY":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.wNAF = wNAF;
exports.pippenger = pippenger;
exports.validateBasic = validateBasic;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ // Abelian group utilities
const modular_js_1 = require("72c8f755a25fddc3");
const utils_js_1 = require("f90fcba6ea31de55");
const _0n = BigInt(0);
const _1n = BigInt(1);
// Since points in different groups cannot be equal (different object constructor),
// we can have single place to store precomputes
const pointPrecomputes = new WeakMap();
const pointWindowSizes = new WeakMap(); // This allows use make points immutable (nothing changes inside)
// Elliptic curve multiplication of Point by scalar. Fragile.
// Scalars should always be less than curve order: this should be checked inside of a curve itself.
// Creates precomputation tables for fast multiplication:
// - private scalar is split by fixed size windows of W bits
// - every window point is collected from window's table & added to accumulator
// - since windows are different, same point inside tables won't be accessed more than once per calc
// - each multiplication is 'Math.ceil(CURVE_ORDER / ) + 1' point additions (fixed for any scalar)
// - +1 window is neccessary for wNAF
// - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication
// TODO: Research returning 2d JS array of windows, instead of a single window. This would allow
// windows to be in different memory locations
function wNAF(c, bits) {
    const constTimeNegate = (condition, item)=>{
        const neg = item.negate();
        return condition ? neg : item;
    };
    const validateW = (W)=>{
        if (!Number.isSafeInteger(W) || W <= 0 || W > bits) throw new Error(`Wrong window size=${W}, should be [1..${bits}]`);
    };
    const opts = (W)=>{
        validateW(W);
        const windows = Math.ceil(bits / W) + 1; // +1, because
        const windowSize = 2 ** (W - 1); // -1 because we skip zero
        return {
            windows,
            windowSize
        };
    };
    return {
        constTimeNegate,
        // non-const time multiplication ladder
        unsafeLadder (elm, n) {
            let p = c.ZERO;
            let d = elm;
            while(n > _0n){
                if (n & _1n) p = p.add(d);
                d = d.double();
                n >>= _1n;
            }
            return p;
        },
        /**
         * Creates a wNAF precomputation window. Used for caching.
         * Default window size is set by `utils.precompute()` and is equal to 8.
         * Number of precomputed points depends on the curve size:
         * 2^(1) * (Math.ceil( / ) + 1), where:
         * -  is the window size
         * -  is the bitlength of the curve order.
         * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
         * @returns precomputed point tables flattened to a single array
         */ precomputeWindow (elm, W) {
            const { windows, windowSize } = opts(W);
            const points = [];
            let p = elm;
            let base = p;
            for(let window = 0; window < windows; window++){
                base = p;
                points.push(base);
                // =1, because we skip zero
                for(let i = 1; i < windowSize; i++){
                    base = base.add(p);
                    points.push(base);
                }
                p = base.double();
            }
            return points;
        },
        /**
         * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
         * @param W window size
         * @param precomputes precomputed tables
         * @param n scalar (we don't check here, but should be less than curve order)
         * @returns real and fake (for const-time) points
         */ wNAF (W, precomputes, n) {
            // TODO: maybe check that scalar is less than group order? wNAF behavious is undefined otherwise
            // But need to carefully remove other checks before wNAF. ORDER == bits here
            const { windows, windowSize } = opts(W);
            let p = c.ZERO;
            let f = c.BASE;
            const mask = BigInt(2 ** W - 1); // Create mask with W ones: 0b1111 for W=4 etc.
            const maxNumber = 2 ** W;
            const shiftBy = BigInt(W);
            for(let window = 0; window < windows; window++){
                const offset = window * windowSize;
                // Extract W bits.
                let wbits = Number(n & mask);
                // Shift number by W bits.
                n >>= shiftBy;
                // If the bits are bigger than max size, we'll split those.
                // +224 => 256 - 32
                if (wbits > windowSize) {
                    wbits -= maxNumber;
                    n += _1n;
                }
                // This code was first written with assumption that 'f' and 'p' will never be infinity point:
                // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,
                // there is negate now: it is possible that negated element from low value
                // would be the same as high element, which will create carry into next window.
                // It's not obvious how this can fail, but still worth investigating later.
                // Check if we're onto Zero point.
                // Add random point inside current window to f.
                const offset1 = offset;
                const offset2 = offset + Math.abs(wbits) - 1; // -1 because we skip zero
                const cond1 = window % 2 !== 0;
                const cond2 = wbits < 0;
                if (wbits === 0) // The most important part for const-time getPublicKey
                f = f.add(constTimeNegate(cond1, precomputes[offset1]));
                else p = p.add(constTimeNegate(cond2, precomputes[offset2]));
            }
            // JIT-compiler should not eliminate f here, since it will later be used in normalizeZ()
            // Even if the variable is still unused, there are some checks which will
            // throw an exception, so compiler needs to prove they won't happen, which is hard.
            // At this point there is a way to F be infinity-point even if p is not,
            // which makes it less const-time: around 1 bigint multiply.
            return {
                p,
                f
            };
        },
        wNAFCached (P, n, transform) {
            const W = pointWindowSizes.get(P) || 1;
            // Calculate precomputes on a first run, reuse them after
            let comp = pointPrecomputes.get(P);
            if (!comp) {
                comp = this.precomputeWindow(P, W);
                if (W !== 1) pointPrecomputes.set(P, transform(comp));
            }
            return this.wNAF(W, comp, n);
        },
        // We calculate precomputes for elliptic curve point multiplication
        // using windowed method. This specifies window size and
        // stores precomputed values. Usually only base point would be precomputed.
        setWindowSize (P, W) {
            validateW(W);
            pointWindowSizes.set(P, W);
            pointPrecomputes.delete(P);
        }
    };
}
/**
 * Pippenger algorithm for multi-scalar multiplication (MSM).
 * MSM is basically (Pa + Qb + Rc + ...).
 * 30x faster vs naive addition on L=4096, 10x faster with precomputes.
 * For N=254bit, L=1, it does: 1024 ADD + 254 DBL. For L=5: 1536 ADD + 254 DBL.
 * Algorithmically constant-time (for same L), even when 1 point + scalar, or when scalar = 0.
 * @param c Curve Point constructor
 * @param field field over CURVE.N - important that it's not over CURVE.P
 * @param points array of L curve points
 * @param scalars array of L scalars (aka private keys / bigints)
 */ function pippenger(c, field, points, scalars) {
    // If we split scalars by some window (let's say 8 bits), every chunk will only
    // take 256 buckets even if there are 4096 scalars, also re-uses double.
    // TODO:
    // - https://eprint.iacr.org/2024/750.pdf
    // - https://tches.iacr.org/index.php/TCHES/article/view/10287
    // 0 is accepted in scalars
    if (!Array.isArray(points) || !Array.isArray(scalars) || scalars.length !== points.length) throw new Error("arrays of points and scalars must have equal length");
    scalars.forEach((s, i)=>{
        if (!field.isValid(s)) throw new Error(`wrong scalar at index ${i}`);
    });
    points.forEach((p, i)=>{
        if (!(p instanceof c)) throw new Error(`wrong point at index ${i}`);
    });
    const wbits = (0, utils_js_1.bitLen)(BigInt(points.length));
    const windowSize = wbits > 12 ? wbits - 3 : wbits > 4 ? wbits - 2 : wbits ? 2 : 1; // in bits
    const MASK = (1 << windowSize) - 1;
    const buckets = new Array(MASK + 1).fill(c.ZERO); // +1 for zero array
    const lastBits = Math.floor((field.BITS - 1) / windowSize) * windowSize;
    let sum = c.ZERO;
    for(let i = lastBits; i >= 0; i -= windowSize){
        buckets.fill(c.ZERO);
        for(let j = 0; j < scalars.length; j++){
            const scalar = scalars[j];
            const wbits = Number(scalar >> BigInt(i) & BigInt(MASK));
            buckets[wbits] = buckets[wbits].add(points[j]);
        }
        let resI = c.ZERO; // not using this will do small speed-up, but will lose ct
        // Skip first bucket, because it is zero
        for(let j = buckets.length - 1, sumI = c.ZERO; j > 0; j--){
            sumI = sumI.add(buckets[j]);
            resI = resI.add(sumI);
        }
        sum = sum.add(resI);
        if (i !== 0) for(let j = 0; j < windowSize; j++)sum = sum.double();
    }
    return sum;
}
function validateBasic(curve) {
    (0, modular_js_1.validateField)(curve.Fp);
    (0, utils_js_1.validateObject)(curve, {
        n: "bigint",
        h: "bigint",
        Gx: "field",
        Gy: "field"
    }, {
        nBitLength: "isSafeInteger",
        nByteLength: "isSafeInteger"
    });
    // Set defaults
    return Object.freeze({
        ...(0, modular_js_1.nLength)(curve.n, curve.nBitLength),
        ...curve,
        p: curve.Fp.ORDER
    });
}

},{"72c8f755a25fddc3":"cB5Z5","f90fcba6ea31de55":"cBmkf"}],"cB5Z5":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isNegativeLE = void 0;
exports.mod = mod;
exports.pow = pow;
exports.pow2 = pow2;
exports.invert = invert;
exports.tonelliShanks = tonelliShanks;
exports.FpSqrt = FpSqrt;
exports.validateField = validateField;
exports.FpPow = FpPow;
exports.FpInvertBatch = FpInvertBatch;
exports.FpDiv = FpDiv;
exports.FpLegendre = FpLegendre;
exports.FpIsSquare = FpIsSquare;
exports.nLength = nLength;
exports.Field = Field;
exports.FpSqrtOdd = FpSqrtOdd;
exports.FpSqrtEven = FpSqrtEven;
exports.hashToPrivateScalar = hashToPrivateScalar;
exports.getFieldBytesLength = getFieldBytesLength;
exports.getMinHashLength = getMinHashLength;
exports.mapHashToField = mapHashToField;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ // Utilities for modular arithmetics and finite fields
const utils_js_1 = require("d8ac4b6c79c60614");
// prettier-ignore
const _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3);
// prettier-ignore
const _4n = BigInt(4), _5n = BigInt(5), _8n = BigInt(8);
// prettier-ignore
const _9n = BigInt(9), _16n = BigInt(16);
// Calculates a modulo b
function mod(a, b) {
    const result = a % b;
    return result >= _0n ? result : b + result;
}
/**
 * Efficiently raise num to power and do modular division.
 * Unsafe in some contexts: uses ladder, so can expose bigint bits.
 * @example
 * pow(2n, 6n, 11n) // 64n % 11n == 9n
 */ // TODO: use field version && remove
function pow(num, power, modulo) {
    if (modulo <= _0n || power < _0n) throw new Error("Expected power/modulo > 0");
    if (modulo === _1n) return _0n;
    let res = _1n;
    while(power > _0n){
        if (power & _1n) res = res * num % modulo;
        num = num * num % modulo;
        power >>= _1n;
    }
    return res;
}
// Does x ^ (2 ^ power) mod p. pow2(30, 4) == 30 ^ (2 ^ 4)
function pow2(x, power, modulo) {
    let res = x;
    while(power-- > _0n){
        res *= res;
        res %= modulo;
    }
    return res;
}
// Inverses number over modulo
function invert(number, modulo) {
    if (number === _0n || modulo <= _0n) throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);
    // Euclidean GCD https://brilliant.org/wiki/extended-euclidean-algorithm/
    // Fermat's little theorem "CT-like" version inv(n) = n^(m-2) mod m is 30x slower.
    let a = mod(number, modulo);
    let b = modulo;
    // prettier-ignore
    let x = _0n, y = _1n, u = _1n, v = _0n;
    while(a !== _0n){
        // JIT applies optimization if those two lines follow each other
        const q = b / a;
        const r = b % a;
        const m = x - u * q;
        const n = y - v * q;
        // prettier-ignore
        b = a, a = r, x = u, y = v, u = m, v = n;
    }
    const gcd = b;
    if (gcd !== _1n) throw new Error("invert: does not exist");
    return mod(x, modulo);
}
/**
 * Tonelli-Shanks square root search algorithm.
 * 1. https://eprint.iacr.org/2012/685.pdf (page 12)
 * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks
 * Will start an infinite loop if field order P is not prime.
 * @param P field order
 * @returns function that takes field Fp (created from P) and number n
 */ function tonelliShanks(P) {
    // Legendre constant: used to calculate Legendre symbol (a | p),
    // which denotes the value of a^((p-1)/2) (mod p).
    // (a | p)  1    if a is a square (mod p)
    // (a | p)  -1   if a is not a square (mod p)
    // (a | p)  0    if a  0 (mod p)
    const legendreC = (P - _1n) / _2n;
    let Q, S, Z;
    // Step 1: By factoring out powers of 2 from p - 1,
    // find q and s such that p - 1 = q*(2^s) with q odd
    for(Q = P - _1n, S = 0; Q % _2n === _0n; Q /= _2n, S++);
    // Step 2: Select a non-square z such that (z | p)  -1 and set c  zq
    for(Z = _2n; Z < P && pow(Z, legendreC, P) !== P - _1n; Z++);
    // Fast-path
    if (S === 1) {
        const p1div4 = (P + _1n) / _4n;
        return function tonelliFast(Fp, n) {
            const root = Fp.pow(n, p1div4);
            if (!Fp.eql(Fp.sqr(root), n)) throw new Error("Cannot find square root");
            return root;
        };
    }
    // Slow-path
    const Q1div2 = (Q + _1n) / _2n;
    return function tonelliSlow(Fp, n) {
        // Step 0: Check that n is indeed a square: (n | p) should not be  -1
        if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE)) throw new Error("Cannot find square root");
        let r = S;
        // TODO: will fail at Fp2/etc
        let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q); // will update both x and b
        let x = Fp.pow(n, Q1div2); // first guess at the square root
        let b = Fp.pow(n, Q); // first guess at the fudge factor
        while(!Fp.eql(b, Fp.ONE)){
            if (Fp.eql(b, Fp.ZERO)) return Fp.ZERO; // https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm (4. If t = 0, return r = 0)
            // Find m such b^(2^m)==1
            let m = 1;
            for(let t2 = Fp.sqr(b); m < r; m++){
                if (Fp.eql(t2, Fp.ONE)) break;
                t2 = Fp.sqr(t2); // t2 *= t2
            }
            // NOTE: r-m-1 can be bigger than 32, need to convert to bigint before shift, otherwise there will be overflow
            const ge = Fp.pow(g, _1n << BigInt(r - m - 1)); // ge = 2^(r-m-1)
            g = Fp.sqr(ge); // g = ge * ge
            x = Fp.mul(x, ge); // x *= ge
            b = Fp.mul(b, g); // b *= g
            r = m;
        }
        return x;
    };
}
function FpSqrt(P) {
    // NOTE: different algorithms can give different roots, it is up to user to decide which one they want.
    // For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).
    // P  3 (mod 4)
    // n = n^((P+1)/4)
    if (P % _4n === _3n) {
        // Not all roots possible!
        // const ORDER =
        //   0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabn;
        // const NUM = 72057594037927816n;
        const p1div4 = (P + _1n) / _4n;
        return function sqrt3mod4(Fp, n) {
            const root = Fp.pow(n, p1div4);
            // Throw if root**2 != n
            if (!Fp.eql(Fp.sqr(root), n)) throw new Error("Cannot find square root");
            return root;
        };
    }
    // Atkin algorithm for q  5 (mod 8), https://eprint.iacr.org/2012/685.pdf (page 10)
    if (P % _8n === _5n) {
        const c1 = (P - _5n) / _8n;
        return function sqrt5mod8(Fp, n) {
            const n2 = Fp.mul(n, _2n);
            const v = Fp.pow(n2, c1);
            const nv = Fp.mul(n, v);
            const i = Fp.mul(Fp.mul(nv, _2n), v);
            const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));
            if (!Fp.eql(Fp.sqr(root), n)) throw new Error("Cannot find square root");
            return root;
        };
    }
    // P  9 (mod 16)
    _9n;
    // Other cases: Tonelli-Shanks algorithm
    return tonelliShanks(P);
}
// Little-endian check for first LE bit (last BE bit);
const isNegativeLE = (num, modulo)=>(mod(num, modulo) & _1n) === _1n;
exports.isNegativeLE = isNegativeLE;
// prettier-ignore
const FIELD_FIELDS = [
    "create",
    "isValid",
    "is0",
    "neg",
    "inv",
    "sqrt",
    "sqr",
    "eql",
    "add",
    "sub",
    "mul",
    "pow",
    "div",
    "addN",
    "subN",
    "mulN",
    "sqrN"
];
function validateField(field) {
    const initial = {
        ORDER: "bigint",
        MASK: "bigint",
        BYTES: "isSafeInteger",
        BITS: "isSafeInteger"
    };
    const opts = FIELD_FIELDS.reduce((map, val)=>{
        map[val] = "function";
        return map;
    }, initial);
    return (0, utils_js_1.validateObject)(field, opts);
}
// Generic field functions
/**
 * Same as `pow` but for Fp: non-constant-time.
 * Unsafe in some contexts: uses ladder, so can expose bigint bits.
 */ function FpPow(f, num, power) {
    // Should have same speed as pow for bigints
    // TODO: benchmark!
    if (power < _0n) throw new Error("Expected power > 0");
    if (power === _0n) return f.ONE;
    if (power === _1n) return num;
    let p = f.ONE;
    let d = num;
    while(power > _0n){
        if (power & _1n) p = f.mul(p, d);
        d = f.sqr(d);
        power >>= _1n;
    }
    return p;
}
/**
 * Efficiently invert an array of Field elements.
 * `inv(0)` will return `undefined` here: make sure to throw an error.
 */ function FpInvertBatch(f, nums) {
    const tmp = new Array(nums.length);
    // Walk from first to last, multiply them by each other MOD p
    const lastMultiplied = nums.reduce((acc, num, i)=>{
        if (f.is0(num)) return acc;
        tmp[i] = acc;
        return f.mul(acc, num);
    }, f.ONE);
    // Invert last element
    const inverted = f.inv(lastMultiplied);
    // Walk from last to first, multiply them by inverted each other MOD p
    nums.reduceRight((acc, num, i)=>{
        if (f.is0(num)) return acc;
        tmp[i] = f.mul(acc, tmp[i]);
        return f.mul(acc, num);
    }, inverted);
    return tmp;
}
function FpDiv(f, lhs, rhs) {
    return f.mul(lhs, typeof rhs === "bigint" ? invert(rhs, f.ORDER) : f.inv(rhs));
}
function FpLegendre(order) {
    // (a | p)  1    if a is a square (mod p), quadratic residue
    // (a | p)  -1   if a is not a square (mod p), quadratic non residue
    // (a | p)  0    if a  0 (mod p)
    const legendreConst = (order - _1n) / _2n; // Integer arithmetic
    return (f, x)=>f.pow(x, legendreConst);
}
// This function returns True whenever the value x is a square in the field F.
function FpIsSquare(f) {
    const legendre = FpLegendre(f.ORDER);
    return (x)=>{
        const p = legendre(f, x);
        return f.eql(p, f.ZERO) || f.eql(p, f.ONE);
    };
}
// CURVE.n lengths
function nLength(n, nBitLength) {
    // Bit size, byte size of CURVE.n
    const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;
    const nByteLength = Math.ceil(_nBitLength / 8);
    return {
        nBitLength: _nBitLength,
        nByteLength
    };
}
/**
 * Initializes a finite field over prime. **Non-primes are not supported.**
 * Do not init in loop: slow. Very fragile: always run a benchmark on a change.
 * Major performance optimizations:
 * * a) denormalized operations like mulN instead of mul
 * * b) same object shape: never add or remove keys
 * * c) Object.freeze
 * NOTE: operations don't check 'isValid' for all elements for performance reasons,
 * it is caller responsibility to check this.
 * This is low-level code, please make sure you know what you doing.
 * @param ORDER prime positive bigint
 * @param bitLen how many bits the field consumes
 * @param isLE (def: false) if encoding / decoding should be in little-endian
 * @param redef optional faster redefinitions of sqrt and other methods
 */ function Field(ORDER, bitLen, isLE = false, redef = {}) {
    if (ORDER <= _0n) throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);
    const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);
    if (BYTES > 2048) throw new Error("Field lengths over 2048 bytes are not supported");
    const sqrtP = FpSqrt(ORDER);
    const f = Object.freeze({
        ORDER,
        BITS,
        BYTES,
        MASK: (0, utils_js_1.bitMask)(BITS),
        ZERO: _0n,
        ONE: _1n,
        create: (num)=>mod(num, ORDER),
        isValid: (num)=>{
            if (typeof num !== "bigint") throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);
            return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible
        },
        is0: (num)=>num === _0n,
        isOdd: (num)=>(num & _1n) === _1n,
        neg: (num)=>mod(-num, ORDER),
        eql: (lhs, rhs)=>lhs === rhs,
        sqr: (num)=>mod(num * num, ORDER),
        add: (lhs, rhs)=>mod(lhs + rhs, ORDER),
        sub: (lhs, rhs)=>mod(lhs - rhs, ORDER),
        mul: (lhs, rhs)=>mod(lhs * rhs, ORDER),
        pow: (num, power)=>FpPow(f, num, power),
        div: (lhs, rhs)=>mod(lhs * invert(rhs, ORDER), ORDER),
        // Same as above, but doesn't normalize
        sqrN: (num)=>num * num,
        addN: (lhs, rhs)=>lhs + rhs,
        subN: (lhs, rhs)=>lhs - rhs,
        mulN: (lhs, rhs)=>lhs * rhs,
        inv: (num)=>invert(num, ORDER),
        sqrt: redef.sqrt || ((n)=>sqrtP(f, n)),
        invertBatch: (lst)=>FpInvertBatch(f, lst),
        // TODO: do we really need constant cmov?
        // We don't have const-time bigints anyway, so probably will be not very useful
        cmov: (a, b, c)=>c ? b : a,
        toBytes: (num)=>isLE ? (0, utils_js_1.numberToBytesLE)(num, BYTES) : (0, utils_js_1.numberToBytesBE)(num, BYTES),
        fromBytes: (bytes)=>{
            if (bytes.length !== BYTES) throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes.length}`);
            return isLE ? (0, utils_js_1.bytesToNumberLE)(bytes) : (0, utils_js_1.bytesToNumberBE)(bytes);
        }
    });
    return Object.freeze(f);
}
function FpSqrtOdd(Fp, elm) {
    if (!Fp.isOdd) throw new Error(`Field doesn't have isOdd`);
    const root = Fp.sqrt(elm);
    return Fp.isOdd(root) ? root : Fp.neg(root);
}
function FpSqrtEven(Fp, elm) {
    if (!Fp.isOdd) throw new Error(`Field doesn't have isOdd`);
    const root = Fp.sqrt(elm);
    return Fp.isOdd(root) ? Fp.neg(root) : root;
}
/**
 * "Constant-time" private key generation utility.
 * Same as mapKeyToField, but accepts less bytes (40 instead of 48 for 32-byte field).
 * Which makes it slightly more biased, less secure.
 * @deprecated use mapKeyToField instead
 */ function hashToPrivateScalar(hash, groupOrder, isLE = false) {
    hash = (0, utils_js_1.ensureBytes)("privateHash", hash);
    const hashLen = hash.length;
    const minLen = nLength(groupOrder).nByteLength + 8;
    if (minLen < 24 || hashLen < minLen || hashLen > 1024) throw new Error(`hashToPrivateScalar: expected ${minLen}-1024 bytes of input, got ${hashLen}`);
    const num = isLE ? (0, utils_js_1.bytesToNumberLE)(hash) : (0, utils_js_1.bytesToNumberBE)(hash);
    return mod(num, groupOrder - _1n) + _1n;
}
/**
 * Returns total number of bytes consumed by the field element.
 * For example, 32 bytes for usual 256-bit weierstrass curve.
 * @param fieldOrder number of field elements, usually CURVE.n
 * @returns byte length of field
 */ function getFieldBytesLength(fieldOrder) {
    if (typeof fieldOrder !== "bigint") throw new Error("field order must be bigint");
    const bitLength = fieldOrder.toString(2).length;
    return Math.ceil(bitLength / 8);
}
/**
 * Returns minimal amount of bytes that can be safely reduced
 * by field order.
 * Should be 2^-128 for 128-bit curve such as P256.
 * @param fieldOrder number of field elements, usually CURVE.n
 * @returns byte length of target hash
 */ function getMinHashLength(fieldOrder) {
    const length = getFieldBytesLength(fieldOrder);
    return length + Math.ceil(length / 2);
}
/**
 * "Constant-time" private key generation utility.
 * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF
 * and convert them into private scalar, with the modulo bias being negligible.
 * Needs at least 48 bytes of input for 32-byte private key.
 * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/
 * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final
 * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5
 * @param hash hash output from SHA3 or a similar function
 * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)
 * @param isLE interpret hash bytes as LE num
 * @returns valid private scalar
 */ function mapHashToField(key, fieldOrder, isLE = false) {
    const len = key.length;
    const fieldLen = getFieldBytesLength(fieldOrder);
    const minLen = getMinHashLength(fieldOrder);
    // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.
    if (len < 16 || len < minLen || len > 1024) throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);
    const num = isLE ? (0, utils_js_1.bytesToNumberBE)(key) : (0, utils_js_1.bytesToNumberLE)(key);
    // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0
    const reduced = mod(num, fieldOrder - _1n) + _1n;
    return isLE ? (0, utils_js_1.numberToBytesLE)(reduced, fieldLen) : (0, utils_js_1.numberToBytesBE)(reduced, fieldLen);
}

},{"d8ac4b6c79c60614":"cBmkf"}],"cBmkf":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.notImplemented = exports.bitMask = void 0;
exports.isBytes = isBytes;
exports.abytes = abytes;
exports.abool = abool;
exports.bytesToHex = bytesToHex;
exports.numberToHexUnpadded = numberToHexUnpadded;
exports.hexToNumber = hexToNumber;
exports.hexToBytes = hexToBytes;
exports.bytesToNumberBE = bytesToNumberBE;
exports.bytesToNumberLE = bytesToNumberLE;
exports.numberToBytesBE = numberToBytesBE;
exports.numberToBytesLE = numberToBytesLE;
exports.numberToVarBytesBE = numberToVarBytesBE;
exports.ensureBytes = ensureBytes;
exports.concatBytes = concatBytes;
exports.equalBytes = equalBytes;
exports.utf8ToBytes = utf8ToBytes;
exports.inRange = inRange;
exports.aInRange = aInRange;
exports.bitLen = bitLen;
exports.bitGet = bitGet;
exports.bitSet = bitSet;
exports.createHmacDrbg = createHmacDrbg;
exports.validateObject = validateObject;
exports.memoized = memoized;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ // 100 lines of code in the file are duplicated from noble-hashes (utils).
// This is OK: `abstract` directory does not use noble-hashes.
// User may opt-in into using different hashing library. This way, noble-hashes
// won't be included into their bundle.
const _0n = /* @__PURE__ */ BigInt(0);
const _1n = /* @__PURE__ */ BigInt(1);
const _2n = /* @__PURE__ */ BigInt(2);
function isBytes(a) {
    return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
}
function abytes(item) {
    if (!isBytes(item)) throw new Error("Uint8Array expected");
}
function abool(title, value) {
    if (typeof value !== "boolean") throw new Error(`${title} must be valid boolean, got "${value}".`);
}
// Array where index 0xf0 (240) is mapped to string 'f0'
const hexes = /* @__PURE__ */ Array.from({
    length: 256
}, (_, i)=>i.toString(16).padStart(2, "0"));
/**
 * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'
 */ function bytesToHex(bytes) {
    abytes(bytes);
    // pre-caching improves the speed 6x
    let hex = "";
    for(let i = 0; i < bytes.length; i++)hex += hexes[bytes[i]];
    return hex;
}
function numberToHexUnpadded(num) {
    const hex = num.toString(16);
    return hex.length & 1 ? `0${hex}` : hex;
}
function hexToNumber(hex) {
    if (typeof hex !== "string") throw new Error("hex string expected, got " + typeof hex);
    // Big Endian
    return BigInt(hex === "" ? "0" : `0x${hex}`);
}
// We use optimized technique to convert hex string to byte array
const asciis = {
    _0: 48,
    _9: 57,
    _A: 65,
    _F: 70,
    _a: 97,
    _f: 102
};
function asciiToBase16(char) {
    if (char >= asciis._0 && char <= asciis._9) return char - asciis._0;
    if (char >= asciis._A && char <= asciis._F) return char - (asciis._A - 10);
    if (char >= asciis._a && char <= asciis._f) return char - (asciis._a - 10);
    return;
}
/**
 * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])
 */ function hexToBytes(hex) {
    if (typeof hex !== "string") throw new Error("hex string expected, got " + typeof hex);
    const hl = hex.length;
    const al = hl / 2;
    if (hl % 2) throw new Error("padded hex string expected, got unpadded hex of length " + hl);
    const array = new Uint8Array(al);
    for(let ai = 0, hi = 0; ai < al; ai++, hi += 2){
        const n1 = asciiToBase16(hex.charCodeAt(hi));
        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
        if (n1 === undefined || n2 === undefined) {
            const char = hex[hi] + hex[hi + 1];
            throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
        }
        array[ai] = n1 * 16 + n2;
    }
    return array;
}
// BE: Big Endian, LE: Little Endian
function bytesToNumberBE(bytes) {
    return hexToNumber(bytesToHex(bytes));
}
function bytesToNumberLE(bytes) {
    abytes(bytes);
    return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));
}
function numberToBytesBE(n, len) {
    return hexToBytes(n.toString(16).padStart(len * 2, "0"));
}
function numberToBytesLE(n, len) {
    return numberToBytesBE(n, len).reverse();
}
// Unpadded, rarely used
function numberToVarBytesBE(n) {
    return hexToBytes(numberToHexUnpadded(n));
}
/**
 * Takes hex string or Uint8Array, converts to Uint8Array.
 * Validates output length.
 * Will throw error for other types.
 * @param title descriptive title for an error e.g. 'private key'
 * @param hex hex string or Uint8Array
 * @param expectedLength optional, will compare to result array's length
 * @returns
 */ function ensureBytes(title, hex, expectedLength) {
    let res;
    if (typeof hex === "string") try {
        res = hexToBytes(hex);
    } catch (e) {
        throw new Error(`${title} must be valid hex string, got "${hex}". Cause: ${e}`);
    }
    else if (isBytes(hex)) // Uint8Array.from() instead of hash.slice() because node.js Buffer
    // is instance of Uint8Array, and its slice() creates **mutable** copy
    res = Uint8Array.from(hex);
    else throw new Error(`${title} must be hex string or Uint8Array`);
    const len = res.length;
    if (typeof expectedLength === "number" && len !== expectedLength) throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);
    return res;
}
/**
 * Copies several Uint8Arrays into one.
 */ function concatBytes(...arrays) {
    let sum = 0;
    for(let i = 0; i < arrays.length; i++){
        const a = arrays[i];
        abytes(a);
        sum += a.length;
    }
    const res = new Uint8Array(sum);
    for(let i = 0, pad = 0; i < arrays.length; i++){
        const a = arrays[i];
        res.set(a, pad);
        pad += a.length;
    }
    return res;
}
// Compares 2 u8a-s in kinda constant time
function equalBytes(a, b) {
    if (a.length !== b.length) return false;
    let diff = 0;
    for(let i = 0; i < a.length; i++)diff |= a[i] ^ b[i];
    return diff === 0;
}
/**
 * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])
 */ function utf8ToBytes(str) {
    if (typeof str !== "string") throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809
}
// Is positive bigint
const isPosBig = (n)=>typeof n === "bigint" && _0n <= n;
function inRange(n, min, max) {
    return isPosBig(n) && isPosBig(min) && isPosBig(max) && min <= n && n < max;
}
/**
 * Asserts min <= n < max. NOTE: It's < max and not <= max.
 * @example
 * aInRange('x', x, 1n, 256n); // would assume x is in (1n..255n)
 */ function aInRange(title, n, min, max) {
    // Why min <= n < max and not a (min < n < max) OR b (min <= n <= max)?
    // consider P=256n, min=0n, max=P
    // - a for min=0 would require -1:          `inRange('x', x, -1n, P)`
    // - b would commonly require subtraction:  `inRange('x', x, 0n, P - 1n)`
    // - our way is the cleanest:               `inRange('x', x, 0n, P)
    if (!inRange(n, min, max)) throw new Error(`expected valid ${title}: ${min} <= n < ${max}, got ${typeof n} ${n}`);
}
// Bit operations
/**
 * Calculates amount of bits in a bigint.
 * Same as `n.toString(2).length`
 */ function bitLen(n) {
    let len;
    for(len = 0; n > _0n; n >>= _1n, len += 1);
    return len;
}
/**
 * Gets single bit at position.
 * NOTE: first bit position is 0 (same as arrays)
 * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`
 */ function bitGet(n, pos) {
    return n >> BigInt(pos) & _1n;
}
/**
 * Sets single bit at position.
 */ function bitSet(n, pos, value) {
    return n | (value ? _1n : _0n) << BigInt(pos);
}
/**
 * Calculate mask for N bits. Not using ** operator with bigints because of old engines.
 * Same as BigInt(`0b${Array(i).fill('1').join('')}`)
 */ const bitMask = (n)=>(_2n << BigInt(n - 1)) - _1n;
exports.bitMask = bitMask;
// DRBG
const u8n = (data)=>new Uint8Array(data); // creates Uint8Array
const u8fr = (arr)=>Uint8Array.from(arr); // another shortcut
/**
 * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.
 * @returns function that will call DRBG until 2nd arg returns something meaningful
 * @example
 *   const drbg = createHmacDRBG<Key>(32, 32, hmac);
 *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined
 */ function createHmacDrbg(hashLen, qByteLen, hmacFn) {
    if (typeof hashLen !== "number" || hashLen < 2) throw new Error("hashLen must be a number");
    if (typeof qByteLen !== "number" || qByteLen < 2) throw new Error("qByteLen must be a number");
    if (typeof hmacFn !== "function") throw new Error("hmacFn must be a function");
    // Step B, Step C: set hashLen to 8*ceil(hlen/8)
    let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.
    let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same
    let i = 0; // Iterations counter, will throw when over 1000
    const reset = ()=>{
        v.fill(1);
        k.fill(0);
        i = 0;
    };
    const h = (...b)=>hmacFn(k, v, ...b); // hmac(k)(v, ...values)
    const reseed = (seed = u8n())=>{
        // HMAC-DRBG reseed() function. Steps D-G
        k = h(u8fr([
            0x00
        ]), seed); // k = hmac(k || v || 0x00 || seed)
        v = h(); // v = hmac(k || v)
        if (seed.length === 0) return;
        k = h(u8fr([
            0x01
        ]), seed); // k = hmac(k || v || 0x01 || seed)
        v = h(); // v = hmac(k || v)
    };
    const gen = ()=>{
        // HMAC-DRBG generate() function
        if (i++ >= 1000) throw new Error("drbg: tried 1000 values");
        let len = 0;
        const out = [];
        while(len < qByteLen){
            v = h();
            const sl = v.slice();
            out.push(sl);
            len += v.length;
        }
        return concatBytes(...out);
    };
    const genUntil = (seed, pred)=>{
        reset();
        reseed(seed); // Steps D-G
        let res = undefined; // Step H: grind until k is in [1..n-1]
        while(!(res = pred(gen())))reseed();
        reset();
        return res;
    };
    return genUntil;
}
// Validating curves and fields
const validatorFns = {
    bigint: (val)=>typeof val === "bigint",
    function: (val)=>typeof val === "function",
    boolean: (val)=>typeof val === "boolean",
    string: (val)=>typeof val === "string",
    stringOrUint8Array: (val)=>typeof val === "string" || isBytes(val),
    isSafeInteger: (val)=>Number.isSafeInteger(val),
    array: (val)=>Array.isArray(val),
    field: (val, object)=>object.Fp.isValid(val),
    hash: (val)=>typeof val === "function" && Number.isSafeInteger(val.outputLen)
};
// type Record<K extends string | number | symbol, T> = { [P in K]: T; }
function validateObject(object, validators, optValidators = {}) {
    const checkField = (fieldName, type, isOptional)=>{
        const checkVal = validatorFns[type];
        if (typeof checkVal !== "function") throw new Error(`Invalid validator "${type}", expected function`);
        const val = object[fieldName];
        if (isOptional && val === undefined) return;
        if (!checkVal(val, object)) throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);
    };
    for (const [fieldName, type] of Object.entries(validators))checkField(fieldName, type, false);
    for (const [fieldName, type] of Object.entries(optValidators))checkField(fieldName, type, true);
    return object;
}
// validate type tests
// const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };
// const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!
// // Should fail type-check
// const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });
// const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });
// const z3 = validateObject(o, { test: 'boolean', z: 'bug' });
// const z4 = validateObject(o, { a: 'boolean', z: 'bug' });
/**
 * throws not implemented error
 */ const notImplemented = ()=>{
    throw new Error("not implemented");
};
exports.notImplemented = notImplemented;
/**
 * Memoizes (caches) computation result.
 * Uses WeakMap: the value is going auto-cleaned by GC after last reference is removed.
 */ function memoized(fn) {
    const map = new WeakMap();
    return (arg, ...args)=>{
        const val = map.get(arg);
        if (val !== undefined) return val;
        const computed = fn(arg, ...args);
        map.set(arg, computed);
        return computed;
    };
}

},{}],"2yuJj":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.expand_message_xmd = expand_message_xmd;
exports.expand_message_xof = expand_message_xof;
exports.hash_to_field = hash_to_field;
exports.isogenyMap = isogenyMap;
exports.createHasher = createHasher;
const modular_js_1 = require("eccb35e649679ca");
const utils_js_1 = require("202487820f28c009");
// Octet Stream to Integer. "spec" implementation of os2ip is 2.5x slower vs bytesToNumberBE.
const os2ip = utils_js_1.bytesToNumberBE;
// Integer to Octet Stream (numberToBytesBE)
function i2osp(value, length) {
    anum(value);
    anum(length);
    if (value < 0 || value >= 1 << 8 * length) throw new Error(`bad I2OSP call: value=${value} length=${length}`);
    const res = Array.from({
        length
    }).fill(0);
    for(let i = length - 1; i >= 0; i--){
        res[i] = value & 0xff;
        value >>>= 8;
    }
    return new Uint8Array(res);
}
function strxor(a, b) {
    const arr = new Uint8Array(a.length);
    for(let i = 0; i < a.length; i++)arr[i] = a[i] ^ b[i];
    return arr;
}
function anum(item) {
    if (!Number.isSafeInteger(item)) throw new Error("number expected");
}
// Produces a uniformly random byte string using a cryptographic hash function H that outputs b bits
// https://www.rfc-editor.org/rfc/rfc9380#section-5.3.1
function expand_message_xmd(msg, DST, lenInBytes, H) {
    (0, utils_js_1.abytes)(msg);
    (0, utils_js_1.abytes)(DST);
    anum(lenInBytes);
    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3
    if (DST.length > 255) DST = H((0, utils_js_1.concatBytes)((0, utils_js_1.utf8ToBytes)("H2C-OVERSIZE-DST-"), DST));
    const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;
    const ell = Math.ceil(lenInBytes / b_in_bytes);
    if (lenInBytes > 65535 || ell > 255) throw new Error("expand_message_xmd: invalid lenInBytes");
    const DST_prime = (0, utils_js_1.concatBytes)(DST, i2osp(DST.length, 1));
    const Z_pad = i2osp(0, r_in_bytes);
    const l_i_b_str = i2osp(lenInBytes, 2); // len_in_bytes_str
    const b = new Array(ell);
    const b_0 = H((0, utils_js_1.concatBytes)(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));
    b[0] = H((0, utils_js_1.concatBytes)(b_0, i2osp(1, 1), DST_prime));
    for(let i = 1; i <= ell; i++){
        const args = [
            strxor(b_0, b[i - 1]),
            i2osp(i + 1, 1),
            DST_prime
        ];
        b[i] = H((0, utils_js_1.concatBytes)(...args));
    }
    const pseudo_random_bytes = (0, utils_js_1.concatBytes)(...b);
    return pseudo_random_bytes.slice(0, lenInBytes);
}
// Produces a uniformly random byte string using an extendable-output function (XOF) H.
// 1. The collision resistance of H MUST be at least k bits.
// 2. H MUST be an XOF that has been proved indifferentiable from
//    a random oracle under a reasonable cryptographic assumption.
// https://www.rfc-editor.org/rfc/rfc9380#section-5.3.2
function expand_message_xof(msg, DST, lenInBytes, k, H) {
    (0, utils_js_1.abytes)(msg);
    (0, utils_js_1.abytes)(DST);
    anum(lenInBytes);
    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3
    // DST = H('H2C-OVERSIZE-DST-' || a_very_long_DST, Math.ceil((lenInBytes * k) / 8));
    if (DST.length > 255) {
        const dkLen = Math.ceil(2 * k / 8);
        DST = H.create({
            dkLen
        }).update((0, utils_js_1.utf8ToBytes)("H2C-OVERSIZE-DST-")).update(DST).digest();
    }
    if (lenInBytes > 65535 || DST.length > 255) throw new Error("expand_message_xof: invalid lenInBytes");
    return H.create({
        dkLen: lenInBytes
    }).update(msg).update(i2osp(lenInBytes, 2))// 2. DST_prime = DST || I2OSP(len(DST), 1)
    .update(DST).update(i2osp(DST.length, 1)).digest();
}
/**
 * Hashes arbitrary-length byte strings to a list of one or more elements of a finite field F
 * https://www.rfc-editor.org/rfc/rfc9380#section-5.2
 * @param msg a byte string containing the message to hash
 * @param count the number of elements of F to output
 * @param options `{DST: string, p: bigint, m: number, k: number, expand: 'xmd' | 'xof', hash: H}`, see above
 * @returns [u_0, ..., u_(count - 1)], a list of field elements.
 */ function hash_to_field(msg, count, options) {
    (0, utils_js_1.validateObject)(options, {
        DST: "stringOrUint8Array",
        p: "bigint",
        m: "isSafeInteger",
        k: "isSafeInteger",
        hash: "hash"
    });
    const { p, k, m, hash, expand, DST: _DST } = options;
    (0, utils_js_1.abytes)(msg);
    anum(count);
    const DST = typeof _DST === "string" ? (0, utils_js_1.utf8ToBytes)(_DST) : _DST;
    const log2p = p.toString(2).length;
    const L = Math.ceil((log2p + k) / 8); // section 5.1 of ietf draft link above
    const len_in_bytes = count * m * L;
    let prb; // pseudo_random_bytes
    if (expand === "xmd") prb = expand_message_xmd(msg, DST, len_in_bytes, hash);
    else if (expand === "xof") prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);
    else if (expand === "_internal_pass") // for internal tests only
    prb = msg;
    else throw new Error('expand must be "xmd" or "xof"');
    const u = new Array(count);
    for(let i = 0; i < count; i++){
        const e = new Array(m);
        for(let j = 0; j < m; j++){
            const elm_offset = L * (j + i * m);
            const tv = prb.subarray(elm_offset, elm_offset + L);
            e[j] = (0, modular_js_1.mod)(os2ip(tv), p);
        }
        u[i] = e;
    }
    return u;
}
function isogenyMap(field, map) {
    // Make same order as in spec
    const COEFF = map.map((i)=>Array.from(i).reverse());
    return (x, y)=>{
        const [xNum, xDen, yNum, yDen] = COEFF.map((val)=>val.reduce((acc, i)=>field.add(field.mul(acc, x), i)));
        x = field.div(xNum, xDen); // xNum / xDen
        y = field.mul(y, field.div(yNum, yDen)); // y * (yNum / yDev)
        return {
            x,
            y
        };
    };
}
function createHasher(Point, mapToCurve, def) {
    if (typeof mapToCurve !== "function") throw new Error("mapToCurve() must be defined");
    return {
        // Encodes byte string to elliptic curve.
        // hash_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
        hashToCurve (msg, options) {
            const u = hash_to_field(msg, 2, {
                ...def,
                DST: def.DST,
                ...options
            });
            const u0 = Point.fromAffine(mapToCurve(u[0]));
            const u1 = Point.fromAffine(mapToCurve(u[1]));
            const P = u0.add(u1).clearCofactor();
            P.assertValidity();
            return P;
        },
        // Encodes byte string to elliptic curve.
        // encode_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
        encodeToCurve (msg, options) {
            const u = hash_to_field(msg, 1, {
                ...def,
                DST: def.encodeDST,
                ...options
            });
            const P = Point.fromAffine(mapToCurve(u[0])).clearCofactor();
            P.assertValidity();
            return P;
        },
        // Same as encodeToCurve, but without hash
        mapToCurve (scalars) {
            if (!Array.isArray(scalars)) throw new Error("mapToCurve: expected array of bigints");
            for (const i of scalars)if (typeof i !== "bigint") throw new Error(`mapToCurve: expected array of bigints, got ${i} in array`);
            const P = Point.fromAffine(mapToCurve(scalars)).clearCofactor();
            P.assertValidity();
            return P;
        }
    };
}

},{"eccb35e649679ca":"cB5Z5","202487820f28c009":"cBmkf"}],"kbKg4":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.montgomery = montgomery;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const modular_js_1 = require("d01b1f463cd5a2a7");
const utils_js_1 = require("5722d1983f661de5");
const _0n = BigInt(0);
const _1n = BigInt(1);
function validateOpts(curve) {
    (0, utils_js_1.validateObject)(curve, {
        a: "bigint"
    }, {
        montgomeryBits: "isSafeInteger",
        nByteLength: "isSafeInteger",
        adjustScalarBytes: "function",
        domain: "function",
        powPminus2: "function",
        Gu: "bigint"
    });
    // Set defaults
    return Object.freeze({
        ...curve
    });
}
// NOTE: not really montgomery curve, just bunch of very specific methods for X25519/X448 (RFC 7748, https://www.rfc-editor.org/rfc/rfc7748)
// Uses only one coordinate instead of two
function montgomery(curveDef) {
    const CURVE = validateOpts(curveDef);
    const { P } = CURVE;
    const modP = (n)=>(0, modular_js_1.mod)(n, P);
    const montgomeryBits = CURVE.montgomeryBits;
    const montgomeryBytes = Math.ceil(montgomeryBits / 8);
    const fieldLen = CURVE.nByteLength;
    const adjustScalarBytes = CURVE.adjustScalarBytes || ((bytes)=>bytes);
    const powPminus2 = CURVE.powPminus2 || ((x)=>(0, modular_js_1.pow)(x, P - BigInt(2), P));
    // cswap from RFC7748. But it is not from RFC7748!
    /*
      cswap(swap, x_2, x_3):
           dummy = mask(swap) AND (x_2 XOR x_3)
           x_2 = x_2 XOR dummy
           x_3 = x_3 XOR dummy
           Return (x_2, x_3)
    Where mask(swap) is the all-1 or all-0 word of the same length as x_2
     and x_3, computed, e.g., as mask(swap) = 0 - swap.
    */ function cswap(swap, x_2, x_3) {
        const dummy = modP(swap * (x_2 - x_3));
        x_2 = modP(x_2 - dummy);
        x_3 = modP(x_3 + dummy);
        return [
            x_2,
            x_3
        ];
    }
    // x25519 from 4
    // The constant a24 is (486662 - 2) / 4 = 121665 for curve25519/X25519
    const a24 = (CURVE.a - BigInt(2)) / BigInt(4);
    /**
     *
     * @param pointU u coordinate (x) on Montgomery Curve 25519
     * @param scalar by which the point would be multiplied
     * @returns new Point on Montgomery curve
     */ function montgomeryLadder(u, scalar) {
        (0, utils_js_1.aInRange)("u", u, _0n, P);
        (0, utils_js_1.aInRange)("scalar", scalar, _0n, P);
        // Section 5: Implementations MUST accept non-canonical values and process them as
        // if they had been reduced modulo the field prime.
        const k = scalar;
        const x_1 = u;
        let x_2 = _1n;
        let z_2 = _0n;
        let x_3 = u;
        let z_3 = _1n;
        let swap = _0n;
        let sw;
        for(let t = BigInt(montgomeryBits - 1); t >= _0n; t--){
            const k_t = k >> t & _1n;
            swap ^= k_t;
            sw = cswap(swap, x_2, x_3);
            x_2 = sw[0];
            x_3 = sw[1];
            sw = cswap(swap, z_2, z_3);
            z_2 = sw[0];
            z_3 = sw[1];
            swap = k_t;
            const A = x_2 + z_2;
            const AA = modP(A * A);
            const B = x_2 - z_2;
            const BB = modP(B * B);
            const E = AA - BB;
            const C = x_3 + z_3;
            const D = x_3 - z_3;
            const DA = modP(D * A);
            const CB = modP(C * B);
            const dacb = DA + CB;
            const da_cb = DA - CB;
            x_3 = modP(dacb * dacb);
            z_3 = modP(x_1 * modP(da_cb * da_cb));
            x_2 = modP(AA * BB);
            z_2 = modP(E * (AA + modP(a24 * E)));
        }
        // (x_2, x_3) = cswap(swap, x_2, x_3)
        sw = cswap(swap, x_2, x_3);
        x_2 = sw[0];
        x_3 = sw[1];
        // (z_2, z_3) = cswap(swap, z_2, z_3)
        sw = cswap(swap, z_2, z_3);
        z_2 = sw[0];
        z_3 = sw[1];
        // z_2^(p - 2)
        const z2 = powPminus2(z_2);
        // Return x_2 * (z_2^(p - 2))
        return modP(x_2 * z2);
    }
    function encodeUCoordinate(u) {
        return (0, utils_js_1.numberToBytesLE)(modP(u), montgomeryBytes);
    }
    function decodeUCoordinate(uEnc) {
        // Section 5: When receiving such an array, implementations of X25519
        // MUST mask the most significant bit in the final byte.
        const u = (0, utils_js_1.ensureBytes)("u coordinate", uEnc, montgomeryBytes);
        if (fieldLen === 32) u[31] &= 127; // 0b0111_1111
        return (0, utils_js_1.bytesToNumberLE)(u);
    }
    function decodeScalar(n) {
        const bytes = (0, utils_js_1.ensureBytes)("scalar", n);
        const len = bytes.length;
        if (len !== montgomeryBytes && len !== fieldLen) throw new Error(`Expected ${montgomeryBytes} or ${fieldLen} bytes, got ${len}`);
        return (0, utils_js_1.bytesToNumberLE)(adjustScalarBytes(bytes));
    }
    function scalarMult(scalar, u) {
        const pointU = decodeUCoordinate(u);
        const _scalar = decodeScalar(scalar);
        const pu = montgomeryLadder(pointU, _scalar);
        // The result was not contributory
        // https://cr.yp.to/ecdh.html#validate
        if (pu === _0n) throw new Error("Invalid private or public key received");
        return encodeUCoordinate(pu);
    }
    // Computes public key from private. By doing scalar multiplication of base point.
    const GuBytes = encodeUCoordinate(CURVE.Gu);
    function scalarMultBase(scalar) {
        return scalarMult(scalar, GuBytes);
    }
    return {
        scalarMult,
        scalarMultBase,
        getSharedSecret: (privateKey, publicKey)=>scalarMult(privateKey, publicKey),
        getPublicKey: (privateKey)=>scalarMultBase(privateKey),
        utils: {
            randomPrivateKey: ()=>CURVE.randomBytes(CURVE.nByteLength)
        },
        GuBytes: GuBytes
    };
}

},{"d01b1f463cd5a2a7":"cB5Z5","5722d1983f661de5":"cBmkf"}],"VopIn":[function(require,module,exports) {
(function(module1, exports) {
    "use strict";
    // Utils
    function assert(val, msg) {
        if (!val) throw new Error(msg || "Assertion failed");
    }
    // Could use `inherits` module, but don't want to move from single file
    // architecture yet.
    function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {};
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
    }
    // BN
    function BN(number, base, endian) {
        if (BN.isBN(number)) return number;
        this.negative = 0;
        this.words = null;
        this.length = 0;
        // Reduction context
        this.red = null;
        if (number !== null) {
            if (base === "le" || base === "be") {
                endian = base;
                base = 10;
            }
            this._init(number || 0, base || 10, endian || "be");
        }
    }
    if (typeof module1 === "object") module1.exports = BN;
    else exports.BN = BN;
    BN.BN = BN;
    BN.wordSize = 26;
    var Buffer;
    try {
        if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") Buffer = window.Buffer;
        else Buffer = require("bd440367abe2ded7").Buffer;
    } catch (e) {}
    BN.isBN = function isBN(num) {
        if (num instanceof BN) return true;
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
    };
    BN.max = function max(left, right) {
        if (left.cmp(right) > 0) return left;
        return right;
    };
    BN.min = function min(left, right) {
        if (left.cmp(right) < 0) return left;
        return right;
    };
    BN.prototype._init = function init(number, base, endian) {
        if (typeof number === "number") return this._initNumber(number, base, endian);
        if (typeof number === "object") return this._initArray(number, base, endian);
        if (base === "hex") base = 16;
        assert(base === (base | 0) && base >= 2 && base <= 36);
        number = number.toString().replace(/\s+/g, "");
        var start = 0;
        if (number[0] === "-") {
            start++;
            this.negative = 1;
        }
        if (start < number.length) {
            if (base === 16) this._parseHex(number, start, endian);
            else {
                this._parseBase(number, base, start);
                if (endian === "le") this._initArray(this.toArray(), base, endian);
            }
        }
    };
    BN.prototype._initNumber = function _initNumber(number, base, endian) {
        if (number < 0) {
            this.negative = 1;
            number = -number;
        }
        if (number < 0x4000000) {
            this.words = [
                number & 0x3ffffff
            ];
            this.length = 1;
        } else if (number < 0x10000000000000) {
            this.words = [
                number & 0x3ffffff,
                number / 0x4000000 & 0x3ffffff
            ];
            this.length = 2;
        } else {
            assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
            this.words = [
                number & 0x3ffffff,
                number / 0x4000000 & 0x3ffffff,
                1
            ];
            this.length = 3;
        }
        if (endian !== "le") return;
        // Reverse the bytes
        this._initArray(this.toArray(), base, endian);
    };
    BN.prototype._initArray = function _initArray(number, base, endian) {
        // Perhaps a Uint8Array
        assert(typeof number.length === "number");
        if (number.length <= 0) {
            this.words = [
                0
            ];
            this.length = 1;
            return this;
        }
        this.length = Math.ceil(number.length / 3);
        this.words = new Array(this.length);
        for(var i = 0; i < this.length; i++)this.words[i] = 0;
        var j, w;
        var off = 0;
        if (endian === "be") for(i = number.length - 1, j = 0; i >= 0; i -= 3){
            w = number[i] | number[i - 1] << 8 | number[i - 2] << 16;
            this.words[j] |= w << off & 0x3ffffff;
            this.words[j + 1] = w >>> 26 - off & 0x3ffffff;
            off += 24;
            if (off >= 26) {
                off -= 26;
                j++;
            }
        }
        else if (endian === "le") for(i = 0, j = 0; i < number.length; i += 3){
            w = number[i] | number[i + 1] << 8 | number[i + 2] << 16;
            this.words[j] |= w << off & 0x3ffffff;
            this.words[j + 1] = w >>> 26 - off & 0x3ffffff;
            off += 24;
            if (off >= 26) {
                off -= 26;
                j++;
            }
        }
        return this._strip();
    };
    function parseHex4Bits(string, index) {
        var c = string.charCodeAt(index);
        // '0' - '9'
        if (c >= 48 && c <= 57) return c - 48;
        else if (c >= 65 && c <= 70) return c - 55;
        else if (c >= 97 && c <= 102) return c - 87;
        else assert(false, "Invalid character in " + string);
    }
    function parseHexByte(string, lowerBound, index) {
        var r = parseHex4Bits(string, index);
        if (index - 1 >= lowerBound) r |= parseHex4Bits(string, index - 1) << 4;
        return r;
    }
    BN.prototype._parseHex = function _parseHex(number, start, endian) {
        // Create possibly bigger array to ensure that it fits the number
        this.length = Math.ceil((number.length - start) / 6);
        this.words = new Array(this.length);
        for(var i = 0; i < this.length; i++)this.words[i] = 0;
        // 24-bits chunks
        var off = 0;
        var j = 0;
        var w;
        if (endian === "be") for(i = number.length - 1; i >= start; i -= 2){
            w = parseHexByte(number, start, i) << off;
            this.words[j] |= w & 0x3ffffff;
            if (off >= 18) {
                off -= 18;
                j += 1;
                this.words[j] |= w >>> 26;
            } else off += 8;
        }
        else {
            var parseLength = number.length - start;
            for(i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2){
                w = parseHexByte(number, start, i) << off;
                this.words[j] |= w & 0x3ffffff;
                if (off >= 18) {
                    off -= 18;
                    j += 1;
                    this.words[j] |= w >>> 26;
                } else off += 8;
            }
        }
        this._strip();
    };
    function parseBase(str, start, end, mul) {
        var r = 0;
        var b = 0;
        var len = Math.min(str.length, end);
        for(var i = start; i < len; i++){
            var c = str.charCodeAt(i) - 48;
            r *= mul;
            // 'a'
            if (c >= 49) b = c - 49 + 0xa;
            else if (c >= 17) b = c - 17 + 0xa;
            else b = c;
            assert(c >= 0 && b < mul, "Invalid character");
            r += b;
        }
        return r;
    }
    BN.prototype._parseBase = function _parseBase(number, base, start) {
        // Initialize as zero
        this.words = [
            0
        ];
        this.length = 1;
        // Find length of limb in base
        for(var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base)limbLen++;
        limbLen--;
        limbPow = limbPow / base | 0;
        var total = number.length - start;
        var mod = total % limbLen;
        var end = Math.min(total, total - mod) + start;
        var word = 0;
        for(var i = start; i < end; i += limbLen){
            word = parseBase(number, i, i + limbLen, base);
            this.imuln(limbPow);
            if (this.words[0] + word < 0x4000000) this.words[0] += word;
            else this._iaddn(word);
        }
        if (mod !== 0) {
            var pow = 1;
            word = parseBase(number, i, number.length, base);
            for(i = 0; i < mod; i++)pow *= base;
            this.imuln(pow);
            if (this.words[0] + word < 0x4000000) this.words[0] += word;
            else this._iaddn(word);
        }
        this._strip();
    };
    BN.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for(var i = 0; i < this.length; i++)dest.words[i] = this.words[i];
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
    };
    function move(dest, src) {
        dest.words = src.words;
        dest.length = src.length;
        dest.negative = src.negative;
        dest.red = src.red;
    }
    BN.prototype._move = function _move(dest) {
        move(dest, this);
    };
    BN.prototype.clone = function clone() {
        var r = new BN(null);
        this.copy(r);
        return r;
    };
    BN.prototype._expand = function _expand(size) {
        while(this.length < size)this.words[this.length++] = 0;
        return this;
    };
    // Remove leading `0` from `this`
    BN.prototype._strip = function strip() {
        while(this.length > 1 && this.words[this.length - 1] === 0)this.length--;
        return this._normSign();
    };
    BN.prototype._normSign = function _normSign() {
        // -0 = 0
        if (this.length === 1 && this.words[0] === 0) this.negative = 0;
        return this;
    };
    // Check Symbol.for because not everywhere where Symbol defined
    // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol#Browser_compatibility
    if (typeof Symbol !== "undefined" && typeof Symbol.for === "function") try {
        BN.prototype[Symbol.for("nodejs.util.inspect.custom")] = inspect;
    } catch (e) {
        BN.prototype.inspect = inspect;
    }
    else BN.prototype.inspect = inspect;
    function inspect() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    }
    /*

  var zeros = [];
  var groupSizes = [];
  var groupBases = [];

  var s = '';
  var i = -1;
  while (++i < BN.wordSize) {
    zeros[i] = s;
    s += '0';
  }
  groupSizes[0] = 0;
  groupSizes[1] = 0;
  groupBases[0] = 0;
  groupBases[1] = 0;
  var base = 2 - 1;
  while (++base < 36 + 1) {
    var groupSize = 0;
    var groupBase = 1;
    while (groupBase < (1 << BN.wordSize) / base) {
      groupBase *= base;
      groupSize += 1;
    }
    groupSizes[base] = groupSize;
    groupBases[base] = groupBase;
  }

  */ var zeros = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
    ];
    var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
    ];
    var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        10000000,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64000000,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        24300000,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
    ];
    BN.prototype.toString = function toString(base, padding) {
        base = base || 10;
        padding = padding | 0 || 1;
        var out;
        if (base === 16 || base === "hex") {
            out = "";
            var off = 0;
            var carry = 0;
            for(var i = 0; i < this.length; i++){
                var w = this.words[i];
                var word = ((w << off | carry) & 0xffffff).toString(16);
                carry = w >>> 24 - off & 0xffffff;
                off += 2;
                if (off >= 26) {
                    off -= 26;
                    i--;
                }
                if (carry !== 0 || i !== this.length - 1) out = zeros[6 - word.length] + word + out;
                else out = word + out;
            }
            if (carry !== 0) out = carry.toString(16) + out;
            while(out.length % padding !== 0)out = "0" + out;
            if (this.negative !== 0) out = "-" + out;
            return out;
        }
        if (base === (base | 0) && base >= 2 && base <= 36) {
            // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
            var groupSize = groupSizes[base];
            // var groupBase = Math.pow(base, groupSize);
            var groupBase = groupBases[base];
            out = "";
            var c = this.clone();
            c.negative = 0;
            while(!c.isZero()){
                var r = c.modrn(groupBase).toString(base);
                c = c.idivn(groupBase);
                if (!c.isZero()) out = zeros[groupSize - r.length] + r + out;
                else out = r + out;
            }
            if (this.isZero()) out = "0" + out;
            while(out.length % padding !== 0)out = "0" + out;
            if (this.negative !== 0) out = "-" + out;
            return out;
        }
        assert(false, "Base should be between 2 and 36");
    };
    BN.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) ret += this.words[1] * 0x4000000;
        else if (this.length === 3 && this.words[2] === 0x01) // NOTE: at this stage it is known that the top bit is set
        ret += 0x10000000000000 + this.words[1] * 0x4000000;
        else if (this.length > 2) assert(false, "Number can only safely store up to 53 bits");
        return this.negative !== 0 ? -ret : ret;
    };
    BN.prototype.toJSON = function toJSON() {
        return this.toString(16, 2);
    };
    if (Buffer) BN.prototype.toBuffer = function toBuffer(endian, length) {
        return this.toArrayLike(Buffer, endian, length);
    };
    BN.prototype.toArray = function toArray(endian, length) {
        return this.toArrayLike(Array, endian, length);
    };
    var allocate = function allocate(ArrayType, size) {
        if (ArrayType.allocUnsafe) return ArrayType.allocUnsafe(size);
        return new ArrayType(size);
    };
    BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        this._strip();
        var byteLength = this.byteLength();
        var reqLength = length || Math.max(1, byteLength);
        assert(byteLength <= reqLength, "byte array longer than desired length");
        assert(reqLength > 0, "Requested array length <= 0");
        var res = allocate(ArrayType, reqLength);
        var postfix = endian === "le" ? "LE" : "BE";
        this["_toArrayLike" + postfix](res, byteLength);
        return res;
    };
    BN.prototype._toArrayLikeLE = function _toArrayLikeLE(res, byteLength) {
        var position = 0;
        var carry = 0;
        for(var i = 0, shift = 0; i < this.length; i++){
            var word = this.words[i] << shift | carry;
            res[position++] = word & 0xff;
            if (position < res.length) res[position++] = word >> 8 & 0xff;
            if (position < res.length) res[position++] = word >> 16 & 0xff;
            if (shift === 6) {
                if (position < res.length) res[position++] = word >> 24 & 0xff;
                carry = 0;
                shift = 0;
            } else {
                carry = word >>> 24;
                shift += 2;
            }
        }
        if (position < res.length) {
            res[position++] = carry;
            while(position < res.length)res[position++] = 0;
        }
    };
    BN.prototype._toArrayLikeBE = function _toArrayLikeBE(res, byteLength) {
        var position = res.length - 1;
        var carry = 0;
        for(var i = 0, shift = 0; i < this.length; i++){
            var word = this.words[i] << shift | carry;
            res[position--] = word & 0xff;
            if (position >= 0) res[position--] = word >> 8 & 0xff;
            if (position >= 0) res[position--] = word >> 16 & 0xff;
            if (shift === 6) {
                if (position >= 0) res[position--] = word >> 24 & 0xff;
                carry = 0;
                shift = 0;
            } else {
                carry = word >>> 24;
                shift += 2;
            }
        }
        if (position >= 0) {
            res[position--] = carry;
            while(position >= 0)res[position--] = 0;
        }
    };
    if (Math.clz32) BN.prototype._countBits = function _countBits(w) {
        return 32 - Math.clz32(w);
    };
    else BN.prototype._countBits = function _countBits(w) {
        var t = w;
        var r = 0;
        if (t >= 0x1000) {
            r += 13;
            t >>>= 13;
        }
        if (t >= 0x40) {
            r += 7;
            t >>>= 7;
        }
        if (t >= 0x8) {
            r += 4;
            t >>>= 4;
        }
        if (t >= 0x02) {
            r += 2;
            t >>>= 2;
        }
        return r + t;
    };
    BN.prototype._zeroBits = function _zeroBits(w) {
        // Short-cut
        if (w === 0) return 26;
        var t = w;
        var r = 0;
        if ((t & 0x1fff) === 0) {
            r += 13;
            t >>>= 13;
        }
        if ((t & 0x7f) === 0) {
            r += 7;
            t >>>= 7;
        }
        if ((t & 0xf) === 0) {
            r += 4;
            t >>>= 4;
        }
        if ((t & 0x3) === 0) {
            r += 2;
            t >>>= 2;
        }
        if ((t & 0x1) === 0) r++;
        return r;
    };
    // Return number of used bits in a BN
    BN.prototype.bitLength = function bitLength() {
        var w = this.words[this.length - 1];
        var hi = this._countBits(w);
        return (this.length - 1) * 26 + hi;
    };
    function toBitArray(num) {
        var w = new Array(num.bitLength());
        for(var bit = 0; bit < w.length; bit++){
            var off = bit / 26 | 0;
            var wbit = bit % 26;
            w[bit] = num.words[off] >>> wbit & 0x01;
        }
        return w;
    }
    // Number of trailing zero bits
    BN.prototype.zeroBits = function zeroBits() {
        if (this.isZero()) return 0;
        var r = 0;
        for(var i = 0; i < this.length; i++){
            var b = this._zeroBits(this.words[i]);
            r += b;
            if (b !== 26) break;
        }
        return r;
    };
    BN.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
    };
    BN.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) return this.abs().inotn(width).iaddn(1);
        return this.clone();
    };
    BN.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) return this.notn(width).iaddn(1).ineg();
        return this.clone();
    };
    BN.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
    };
    // Return negative clone of `this`
    BN.prototype.neg = function neg() {
        return this.clone().ineg();
    };
    BN.prototype.ineg = function ineg() {
        if (!this.isZero()) this.negative ^= 1;
        return this;
    };
    // Or `num` with `this` in-place
    BN.prototype.iuor = function iuor(num) {
        while(this.length < num.length)this.words[this.length++] = 0;
        for(var i = 0; i < num.length; i++)this.words[i] = this.words[i] | num.words[i];
        return this._strip();
    };
    BN.prototype.ior = function ior(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuor(num);
    };
    // Or `num` with `this`
    BN.prototype.or = function or(num) {
        if (this.length > num.length) return this.clone().ior(num);
        return num.clone().ior(this);
    };
    BN.prototype.uor = function uor(num) {
        if (this.length > num.length) return this.clone().iuor(num);
        return num.clone().iuor(this);
    };
    // And `num` with `this` in-place
    BN.prototype.iuand = function iuand(num) {
        // b = min-length(num, this)
        var b;
        if (this.length > num.length) b = num;
        else b = this;
        for(var i = 0; i < b.length; i++)this.words[i] = this.words[i] & num.words[i];
        this.length = b.length;
        return this._strip();
    };
    BN.prototype.iand = function iand(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuand(num);
    };
    // And `num` with `this`
    BN.prototype.and = function and(num) {
        if (this.length > num.length) return this.clone().iand(num);
        return num.clone().iand(this);
    };
    BN.prototype.uand = function uand(num) {
        if (this.length > num.length) return this.clone().iuand(num);
        return num.clone().iuand(this);
    };
    // Xor `num` with `this` in-place
    BN.prototype.iuxor = function iuxor(num) {
        // a.length > b.length
        var a;
        var b;
        if (this.length > num.length) {
            a = this;
            b = num;
        } else {
            a = num;
            b = this;
        }
        for(var i = 0; i < b.length; i++)this.words[i] = a.words[i] ^ b.words[i];
        if (this !== a) for(; i < a.length; i++)this.words[i] = a.words[i];
        this.length = a.length;
        return this._strip();
    };
    BN.prototype.ixor = function ixor(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuxor(num);
    };
    // Xor `num` with `this`
    BN.prototype.xor = function xor(num) {
        if (this.length > num.length) return this.clone().ixor(num);
        return num.clone().ixor(this);
    };
    BN.prototype.uxor = function uxor(num) {
        if (this.length > num.length) return this.clone().iuxor(num);
        return num.clone().iuxor(this);
    };
    // Not ``this`` with ``width`` bitwidth
    BN.prototype.inotn = function inotn(width) {
        assert(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        // Extend the buffer with leading zeroes
        this._expand(bytesNeeded);
        if (bitsLeft > 0) bytesNeeded--;
        // Handle complete words
        for(var i = 0; i < bytesNeeded; i++)this.words[i] = ~this.words[i] & 0x3ffffff;
        // Handle the residue
        if (bitsLeft > 0) this.words[i] = ~this.words[i] & 0x3ffffff >> 26 - bitsLeft;
        // And remove leading zeroes
        return this._strip();
    };
    BN.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
    };
    // Set `bit` of `this`
    BN.prototype.setn = function setn(bit, val) {
        assert(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) this.words[off] = this.words[off] | 1 << wbit;
        else this.words[off] = this.words[off] & ~(1 << wbit);
        return this._strip();
    };
    // Add `num` to `this` in-place
    BN.prototype.iadd = function iadd(num) {
        var r;
        // negative + positive
        if (this.negative !== 0 && num.negative === 0) {
            this.negative = 0;
            r = this.isub(num);
            this.negative ^= 1;
            return this._normSign();
        // positive + negative
        } else if (this.negative === 0 && num.negative !== 0) {
            num.negative = 0;
            r = this.isub(num);
            num.negative = 1;
            return r._normSign();
        }
        // a.length > b.length
        var a, b;
        if (this.length > num.length) {
            a = this;
            b = num;
        } else {
            a = num;
            b = this;
        }
        var carry = 0;
        for(var i = 0; i < b.length; i++){
            r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
            this.words[i] = r & 0x3ffffff;
            carry = r >>> 26;
        }
        for(; carry !== 0 && i < a.length; i++){
            r = (a.words[i] | 0) + carry;
            this.words[i] = r & 0x3ffffff;
            carry = r >>> 26;
        }
        this.length = a.length;
        if (carry !== 0) {
            this.words[this.length] = carry;
            this.length++;
        // Copy the rest of the words
        } else if (a !== this) for(; i < a.length; i++)this.words[i] = a.words[i];
        return this;
    };
    // Add `num` to `this`
    BN.prototype.add = function add(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
            num.negative = 0;
            res = this.sub(num);
            num.negative ^= 1;
            return res;
        } else if (num.negative === 0 && this.negative !== 0) {
            this.negative = 0;
            res = num.sub(this);
            this.negative = 1;
            return res;
        }
        if (this.length > num.length) return this.clone().iadd(num);
        return num.clone().iadd(this);
    };
    // Subtract `num` from `this` in-place
    BN.prototype.isub = function isub(num) {
        // this - (-num) = this + num
        if (num.negative !== 0) {
            num.negative = 0;
            var r = this.iadd(num);
            num.negative = 1;
            return r._normSign();
        // -this - num = -(this + num)
        } else if (this.negative !== 0) {
            this.negative = 0;
            this.iadd(num);
            this.negative = 1;
            return this._normSign();
        }
        // At this point both numbers are positive
        var cmp = this.cmp(num);
        // Optimization - zeroify
        if (cmp === 0) {
            this.negative = 0;
            this.length = 1;
            this.words[0] = 0;
            return this;
        }
        // a > b
        var a, b;
        if (cmp > 0) {
            a = this;
            b = num;
        } else {
            a = num;
            b = this;
        }
        var carry = 0;
        for(var i = 0; i < b.length; i++){
            r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
            carry = r >> 26;
            this.words[i] = r & 0x3ffffff;
        }
        for(; carry !== 0 && i < a.length; i++){
            r = (a.words[i] | 0) + carry;
            carry = r >> 26;
            this.words[i] = r & 0x3ffffff;
        }
        // Copy rest of the words
        if (carry === 0 && i < a.length && a !== this) for(; i < a.length; i++)this.words[i] = a.words[i];
        this.length = Math.max(this.length, i);
        if (a !== this) this.negative = 1;
        return this._strip();
    };
    // Subtract `num` from `this`
    BN.prototype.sub = function sub(num) {
        return this.clone().isub(num);
    };
    function smallMulTo(self, num, out) {
        out.negative = num.negative ^ self.negative;
        var len = self.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        // Peel one iteration (compiler can't do it, because of code complexity)
        var a = self.words[0] | 0;
        var b = num.words[0] | 0;
        var r = a * b;
        var lo = r & 0x3ffffff;
        var carry = r / 0x4000000 | 0;
        out.words[0] = lo;
        for(var k = 1; k < len; k++){
            // Sum all words with the same `i + j = k` and accumulate `ncarry`,
            // note that ncarry could be >= 0x3ffffff
            var ncarry = carry >>> 26;
            var rword = carry & 0x3ffffff;
            var maxJ = Math.min(k, num.length - 1);
            for(var j = Math.max(0, k - self.length + 1); j <= maxJ; j++){
                var i = k - j | 0;
                a = self.words[i] | 0;
                b = num.words[j] | 0;
                r = a * b + rword;
                ncarry += r / 0x4000000 | 0;
                rword = r & 0x3ffffff;
            }
            out.words[k] = rword | 0;
            carry = ncarry | 0;
        }
        if (carry !== 0) out.words[k] = carry | 0;
        else out.length--;
        return out._strip();
    }
    // TODO(indutny): it may be reasonable to omit it for users who don't need
    // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
    // multiplication (like elliptic secp256k1).
    var comb10MulTo = function comb10MulTo(self, num, out) {
        var a = self.words;
        var b = num.words;
        var o = out.words;
        var c = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a[0] | 0;
        var al0 = a0 & 0x1fff;
        var ah0 = a0 >>> 13;
        var a1 = a[1] | 0;
        var al1 = a1 & 0x1fff;
        var ah1 = a1 >>> 13;
        var a2 = a[2] | 0;
        var al2 = a2 & 0x1fff;
        var ah2 = a2 >>> 13;
        var a3 = a[3] | 0;
        var al3 = a3 & 0x1fff;
        var ah3 = a3 >>> 13;
        var a4 = a[4] | 0;
        var al4 = a4 & 0x1fff;
        var ah4 = a4 >>> 13;
        var a5 = a[5] | 0;
        var al5 = a5 & 0x1fff;
        var ah5 = a5 >>> 13;
        var a6 = a[6] | 0;
        var al6 = a6 & 0x1fff;
        var ah6 = a6 >>> 13;
        var a7 = a[7] | 0;
        var al7 = a7 & 0x1fff;
        var ah7 = a7 >>> 13;
        var a8 = a[8] | 0;
        var al8 = a8 & 0x1fff;
        var ah8 = a8 >>> 13;
        var a9 = a[9] | 0;
        var al9 = a9 & 0x1fff;
        var ah9 = a9 >>> 13;
        var b0 = b[0] | 0;
        var bl0 = b0 & 0x1fff;
        var bh0 = b0 >>> 13;
        var b1 = b[1] | 0;
        var bl1 = b1 & 0x1fff;
        var bh1 = b1 >>> 13;
        var b2 = b[2] | 0;
        var bl2 = b2 & 0x1fff;
        var bh2 = b2 >>> 13;
        var b3 = b[3] | 0;
        var bl3 = b3 & 0x1fff;
        var bh3 = b3 >>> 13;
        var b4 = b[4] | 0;
        var bl4 = b4 & 0x1fff;
        var bh4 = b4 >>> 13;
        var b5 = b[5] | 0;
        var bl5 = b5 & 0x1fff;
        var bh5 = b5 >>> 13;
        var b6 = b[6] | 0;
        var bl6 = b6 & 0x1fff;
        var bh6 = b6 >>> 13;
        var b7 = b[7] | 0;
        var bl7 = b7 & 0x1fff;
        var bh7 = b7 >>> 13;
        var b8 = b[8] | 0;
        var bl8 = b8 & 0x1fff;
        var bh8 = b8 >>> 13;
        var b9 = b[9] | 0;
        var bl9 = b9 & 0x1fff;
        var bh9 = b9 >>> 13;
        out.negative = self.negative ^ num.negative;
        out.length = 19;
        /* k = 0 */ lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 0x3ffffff;
        /* k = 1 */ lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 0x3ffffff;
        /* k = 2 */ lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w2 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
        w2 &= 0x3ffffff;
        /* k = 3 */ lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w3 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
        w3 &= 0x3ffffff;
        /* k = 4 */ lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w4 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
        w4 &= 0x3ffffff;
        /* k = 5 */ lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w5 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
        w5 &= 0x3ffffff;
        /* k = 6 */ lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 0x3ffffff;
        /* k = 7 */ lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 0x3ffffff;
        /* k = 8 */ lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 0x3ffffff;
        /* k = 9 */ lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 0x3ffffff;
        /* k = 10 */ lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 0x3ffffff;
        /* k = 11 */ lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 0x3ffffff;
        /* k = 12 */ lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 0x3ffffff;
        /* k = 13 */ lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 0x3ffffff;
        /* k = 14 */ lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 0x3ffffff;
        /* k = 15 */ lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 0x3ffffff;
        /* k = 16 */ lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 0x3ffffff;
        /* k = 17 */ lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 0x3ffffff;
        /* k = 18 */ lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 0x3ffffff;
        o[0] = w0;
        o[1] = w1;
        o[2] = w2;
        o[3] = w3;
        o[4] = w4;
        o[5] = w5;
        o[6] = w6;
        o[7] = w7;
        o[8] = w8;
        o[9] = w9;
        o[10] = w10;
        o[11] = w11;
        o[12] = w12;
        o[13] = w13;
        o[14] = w14;
        o[15] = w15;
        o[16] = w16;
        o[17] = w17;
        o[18] = w18;
        if (c !== 0) {
            o[19] = c;
            out.length++;
        }
        return out;
    };
    // Polyfill comb
    if (!Math.imul) comb10MulTo = smallMulTo;
    function bigMulTo(self, num, out) {
        out.negative = num.negative ^ self.negative;
        out.length = self.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for(var k = 0; k < out.length - 1; k++){
            // Sum all words with the same `i + j = k` and accumulate `ncarry`,
            // note that ncarry could be >= 0x3ffffff
            var ncarry = hncarry;
            hncarry = 0;
            var rword = carry & 0x3ffffff;
            var maxJ = Math.min(k, num.length - 1);
            for(var j = Math.max(0, k - self.length + 1); j <= maxJ; j++){
                var i = k - j;
                var a = self.words[i] | 0;
                var b = num.words[j] | 0;
                var r = a * b;
                var lo = r & 0x3ffffff;
                ncarry = ncarry + (r / 0x4000000 | 0) | 0;
                lo = lo + rword | 0;
                rword = lo & 0x3ffffff;
                ncarry = ncarry + (lo >>> 26) | 0;
                hncarry += ncarry >>> 26;
                ncarry &= 0x3ffffff;
            }
            out.words[k] = rword;
            carry = ncarry;
            ncarry = hncarry;
        }
        if (carry !== 0) out.words[k] = carry;
        else out.length--;
        return out._strip();
    }
    function jumboMulTo(self, num, out) {
        // Temporary disable, see https://github.com/indutny/bn.js/issues/211
        // var fftm = new FFTM();
        // return fftm.mulp(self, num, out);
        return bigMulTo(self, num, out);
    }
    BN.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) res = comb10MulTo(this, num, out);
        else if (len < 63) res = smallMulTo(this, num, out);
        else if (len < 1024) res = bigMulTo(this, num, out);
        else res = jumboMulTo(this, num, out);
        return res;
    };
    // Cooley-Tukey algorithm for FFT
    // slightly revisited to rely on looping instead of recursion
    function FFTM(x, y) {
        this.x = x;
        this.y = y;
    }
    FFTM.prototype.makeRBT = function makeRBT(N) {
        var t = new Array(N);
        var l = BN.prototype._countBits(N) - 1;
        for(var i = 0; i < N; i++)t[i] = this.revBin(i, l, N);
        return t;
    };
    // Returns binary-reversed representation of `x`
    FFTM.prototype.revBin = function revBin(x, l, N) {
        if (x === 0 || x === N - 1) return x;
        var rb = 0;
        for(var i = 0; i < l; i++){
            rb |= (x & 1) << l - i - 1;
            x >>= 1;
        }
        return rb;
    };
    // Performs "tweedling" phase, therefore 'emulating'
    // behaviour of the recursive algorithm
    FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
        for(var i = 0; i < N; i++){
            rtws[i] = rws[rbt[i]];
            itws[i] = iws[rbt[i]];
        }
    };
    FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N);
        for(var s = 1; s < N; s <<= 1){
            var l = s << 1;
            var rtwdf = Math.cos(2 * Math.PI / l);
            var itwdf = Math.sin(2 * Math.PI / l);
            for(var p = 0; p < N; p += l){
                var rtwdf_ = rtwdf;
                var itwdf_ = itwdf;
                for(var j = 0; j < s; j++){
                    var re = rtws[p + j];
                    var ie = itws[p + j];
                    var ro = rtws[p + j + s];
                    var io = itws[p + j + s];
                    var rx = rtwdf_ * ro - itwdf_ * io;
                    io = rtwdf_ * io + itwdf_ * ro;
                    ro = rx;
                    rtws[p + j] = re + ro;
                    itws[p + j] = ie + io;
                    rtws[p + j + s] = re - ro;
                    itws[p + j + s] = ie - io;
                    /* jshint maxdepth : false */ if (j !== l) {
                        rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                        itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                        rtwdf_ = rx;
                    }
                }
            }
        }
    };
    FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
        var N = Math.max(m, n) | 1;
        var odd = N & 1;
        var i = 0;
        for(N = N / 2 | 0; N; N = N >>> 1)i++;
        return 1 << i + 1 + odd;
    };
    FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
        if (N <= 1) return;
        for(var i = 0; i < N / 2; i++){
            var t = rws[i];
            rws[i] = rws[N - i - 1];
            rws[N - i - 1] = t;
            t = iws[i];
            iws[i] = -iws[N - i - 1];
            iws[N - i - 1] = -t;
        }
    };
    FFTM.prototype.normalize13b = function normalize13b(ws, N) {
        var carry = 0;
        for(var i = 0; i < N / 2; i++){
            var w = Math.round(ws[2 * i + 1] / N) * 0x2000 + Math.round(ws[2 * i] / N) + carry;
            ws[i] = w & 0x3ffffff;
            if (w < 0x4000000) carry = 0;
            else carry = w / 0x4000000 | 0;
        }
        return ws;
    };
    FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
        var carry = 0;
        for(var i = 0; i < len; i++){
            carry = carry + (ws[i] | 0);
            rws[2 * i] = carry & 0x1fff;
            carry = carry >>> 13;
            rws[2 * i + 1] = carry & 0x1fff;
            carry = carry >>> 13;
        }
        // Pad with zeroes
        for(i = 2 * len; i < N; ++i)rws[i] = 0;
        assert(carry === 0);
        assert((carry & -8192) === 0);
    };
    FFTM.prototype.stub = function stub(N) {
        var ph = new Array(N);
        for(var i = 0; i < N; i++)ph[i] = 0;
        return ph;
    };
    FFTM.prototype.mulp = function mulp(x, y, out) {
        var N = 2 * this.guessLen13b(x.length, y.length);
        var rbt = this.makeRBT(N);
        var _ = this.stub(N);
        var rws = new Array(N);
        var rwst = new Array(N);
        var iwst = new Array(N);
        var nrws = new Array(N);
        var nrwst = new Array(N);
        var niwst = new Array(N);
        var rmws = out.words;
        rmws.length = N;
        this.convert13b(x.words, x.length, rws, N);
        this.convert13b(y.words, y.length, nrws, N);
        this.transform(rws, _, rwst, iwst, N, rbt);
        this.transform(nrws, _, nrwst, niwst, N, rbt);
        for(var i = 0; i < N; i++){
            var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
            iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
            rwst[i] = rx;
        }
        this.conjugate(rwst, iwst, N);
        this.transform(rwst, iwst, rmws, _, N, rbt);
        this.conjugate(rmws, _, N);
        this.normalize13b(rmws, N);
        out.negative = x.negative ^ y.negative;
        out.length = x.length + y.length;
        return out._strip();
    };
    // Multiply `this` by `num`
    BN.prototype.mul = function mul(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
    };
    // Multiply employing FFT
    BN.prototype.mulf = function mulf(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
    };
    // In-place Multiplication
    BN.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
    };
    BN.prototype.imuln = function imuln(num) {
        var isNegNum = num < 0;
        if (isNegNum) num = -num;
        assert(typeof num === "number");
        assert(num < 0x4000000);
        // Carry
        var carry = 0;
        for(var i = 0; i < this.length; i++){
            var w = (this.words[i] | 0) * num;
            var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
            carry >>= 26;
            carry += w / 0x4000000 | 0;
            // NOTE: lo is 27bit maximum
            carry += lo >>> 26;
            this.words[i] = lo & 0x3ffffff;
        }
        if (carry !== 0) {
            this.words[i] = carry;
            this.length++;
        }
        return isNegNum ? this.ineg() : this;
    };
    BN.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
    };
    // `this` * `this`
    BN.prototype.sqr = function sqr() {
        return this.mul(this);
    };
    // `this` * `this` in-place
    BN.prototype.isqr = function isqr() {
        return this.imul(this.clone());
    };
    // Math.pow(`this`, `num`)
    BN.prototype.pow = function pow(num) {
        var w = toBitArray(num);
        if (w.length === 0) return new BN(1);
        // Skip leading zeroes
        var res = this;
        for(var i = 0; i < w.length; i++, res = res.sqr()){
            if (w[i] !== 0) break;
        }
        if (++i < w.length) for(var q = res.sqr(); i < w.length; i++, q = q.sqr()){
            if (w[i] === 0) continue;
            res = res.mul(q);
        }
        return res;
    };
    // Shift-left in-place
    BN.prototype.iushln = function iushln(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        var carryMask = 0x3ffffff >>> 26 - r << 26 - r;
        var i;
        if (r !== 0) {
            var carry = 0;
            for(i = 0; i < this.length; i++){
                var newCarry = this.words[i] & carryMask;
                var c = (this.words[i] | 0) - newCarry << r;
                this.words[i] = c | carry;
                carry = newCarry >>> 26 - r;
            }
            if (carry) {
                this.words[i] = carry;
                this.length++;
            }
        }
        if (s !== 0) {
            for(i = this.length - 1; i >= 0; i--)this.words[i + s] = this.words[i];
            for(i = 0; i < s; i++)this.words[i] = 0;
            this.length += s;
        }
        return this._strip();
    };
    BN.prototype.ishln = function ishln(bits) {
        // TODO(indutny): implement me
        assert(this.negative === 0);
        return this.iushln(bits);
    };
    // Shift-right in-place
    // NOTE: `hint` is a lowest bit before trailing zeroes
    // NOTE: if `extended` is present - it will be filled with destroyed bits
    BN.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert(typeof bits === "number" && bits >= 0);
        var h;
        if (hint) h = (hint - hint % 26) / 26;
        else h = 0;
        var r = bits % 26;
        var s = Math.min((bits - r) / 26, this.length);
        var mask = 0x3ffffff ^ 0x3ffffff >>> r << r;
        var maskedWords = extended;
        h -= s;
        h = Math.max(0, h);
        // Extended mode, copy masked part
        if (maskedWords) {
            for(var i = 0; i < s; i++)maskedWords.words[i] = this.words[i];
            maskedWords.length = s;
        }
        if (s === 0) ;
        else if (this.length > s) {
            this.length -= s;
            for(i = 0; i < this.length; i++)this.words[i] = this.words[i + s];
        } else {
            this.words[0] = 0;
            this.length = 1;
        }
        var carry = 0;
        for(i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--){
            var word = this.words[i] | 0;
            this.words[i] = carry << 26 - r | word >>> r;
            carry = word & mask;
        }
        // Push carried bits as a mask
        if (maskedWords && carry !== 0) maskedWords.words[maskedWords.length++] = carry;
        if (this.length === 0) {
            this.words[0] = 0;
            this.length = 1;
        }
        return this._strip();
    };
    BN.prototype.ishrn = function ishrn(bits, hint, extended) {
        // TODO(indutny): implement me
        assert(this.negative === 0);
        return this.iushrn(bits, hint, extended);
    };
    // Shift-left
    BN.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
    };
    BN.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
    };
    // Shift-right
    BN.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
    };
    BN.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
    };
    // Test if n bit is set
    BN.prototype.testn = function testn(bit) {
        assert(typeof bit === "number" && bit >= 0);
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        // Fast case: bit is much higher than all existing words
        if (this.length <= s) return false;
        // Check bit and return
        var w = this.words[s];
        return !!(w & q);
    };
    // Return only lowers bits of number (in-place)
    BN.prototype.imaskn = function imaskn(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        assert(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s) return this;
        if (r !== 0) s++;
        this.length = Math.min(s, this.length);
        if (r !== 0) {
            var mask = 0x3ffffff ^ 0x3ffffff >>> r << r;
            this.words[this.length - 1] &= mask;
        }
        return this._strip();
    };
    // Return only lowers bits of number
    BN.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
    };
    // Add plain number `num` to `this`
    BN.prototype.iaddn = function iaddn(num) {
        assert(typeof num === "number");
        assert(num < 0x4000000);
        if (num < 0) return this.isubn(-num);
        // Possible sign change
        if (this.negative !== 0) {
            if (this.length === 1 && (this.words[0] | 0) <= num) {
                this.words[0] = num - (this.words[0] | 0);
                this.negative = 0;
                return this;
            }
            this.negative = 0;
            this.isubn(num);
            this.negative = 1;
            return this;
        }
        // Add without checks
        return this._iaddn(num);
    };
    BN.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        // Carry
        for(var i = 0; i < this.length && this.words[i] >= 0x4000000; i++){
            this.words[i] -= 0x4000000;
            if (i === this.length - 1) this.words[i + 1] = 1;
            else this.words[i + 1]++;
        }
        this.length = Math.max(this.length, i + 1);
        return this;
    };
    // Subtract plain number `num` from `this`
    BN.prototype.isubn = function isubn(num) {
        assert(typeof num === "number");
        assert(num < 0x4000000);
        if (num < 0) return this.iaddn(-num);
        if (this.negative !== 0) {
            this.negative = 0;
            this.iaddn(num);
            this.negative = 1;
            return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
            this.words[0] = -this.words[0];
            this.negative = 1;
        } else // Carry
        for(var i = 0; i < this.length && this.words[i] < 0; i++){
            this.words[i] += 0x4000000;
            this.words[i + 1] -= 1;
        }
        return this._strip();
    };
    BN.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
    };
    BN.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
    };
    BN.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
    };
    BN.prototype.abs = function abs() {
        return this.clone().iabs();
    };
    BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len = num.length + shift;
        var i;
        this._expand(len);
        var w;
        var carry = 0;
        for(i = 0; i < num.length; i++){
            w = (this.words[i + shift] | 0) + carry;
            var right = (num.words[i] | 0) * mul;
            w -= right & 0x3ffffff;
            carry = (w >> 26) - (right / 0x4000000 | 0);
            this.words[i + shift] = w & 0x3ffffff;
        }
        for(; i < this.length - shift; i++){
            w = (this.words[i + shift] | 0) + carry;
            carry = w >> 26;
            this.words[i + shift] = w & 0x3ffffff;
        }
        if (carry === 0) return this._strip();
        // Subtraction overflow
        assert(carry === -1);
        carry = 0;
        for(i = 0; i < this.length; i++){
            w = -(this.words[i] | 0) + carry;
            carry = w >> 26;
            this.words[i] = w & 0x3ffffff;
        }
        this.negative = 1;
        return this._strip();
    };
    BN.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a = this.clone();
        var b = num;
        // Normalize
        var bhi = b.words[b.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
            b = b.ushln(shift);
            a.iushln(shift);
            bhi = b.words[b.length - 1] | 0;
        }
        // Initialize quotient
        var m = a.length - b.length;
        var q;
        if (mode !== "mod") {
            q = new BN(null);
            q.length = m + 1;
            q.words = new Array(q.length);
            for(var i = 0; i < q.length; i++)q.words[i] = 0;
        }
        var diff = a.clone()._ishlnsubmul(b, 1, m);
        if (diff.negative === 0) {
            a = diff;
            if (q) q.words[m] = 1;
        }
        for(var j = m - 1; j >= 0; j--){
            var qj = (a.words[b.length + j] | 0) * 0x4000000 + (a.words[b.length + j - 1] | 0);
            // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
            // (0x7ffffff)
            qj = Math.min(qj / bhi | 0, 0x3ffffff);
            a._ishlnsubmul(b, qj, j);
            while(a.negative !== 0){
                qj--;
                a.negative = 0;
                a._ishlnsubmul(b, 1, j);
                if (!a.isZero()) a.negative ^= 1;
            }
            if (q) q.words[j] = qj;
        }
        if (q) q._strip();
        a._strip();
        // Denormalize
        if (mode !== "div" && shift !== 0) a.iushrn(shift);
        return {
            div: q || null,
            mod: a
        };
    };
    // NOTE: 1) `mode` can be set to `mod` to request mod only,
    //       to `div` to request div only, or be absent to
    //       request both div & mod
    //       2) `positive` is true if unsigned mod is requested
    BN.prototype.divmod = function divmod(num, mode, positive) {
        assert(!num.isZero());
        if (this.isZero()) return {
            div: new BN(0),
            mod: new BN(0)
        };
        var div, mod, res;
        if (this.negative !== 0 && num.negative === 0) {
            res = this.neg().divmod(num, mode);
            if (mode !== "mod") div = res.div.neg();
            if (mode !== "div") {
                mod = res.mod.neg();
                if (positive && mod.negative !== 0) mod.iadd(num);
            }
            return {
                div: div,
                mod: mod
            };
        }
        if (this.negative === 0 && num.negative !== 0) {
            res = this.divmod(num.neg(), mode);
            if (mode !== "mod") div = res.div.neg();
            return {
                div: div,
                mod: res.mod
            };
        }
        if ((this.negative & num.negative) !== 0) {
            res = this.neg().divmod(num.neg(), mode);
            if (mode !== "div") {
                mod = res.mod.neg();
                if (positive && mod.negative !== 0) mod.isub(num);
            }
            return {
                div: res.div,
                mod: mod
            };
        }
        // Both numbers are positive at this point
        // Strip both numbers to approximate shift value
        if (num.length > this.length || this.cmp(num) < 0) return {
            div: new BN(0),
            mod: this
        };
        // Very short reduction
        if (num.length === 1) {
            if (mode === "div") return {
                div: this.divn(num.words[0]),
                mod: null
            };
            if (mode === "mod") return {
                div: null,
                mod: new BN(this.modrn(num.words[0]))
            };
            return {
                div: this.divn(num.words[0]),
                mod: new BN(this.modrn(num.words[0]))
            };
        }
        return this._wordDiv(num, mode);
    };
    // Find `this` / `num`
    BN.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
    };
    // Find `this` % `num`
    BN.prototype.mod = function mod(num) {
        return this.divmod(num, "mod", false).mod;
    };
    BN.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
    };
    // Find Round(`this` / `num`)
    BN.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        // Fast case - exact division
        if (dm.mod.isZero()) return dm.div;
        var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r2 = num.andln(1);
        var cmp = mod.cmp(half);
        // Round down
        if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;
        // Round up
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
    };
    BN.prototype.modrn = function modrn(num) {
        var isNegNum = num < 0;
        if (isNegNum) num = -num;
        assert(num <= 0x3ffffff);
        var p = 67108864 % num;
        var acc = 0;
        for(var i = this.length - 1; i >= 0; i--)acc = (p * acc + (this.words[i] | 0)) % num;
        return isNegNum ? -acc : acc;
    };
    // WARNING: DEPRECATED
    BN.prototype.modn = function modn(num) {
        return this.modrn(num);
    };
    // In-place division by number
    BN.prototype.idivn = function idivn(num) {
        var isNegNum = num < 0;
        if (isNegNum) num = -num;
        assert(num <= 0x3ffffff);
        var carry = 0;
        for(var i = this.length - 1; i >= 0; i--){
            var w = (this.words[i] | 0) + carry * 0x4000000;
            this.words[i] = w / num | 0;
            carry = w % num;
        }
        this._strip();
        return isNegNum ? this.ineg() : this;
    };
    BN.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
    };
    BN.prototype.egcd = function egcd(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var x = this;
        var y = p.clone();
        if (x.negative !== 0) x = x.umod(p);
        else x = x.clone();
        // A * x + B * y = x
        var A = new BN(1);
        var B = new BN(0);
        // C * x + D * y = y
        var C = new BN(0);
        var D = new BN(1);
        var g = 0;
        while(x.isEven() && y.isEven()){
            x.iushrn(1);
            y.iushrn(1);
            ++g;
        }
        var yp = y.clone();
        var xp = x.clone();
        while(!x.isZero()){
            for(var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
            if (i > 0) {
                x.iushrn(i);
                while(i-- > 0){
                    if (A.isOdd() || B.isOdd()) {
                        A.iadd(yp);
                        B.isub(xp);
                    }
                    A.iushrn(1);
                    B.iushrn(1);
                }
            }
            for(var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
            if (j > 0) {
                y.iushrn(j);
                while(j-- > 0){
                    if (C.isOdd() || D.isOdd()) {
                        C.iadd(yp);
                        D.isub(xp);
                    }
                    C.iushrn(1);
                    D.iushrn(1);
                }
            }
            if (x.cmp(y) >= 0) {
                x.isub(y);
                A.isub(C);
                B.isub(D);
            } else {
                y.isub(x);
                C.isub(A);
                D.isub(B);
            }
        }
        return {
            a: C,
            b: D,
            gcd: y.iushln(g)
        };
    };
    // This is reduced incarnation of the binary EEA
    // above, designated to invert members of the
    // _prime_ fields F(p) at a maximal speed
    BN.prototype._invmp = function _invmp(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var a = this;
        var b = p.clone();
        if (a.negative !== 0) a = a.umod(p);
        else a = a.clone();
        var x1 = new BN(1);
        var x2 = new BN(0);
        var delta = b.clone();
        while(a.cmpn(1) > 0 && b.cmpn(1) > 0){
            for(var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
            if (i > 0) {
                a.iushrn(i);
                while(i-- > 0){
                    if (x1.isOdd()) x1.iadd(delta);
                    x1.iushrn(1);
                }
            }
            for(var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
            if (j > 0) {
                b.iushrn(j);
                while(j-- > 0){
                    if (x2.isOdd()) x2.iadd(delta);
                    x2.iushrn(1);
                }
            }
            if (a.cmp(b) >= 0) {
                a.isub(b);
                x1.isub(x2);
            } else {
                b.isub(a);
                x2.isub(x1);
            }
        }
        var res;
        if (a.cmpn(1) === 0) res = x1;
        else res = x2;
        if (res.cmpn(0) < 0) res.iadd(p);
        return res;
    };
    BN.prototype.gcd = function gcd(num) {
        if (this.isZero()) return num.abs();
        if (num.isZero()) return this.abs();
        var a = this.clone();
        var b = num.clone();
        a.negative = 0;
        b.negative = 0;
        // Remove common factor of two
        for(var shift = 0; a.isEven() && b.isEven(); shift++){
            a.iushrn(1);
            b.iushrn(1);
        }
        do {
            while(a.isEven())a.iushrn(1);
            while(b.isEven())b.iushrn(1);
            var r = a.cmp(b);
            if (r < 0) {
                // Swap `a` and `b` to make `a` always bigger than `b`
                var t = a;
                a = b;
                b = t;
            } else if (r === 0 || b.cmpn(1) === 0) break;
            a.isub(b);
        }while (true);
        return b.iushln(shift);
    };
    // Invert number in the field F(num)
    BN.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
    };
    BN.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
    };
    BN.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
    };
    // And first word and num
    BN.prototype.andln = function andln(num) {
        return this.words[0] & num;
    };
    // Increment at the bit position in-line
    BN.prototype.bincn = function bincn(bit) {
        assert(typeof bit === "number");
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        // Fast case: bit is much higher than all existing words
        if (this.length <= s) {
            this._expand(s + 1);
            this.words[s] |= q;
            return this;
        }
        // Add bit and propagate, if needed
        var carry = q;
        for(var i = s; carry !== 0 && i < this.length; i++){
            var w = this.words[i] | 0;
            w += carry;
            carry = w >>> 26;
            w &= 0x3ffffff;
            this.words[i] = w;
        }
        if (carry !== 0) {
            this.words[i] = carry;
            this.length++;
        }
        return this;
    };
    BN.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
    };
    BN.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative) return -1;
        if (this.negative === 0 && negative) return 1;
        this._strip();
        var res;
        if (this.length > 1) res = 1;
        else {
            if (negative) num = -num;
            assert(num <= 0x3ffffff, "Number is too big");
            var w = this.words[0] | 0;
            res = w === num ? 0 : w < num ? -1 : 1;
        }
        if (this.negative !== 0) return -res | 0;
        return res;
    };
    // Compare two numbers and return:
    // 1 - if `this` > `num`
    // 0 - if `this` == `num`
    // -1 - if `this` < `num`
    BN.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0) return -1;
        if (this.negative === 0 && num.negative !== 0) return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0) return -res | 0;
        return res;
    };
    // Unsigned comparison
    BN.prototype.ucmp = function ucmp(num) {
        // At this point both numbers have the same sign
        if (this.length > num.length) return 1;
        if (this.length < num.length) return -1;
        var res = 0;
        for(var i = this.length - 1; i >= 0; i--){
            var a = this.words[i] | 0;
            var b = num.words[i] | 0;
            if (a === b) continue;
            if (a < b) res = -1;
            else if (a > b) res = 1;
            break;
        }
        return res;
    };
    BN.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
    };
    BN.prototype.gt = function gt(num) {
        return this.cmp(num) === 1;
    };
    BN.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
    };
    BN.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
    };
    BN.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
    };
    BN.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
    };
    BN.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
    };
    BN.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
    };
    BN.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
    };
    BN.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
    };
    //
    // A reduce context, could be using montgomery or something better, depending
    // on the `m` itself.
    //
    BN.red = function red(num) {
        return new Red(num);
    };
    BN.prototype.toRed = function toRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        assert(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
    };
    BN.prototype.fromRed = function fromRed() {
        assert(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
    };
    BN.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
    };
    BN.prototype.forceRed = function forceRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
    };
    BN.prototype.redAdd = function redAdd(num) {
        assert(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
    };
    BN.prototype.redIAdd = function redIAdd(num) {
        assert(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
    };
    BN.prototype.redSub = function redSub(num) {
        assert(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
    };
    BN.prototype.redISub = function redISub(num) {
        assert(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
    };
    BN.prototype.redShl = function redShl(num) {
        assert(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
    };
    BN.prototype.redMul = function redMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
    };
    BN.prototype.redIMul = function redIMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
    };
    BN.prototype.redSqr = function redSqr() {
        assert(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
    };
    BN.prototype.redISqr = function redISqr() {
        assert(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
    };
    // Square root over p
    BN.prototype.redSqrt = function redSqrt() {
        assert(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
    };
    BN.prototype.redInvm = function redInvm() {
        assert(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
    };
    // Return negative clone of `this` % `red modulo`
    BN.prototype.redNeg = function redNeg() {
        assert(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
    };
    BN.prototype.redPow = function redPow(num) {
        assert(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
    };
    // Prime numbers with efficient reduction
    var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
    };
    // Pseudo-Mersenne prime
    function MPrime(name, p) {
        // P = 2 ^ N - K
        this.name = name;
        this.p = new BN(p, 16);
        this.n = this.p.bitLength();
        this.k = new BN(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
    }
    MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
    };
    MPrime.prototype.ireduce = function ireduce(num) {
        // Assumes that `num` is less than `P^2`
        // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
        var r = num;
        var rlen;
        do {
            this.split(r, this.tmp);
            r = this.imulK(r);
            r = r.iadd(this.tmp);
            rlen = r.bitLength();
        }while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
        if (cmp === 0) {
            r.words[0] = 0;
            r.length = 1;
        } else if (cmp > 0) r.isub(this.p);
        else if (r.strip !== undefined) // r is a BN v4 instance
        r.strip();
        else // r is a BN v5 instance
        r._strip();
        return r;
    };
    MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
    };
    MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
    };
    function K256() {
        MPrime.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
    }
    inherits(K256, MPrime);
    K256.prototype.split = function split(input, output) {
        // 256 = 9 * 26 + 22
        var mask = 0x3fffff;
        var outLen = Math.min(input.length, 9);
        for(var i = 0; i < outLen; i++)output.words[i] = input.words[i];
        output.length = outLen;
        if (input.length <= 9) {
            input.words[0] = 0;
            input.length = 1;
            return;
        }
        // Shift by 9 limbs
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for(i = 10; i < input.length; i++){
            var next = input.words[i] | 0;
            input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
            prev = next;
        }
        prev >>>= 22;
        input.words[i - 10] = prev;
        if (prev === 0 && input.length > 10) input.length -= 10;
        else input.length -= 9;
    };
    K256.prototype.imulK = function imulK(num) {
        // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
        var lo = 0;
        for(var i = 0; i < num.length; i++){
            var w = num.words[i] | 0;
            lo += w * 0x3d1;
            num.words[i] = lo & 0x3ffffff;
            lo = w * 0x40 + (lo / 0x4000000 | 0);
        }
        // Fast length reduction
        if (num.words[num.length - 1] === 0) {
            num.length--;
            if (num.words[num.length - 1] === 0) num.length--;
        }
        return num;
    };
    function P224() {
        MPrime.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
    }
    inherits(P224, MPrime);
    function P192() {
        MPrime.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
    }
    inherits(P192, MPrime);
    function P25519() {
        // 2 ^ 255 - 19
        MPrime.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
    }
    inherits(P25519, MPrime);
    P25519.prototype.imulK = function imulK(num) {
        // K = 0x13
        var carry = 0;
        for(var i = 0; i < num.length; i++){
            var hi = (num.words[i] | 0) * 0x13 + carry;
            var lo = hi & 0x3ffffff;
            hi >>>= 26;
            num.words[i] = lo;
            carry = hi;
        }
        if (carry !== 0) num.words[num.length++] = carry;
        return num;
    };
    // Exported mostly for testing purposes, use plain name instead
    BN._prime = function prime(name) {
        // Cached version of prime
        if (primes[name]) return primes[name];
        var prime;
        if (name === "k256") prime = new K256();
        else if (name === "p224") prime = new P224();
        else if (name === "p192") prime = new P192();
        else if (name === "p25519") prime = new P25519();
        else throw new Error("Unknown prime " + name);
        primes[name] = prime;
        return prime;
    };
    //
    // Base reduction engine
    //
    function Red(m) {
        if (typeof m === "string") {
            var prime = BN._prime(m);
            this.m = prime.p;
            this.prime = prime;
        } else {
            assert(m.gtn(1), "modulus must be greater than 1");
            this.m = m;
            this.prime = null;
        }
    }
    Red.prototype._verify1 = function _verify1(a) {
        assert(a.negative === 0, "red works only with positives");
        assert(a.red, "red works only with red numbers");
    };
    Red.prototype._verify2 = function _verify2(a, b) {
        assert((a.negative | b.negative) === 0, "red works only with positives");
        assert(a.red && a.red === b.red, "red works only with red numbers");
    };
    Red.prototype.imod = function imod(a) {
        if (this.prime) return this.prime.ireduce(a)._forceRed(this);
        move(a, a.umod(this.m)._forceRed(this));
        return a;
    };
    Red.prototype.neg = function neg(a) {
        if (a.isZero()) return a.clone();
        return this.m.sub(a)._forceRed(this);
    };
    Red.prototype.add = function add(a, b) {
        this._verify2(a, b);
        var res = a.add(b);
        if (res.cmp(this.m) >= 0) res.isub(this.m);
        return res._forceRed(this);
    };
    Red.prototype.iadd = function iadd(a, b) {
        this._verify2(a, b);
        var res = a.iadd(b);
        if (res.cmp(this.m) >= 0) res.isub(this.m);
        return res;
    };
    Red.prototype.sub = function sub(a, b) {
        this._verify2(a, b);
        var res = a.sub(b);
        if (res.cmpn(0) < 0) res.iadd(this.m);
        return res._forceRed(this);
    };
    Red.prototype.isub = function isub(a, b) {
        this._verify2(a, b);
        var res = a.isub(b);
        if (res.cmpn(0) < 0) res.iadd(this.m);
        return res;
    };
    Red.prototype.shl = function shl(a, num) {
        this._verify1(a);
        return this.imod(a.ushln(num));
    };
    Red.prototype.imul = function imul(a, b) {
        this._verify2(a, b);
        return this.imod(a.imul(b));
    };
    Red.prototype.mul = function mul(a, b) {
        this._verify2(a, b);
        return this.imod(a.mul(b));
    };
    Red.prototype.isqr = function isqr(a) {
        return this.imul(a, a.clone());
    };
    Red.prototype.sqr = function sqr(a) {
        return this.mul(a, a);
    };
    Red.prototype.sqrt = function sqrt(a) {
        if (a.isZero()) return a.clone();
        var mod3 = this.m.andln(3);
        assert(mod3 % 2 === 1);
        // Fast case
        if (mod3 === 3) {
            var pow = this.m.add(new BN(1)).iushrn(2);
            return this.pow(a, pow);
        }
        // Tonelli-Shanks algorithm (Totally unoptimized and slow)
        //
        // Find Q and S, that Q * 2 ^ S = (P - 1)
        var q = this.m.subn(1);
        var s = 0;
        while(!q.isZero() && q.andln(1) === 0){
            s++;
            q.iushrn(1);
        }
        assert(!q.isZero());
        var one = new BN(1).toRed(this);
        var nOne = one.redNeg();
        // Find quadratic non-residue
        // NOTE: Max is such because of generalized Riemann hypothesis.
        var lpow = this.m.subn(1).iushrn(1);
        var z = this.m.bitLength();
        z = new BN(2 * z * z).toRed(this);
        while(this.pow(z, lpow).cmp(nOne) !== 0)z.redIAdd(nOne);
        var c = this.pow(z, q);
        var r = this.pow(a, q.addn(1).iushrn(1));
        var t = this.pow(a, q);
        var m = s;
        while(t.cmp(one) !== 0){
            var tmp = t;
            for(var i = 0; tmp.cmp(one) !== 0; i++)tmp = tmp.redSqr();
            assert(i < m);
            var b = this.pow(c, new BN(1).iushln(m - i - 1));
            r = r.redMul(b);
            c = b.redSqr();
            t = t.redMul(c);
            m = i;
        }
        return r;
    };
    Red.prototype.invm = function invm(a) {
        var inv = a._invmp(this.m);
        if (inv.negative !== 0) {
            inv.negative = 0;
            return this.imod(inv).redNeg();
        } else return this.imod(inv);
    };
    Red.prototype.pow = function pow(a, num) {
        if (num.isZero()) return new BN(1).toRed(this);
        if (num.cmpn(1) === 0) return a.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN(1).toRed(this);
        wnd[1] = a;
        for(var i = 2; i < wnd.length; i++)wnd[i] = this.mul(wnd[i - 1], a);
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) start = 26;
        for(i = num.length - 1; i >= 0; i--){
            var word = num.words[i];
            for(var j = start - 1; j >= 0; j--){
                var bit = word >> j & 1;
                if (res !== wnd[0]) res = this.sqr(res);
                if (bit === 0 && current === 0) {
                    currentLen = 0;
                    continue;
                }
                current <<= 1;
                current |= bit;
                currentLen++;
                if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;
                res = this.mul(res, wnd[current]);
                currentLen = 0;
                current = 0;
            }
            start = 26;
        }
        return res;
    };
    Red.prototype.convertTo = function convertTo(num) {
        var r = num.umod(this.m);
        return r === num ? r.clone() : r;
    };
    Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
    };
    //
    // Montgomery method engine
    //
    BN.mont = function mont(num) {
        return new Mont(num);
    };
    function Mont(m) {
        Red.call(this, m);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) this.shift += 26 - this.shift % 26;
        this.r = new BN(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
    }
    inherits(Mont, Red);
    Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
    };
    Mont.prototype.convertFrom = function convertFrom(num) {
        var r = this.imod(num.mul(this.rinv));
        r.red = null;
        return r;
    };
    Mont.prototype.imul = function imul(a, b) {
        if (a.isZero() || b.isZero()) {
            a.words[0] = 0;
            a.length = 1;
            return a;
        }
        var t = a.imul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) res = u.isub(this.m);
        else if (u.cmpn(0) < 0) res = u.iadd(this.m);
        return res._forceRed(this);
    };
    Mont.prototype.mul = function mul(a, b) {
        if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);
        var t = a.mul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) res = u.isub(this.m);
        else if (u.cmpn(0) < 0) res = u.iadd(this.m);
        return res._forceRed(this);
    };
    Mont.prototype.invm = function invm(a) {
        // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
        var res = this.imod(a._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
    };
})(module, this);

},{"bd440367abe2ded7":"jhUEF"}],"jhUEF":[function(require,module,exports) {
"use strict";

},{}],"4ji3p":[function(require,module,exports) {
var basex = require("819c30266ae09475");
var ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
module.exports = basex(ALPHABET);

},{"819c30266ae09475":"inVbl"}],"inVbl":[function(require,module,exports) {
"use strict";
// base-x encoding / decoding
// Copyright (c) 2018 base-x contributors
// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)
// Distributed under the MIT software license, see the accompanying
// file LICENSE or http://www.opensource.org/licenses/mit-license.php.
// @ts-ignore
var _Buffer = require("85b264801a1b57da").Buffer;
function base(ALPHABET) {
    if (ALPHABET.length >= 255) throw new TypeError("Alphabet too long");
    var BASE_MAP = new Uint8Array(256);
    for(var j = 0; j < BASE_MAP.length; j++)BASE_MAP[j] = 255;
    for(var i = 0; i < ALPHABET.length; i++){
        var x = ALPHABET.charAt(i);
        var xc = x.charCodeAt(0);
        if (BASE_MAP[xc] !== 255) throw new TypeError(x + " is ambiguous");
        BASE_MAP[xc] = i;
    }
    var BASE = ALPHABET.length;
    var LEADER = ALPHABET.charAt(0);
    var FACTOR = Math.log(BASE) / Math.log(256) // log(BASE) / log(256), rounded up
    ;
    var iFACTOR = Math.log(256) / Math.log(BASE) // log(256) / log(BASE), rounded up
    ;
    function encode(source) {
        if (Array.isArray(source) || source instanceof Uint8Array) source = _Buffer.from(source);
        if (!_Buffer.isBuffer(source)) throw new TypeError("Expected Buffer");
        if (source.length === 0) return "";
        // Skip & count leading zeroes.
        var zeroes = 0;
        var length = 0;
        var pbegin = 0;
        var pend = source.length;
        while(pbegin !== pend && source[pbegin] === 0){
            pbegin++;
            zeroes++;
        }
        // Allocate enough space in big-endian base58 representation.
        var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
        var b58 = new Uint8Array(size);
        // Process the bytes.
        while(pbegin !== pend){
            var carry = source[pbegin];
            // Apply "b58 = b58 * 256 + ch".
            var i = 0;
            for(var it1 = size - 1; (carry !== 0 || i < length) && it1 !== -1; it1--, i++){
                carry += 256 * b58[it1] >>> 0;
                b58[it1] = carry % BASE >>> 0;
                carry = carry / BASE >>> 0;
            }
            if (carry !== 0) throw new Error("Non-zero carry");
            length = i;
            pbegin++;
        }
        // Skip leading zeroes in base58 result.
        var it2 = size - length;
        while(it2 !== size && b58[it2] === 0)it2++;
        // Translate the result into a string.
        var str = LEADER.repeat(zeroes);
        for(; it2 < size; ++it2)str += ALPHABET.charAt(b58[it2]);
        return str;
    }
    function decodeUnsafe(source) {
        if (typeof source !== "string") throw new TypeError("Expected String");
        if (source.length === 0) return _Buffer.alloc(0);
        var psz = 0;
        // Skip and count leading '1's.
        var zeroes = 0;
        var length = 0;
        while(source[psz] === LEADER){
            zeroes++;
            psz++;
        }
        // Allocate enough space in big-endian base256 representation.
        var size = (source.length - psz) * FACTOR + 1 >>> 0 // log(58) / log(256), rounded up.
        ;
        var b256 = new Uint8Array(size);
        // Process the characters.
        while(psz < source.length){
            // Decode character
            var carry = BASE_MAP[source.charCodeAt(psz)];
            // Invalid character
            if (carry === 255) return;
            var i = 0;
            for(var it3 = size - 1; (carry !== 0 || i < length) && it3 !== -1; it3--, i++){
                carry += BASE * b256[it3] >>> 0;
                b256[it3] = carry % 256 >>> 0;
                carry = carry / 256 >>> 0;
            }
            if (carry !== 0) throw new Error("Non-zero carry");
            length = i;
            psz++;
        }
        // Skip leading zeroes in b256.
        var it4 = size - length;
        while(it4 !== size && b256[it4] === 0)it4++;
        var vch = _Buffer.allocUnsafe(zeroes + (size - it4));
        vch.fill(0x00, 0, zeroes);
        var j = zeroes;
        while(it4 !== size)vch[j++] = b256[it4++];
        return vch;
    }
    function decode(string) {
        var buffer = decodeUnsafe(string);
        if (buffer) return buffer;
        throw new Error("Non-base" + BASE + " character");
    }
    return {
        encode: encode,
        decodeUnsafe: decodeUnsafe,
        decode: decode
    };
}
module.exports = base;

},{"85b264801a1b57da":"eW7r9"}],"eW7r9":[function(require,module,exports) {
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */ /* eslint-disable node/no-deprecated-api */ var buffer = require("7e0d6ecd698c3ca6");
var Buffer = buffer.Buffer;
// alternative to using Object.keys for old browsers
function copyProps(src, dst) {
    for(var key in src)dst[key] = src[key];
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) module.exports = buffer;
else {
    // Copy properties from require('buffer')
    copyProps(buffer, exports);
    exports.Buffer = SafeBuffer;
}
function SafeBuffer(arg, encodingOrOffset, length) {
    return Buffer(arg, encodingOrOffset, length);
}
SafeBuffer.prototype = Object.create(Buffer.prototype);
// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer);
SafeBuffer.from = function(arg, encodingOrOffset, length) {
    if (typeof arg === "number") throw new TypeError("Argument must not be a number");
    return Buffer(arg, encodingOrOffset, length);
};
SafeBuffer.alloc = function(size, fill, encoding) {
    if (typeof size !== "number") throw new TypeError("Argument must be a number");
    var buf = Buffer(size);
    if (fill !== undefined) {
        if (typeof encoding === "string") buf.fill(fill, encoding);
        else buf.fill(fill);
    } else buf.fill(0);
    return buf;
};
SafeBuffer.allocUnsafe = function(size) {
    if (typeof size !== "number") throw new TypeError("Argument must be a number");
    return Buffer(size);
};
SafeBuffer.allocUnsafeSlow = function(size) {
    if (typeof size !== "number") throw new TypeError("Argument must be a number");
    return buffer.SlowBuffer(size);
};

},{"7e0d6ecd698c3ca6":"fCgem"}],"JjjO8":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.sha224 = exports.sha256 = exports.SHA256 = void 0;
const _md_js_1 = require("26520c767e1e1930");
const utils_js_1 = require("dd2d5fab8dc388cf");
// SHA2-256 need to try 2^128 hashes to execute birthday attack.
// BTC network is doing 2^67 hashes/sec as per early 2023.
// Round constants:
// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)
// prettier-ignore
const SHA256_K = /* @__PURE__ */ new Uint32Array([
    0x428a2f98,
    0x71374491,
    0xb5c0fbcf,
    0xe9b5dba5,
    0x3956c25b,
    0x59f111f1,
    0x923f82a4,
    0xab1c5ed5,
    0xd807aa98,
    0x12835b01,
    0x243185be,
    0x550c7dc3,
    0x72be5d74,
    0x80deb1fe,
    0x9bdc06a7,
    0xc19bf174,
    0xe49b69c1,
    0xefbe4786,
    0x0fc19dc6,
    0x240ca1cc,
    0x2de92c6f,
    0x4a7484aa,
    0x5cb0a9dc,
    0x76f988da,
    0x983e5152,
    0xa831c66d,
    0xb00327c8,
    0xbf597fc7,
    0xc6e00bf3,
    0xd5a79147,
    0x06ca6351,
    0x14292967,
    0x27b70a85,
    0x2e1b2138,
    0x4d2c6dfc,
    0x53380d13,
    0x650a7354,
    0x766a0abb,
    0x81c2c92e,
    0x92722c85,
    0xa2bfe8a1,
    0xa81a664b,
    0xc24b8b70,
    0xc76c51a3,
    0xd192e819,
    0xd6990624,
    0xf40e3585,
    0x106aa070,
    0x19a4c116,
    0x1e376c08,
    0x2748774c,
    0x34b0bcb5,
    0x391c0cb3,
    0x4ed8aa4a,
    0x5b9cca4f,
    0x682e6ff3,
    0x748f82ee,
    0x78a5636f,
    0x84c87814,
    0x8cc70208,
    0x90befffa,
    0xa4506ceb,
    0xbef9a3f7,
    0xc67178f2
]);
// Initial state:
// first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19
// prettier-ignore
const SHA256_IV = /* @__PURE__ */ new Uint32Array([
    0x6a09e667,
    0xbb67ae85,
    0x3c6ef372,
    0xa54ff53a,
    0x510e527f,
    0x9b05688c,
    0x1f83d9ab,
    0x5be0cd19
]);
// Temporary buffer, not used to store anything between runs
// Named this way because it matches specification.
const SHA256_W = /* @__PURE__ */ new Uint32Array(64);
class SHA256 extends _md_js_1.HashMD {
    constructor(){
        super(64, 32, 8, false);
        // We cannot use array here since array allows indexing by variable
        // which means optimizer/compiler cannot use registers.
        this.A = SHA256_IV[0] | 0;
        this.B = SHA256_IV[1] | 0;
        this.C = SHA256_IV[2] | 0;
        this.D = SHA256_IV[3] | 0;
        this.E = SHA256_IV[4] | 0;
        this.F = SHA256_IV[5] | 0;
        this.G = SHA256_IV[6] | 0;
        this.H = SHA256_IV[7] | 0;
    }
    get() {
        const { A, B, C, D, E, F, G, H } = this;
        return [
            A,
            B,
            C,
            D,
            E,
            F,
            G,
            H
        ];
    }
    // prettier-ignore
    set(A, B, C, D, E, F, G, H) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
        this.E = E | 0;
        this.F = F | 0;
        this.G = G | 0;
        this.H = H | 0;
    }
    process(view, offset) {
        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array
        for(let i = 0; i < 16; i++, offset += 4)SHA256_W[i] = view.getUint32(offset, false);
        for(let i = 16; i < 64; i++){
            const W15 = SHA256_W[i - 15];
            const W2 = SHA256_W[i - 2];
            const s0 = (0, utils_js_1.rotr)(W15, 7) ^ (0, utils_js_1.rotr)(W15, 18) ^ W15 >>> 3;
            const s1 = (0, utils_js_1.rotr)(W2, 17) ^ (0, utils_js_1.rotr)(W2, 19) ^ W2 >>> 10;
            SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
        }
        // Compression function main loop, 64 rounds
        let { A, B, C, D, E, F, G, H } = this;
        for(let i = 0; i < 64; i++){
            const sigma1 = (0, utils_js_1.rotr)(E, 6) ^ (0, utils_js_1.rotr)(E, 11) ^ (0, utils_js_1.rotr)(E, 25);
            const T1 = H + sigma1 + (0, _md_js_1.Chi)(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;
            const sigma0 = (0, utils_js_1.rotr)(A, 2) ^ (0, utils_js_1.rotr)(A, 13) ^ (0, utils_js_1.rotr)(A, 22);
            const T2 = sigma0 + (0, _md_js_1.Maj)(A, B, C) | 0;
            H = G;
            G = F;
            F = E;
            E = D + T1 | 0;
            D = C;
            C = B;
            B = A;
            A = T1 + T2 | 0;
        }
        // Add the compressed chunk to the current hash value
        A = A + this.A | 0;
        B = B + this.B | 0;
        C = C + this.C | 0;
        D = D + this.D | 0;
        E = E + this.E | 0;
        F = F + this.F | 0;
        G = G + this.G | 0;
        H = H + this.H | 0;
        this.set(A, B, C, D, E, F, G, H);
    }
    roundClean() {
        SHA256_W.fill(0);
    }
    destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0);
        this.buffer.fill(0);
    }
}
exports.SHA256 = SHA256;
// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf
class SHA224 extends SHA256 {
    constructor(){
        super();
        this.A = -1056596264;
        this.B = 914150663;
        this.C = 812702999;
        this.D = -150054599;
        this.E = -4191439;
        this.F = 1750603025;
        this.G = 1694076839;
        this.H = -1090891868;
        this.outputLen = 28;
    }
}
/**
 * SHA2-256 hash function
 * @param message - data that would be hashed
 */ exports.sha256 = (0, utils_js_1.wrapConstructor)(()=>new SHA256());
/**
 * SHA2-224 hash function
 */ exports.sha224 = (0, utils_js_1.wrapConstructor)(()=>new SHA224());

},{"26520c767e1e1930":"4Doa0","dd2d5fab8dc388cf":"2ehgp"}],"4JCmN":[function(require,module,exports) {
var Buffer = require("699c164eb7aea5db").Buffer;
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, {
        enumerable: true,
        get: function() {
            return m[k];
        }
    });
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.deserializeUnchecked = exports.deserialize = exports.serialize = exports.BinaryReader = exports.BinaryWriter = exports.BorshError = exports.baseDecode = exports.baseEncode = void 0;
const bn_js_1 = __importDefault(require("17e7c0a10366aaf7"));
const bs58_1 = __importDefault(require("d1e02929d3f43eae"));
// TODO: Make sure this polyfill not included when not required
const encoding = __importStar(require("b378096fead01c9a"));
const ResolvedTextDecoder = typeof TextDecoder !== "function" ? encoding.TextDecoder : TextDecoder;
const textDecoder = new ResolvedTextDecoder("utf-8", {
    fatal: true
});
function baseEncode(value) {
    if (typeof value === "string") value = Buffer.from(value, "utf8");
    return bs58_1.default.encode(Buffer.from(value));
}
exports.baseEncode = baseEncode;
function baseDecode(value) {
    return Buffer.from(bs58_1.default.decode(value));
}
exports.baseDecode = baseDecode;
const INITIAL_LENGTH = 1024;
class BorshError extends Error {
    constructor(message){
        super(message);
        this.fieldPath = [];
        this.originalMessage = message;
    }
    addToFieldPath(fieldName) {
        this.fieldPath.splice(0, 0, fieldName);
        // NOTE: Modifying message directly as jest doesn't use .toString()
        this.message = this.originalMessage + ": " + this.fieldPath.join(".");
    }
}
exports.BorshError = BorshError;
/// Binary encoder.
class BinaryWriter {
    constructor(){
        this.buf = Buffer.alloc(INITIAL_LENGTH);
        this.length = 0;
    }
    maybeResize() {
        if (this.buf.length < 16 + this.length) this.buf = Buffer.concat([
            this.buf,
            Buffer.alloc(INITIAL_LENGTH)
        ]);
    }
    writeU8(value) {
        this.maybeResize();
        this.buf.writeUInt8(value, this.length);
        this.length += 1;
    }
    writeU16(value) {
        this.maybeResize();
        this.buf.writeUInt16LE(value, this.length);
        this.length += 2;
    }
    writeU32(value) {
        this.maybeResize();
        this.buf.writeUInt32LE(value, this.length);
        this.length += 4;
    }
    writeU64(value) {
        this.maybeResize();
        this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray("le", 8)));
    }
    writeU128(value) {
        this.maybeResize();
        this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray("le", 16)));
    }
    writeU256(value) {
        this.maybeResize();
        this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray("le", 32)));
    }
    writeU512(value) {
        this.maybeResize();
        this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray("le", 64)));
    }
    writeBuffer(buffer) {
        // Buffer.from is needed as this.buf.subarray can return plain Uint8Array in browser
        this.buf = Buffer.concat([
            Buffer.from(this.buf.subarray(0, this.length)),
            buffer,
            Buffer.alloc(INITIAL_LENGTH)
        ]);
        this.length += buffer.length;
    }
    writeString(str) {
        this.maybeResize();
        const b = Buffer.from(str, "utf8");
        this.writeU32(b.length);
        this.writeBuffer(b);
    }
    writeFixedArray(array) {
        this.writeBuffer(Buffer.from(array));
    }
    writeArray(array, fn) {
        this.maybeResize();
        this.writeU32(array.length);
        for (const elem of array){
            this.maybeResize();
            fn(elem);
        }
    }
    toArray() {
        return this.buf.subarray(0, this.length);
    }
}
exports.BinaryWriter = BinaryWriter;
function handlingRangeError(target, propertyKey, propertyDescriptor) {
    const originalMethod = propertyDescriptor.value;
    propertyDescriptor.value = function(...args) {
        try {
            return originalMethod.apply(this, args);
        } catch (e) {
            if (e instanceof RangeError) {
                const code = e.code;
                if ([
                    "ERR_BUFFER_OUT_OF_BOUNDS",
                    "ERR_OUT_OF_RANGE"
                ].indexOf(code) >= 0) throw new BorshError("Reached the end of buffer when deserializing");
            }
            throw e;
        }
    };
}
class BinaryReader {
    constructor(buf){
        this.buf = buf;
        this.offset = 0;
    }
    readU8() {
        const value = this.buf.readUInt8(this.offset);
        this.offset += 1;
        return value;
    }
    readU16() {
        const value = this.buf.readUInt16LE(this.offset);
        this.offset += 2;
        return value;
    }
    readU32() {
        const value = this.buf.readUInt32LE(this.offset);
        this.offset += 4;
        return value;
    }
    readU64() {
        const buf = this.readBuffer(8);
        return new bn_js_1.default(buf, "le");
    }
    readU128() {
        const buf = this.readBuffer(16);
        return new bn_js_1.default(buf, "le");
    }
    readU256() {
        const buf = this.readBuffer(32);
        return new bn_js_1.default(buf, "le");
    }
    readU512() {
        const buf = this.readBuffer(64);
        return new bn_js_1.default(buf, "le");
    }
    readBuffer(len) {
        if (this.offset + len > this.buf.length) throw new BorshError(`Expected buffer length ${len} isn't within bounds`);
        const result = this.buf.slice(this.offset, this.offset + len);
        this.offset += len;
        return result;
    }
    readString() {
        const len = this.readU32();
        const buf = this.readBuffer(len);
        try {
            // NOTE: Using TextDecoder to fail on invalid UTF-8
            return textDecoder.decode(buf);
        } catch (e) {
            throw new BorshError(`Error decoding UTF-8 string: ${e}`);
        }
    }
    readFixedArray(len) {
        return new Uint8Array(this.readBuffer(len));
    }
    readArray(fn) {
        const len = this.readU32();
        const result = Array();
        for(let i = 0; i < len; ++i)result.push(fn());
        return result;
    }
}
__decorate([
    handlingRangeError
], BinaryReader.prototype, "readU8", null);
__decorate([
    handlingRangeError
], BinaryReader.prototype, "readU16", null);
__decorate([
    handlingRangeError
], BinaryReader.prototype, "readU32", null);
__decorate([
    handlingRangeError
], BinaryReader.prototype, "readU64", null);
__decorate([
    handlingRangeError
], BinaryReader.prototype, "readU128", null);
__decorate([
    handlingRangeError
], BinaryReader.prototype, "readU256", null);
__decorate([
    handlingRangeError
], BinaryReader.prototype, "readU512", null);
__decorate([
    handlingRangeError
], BinaryReader.prototype, "readString", null);
__decorate([
    handlingRangeError
], BinaryReader.prototype, "readFixedArray", null);
__decorate([
    handlingRangeError
], BinaryReader.prototype, "readArray", null);
exports.BinaryReader = BinaryReader;
function capitalizeFirstLetter(string) {
    return string.charAt(0).toUpperCase() + string.slice(1);
}
function serializeField(schema, fieldName, value, fieldType, writer) {
    try {
        // TODO: Handle missing values properly (make sure they never result in just skipped write)
        if (typeof fieldType === "string") writer[`write${capitalizeFirstLetter(fieldType)}`](value);
        else if (fieldType instanceof Array) {
            if (typeof fieldType[0] === "number") {
                if (value.length !== fieldType[0]) throw new BorshError(`Expecting byte array of length ${fieldType[0]}, but got ${value.length} bytes`);
                writer.writeFixedArray(value);
            } else if (fieldType.length === 2 && typeof fieldType[1] === "number") {
                if (value.length !== fieldType[1]) throw new BorshError(`Expecting byte array of length ${fieldType[1]}, but got ${value.length} bytes`);
                for(let i = 0; i < fieldType[1]; i++)serializeField(schema, null, value[i], fieldType[0], writer);
            } else writer.writeArray(value, (item)=>{
                serializeField(schema, fieldName, item, fieldType[0], writer);
            });
        } else if (fieldType.kind !== undefined) switch(fieldType.kind){
            case "option":
                if (value === null || value === undefined) writer.writeU8(0);
                else {
                    writer.writeU8(1);
                    serializeField(schema, fieldName, value, fieldType.type, writer);
                }
                break;
            case "map":
                writer.writeU32(value.size);
                value.forEach((val, key)=>{
                    serializeField(schema, fieldName, key, fieldType.key, writer);
                    serializeField(schema, fieldName, val, fieldType.value, writer);
                });
                break;
            default:
                throw new BorshError(`FieldType ${fieldType} unrecognized`);
        }
        else serializeStruct(schema, value, writer);
    } catch (error) {
        if (error instanceof BorshError) error.addToFieldPath(fieldName);
        throw error;
    }
}
function serializeStruct(schema, obj, writer) {
    if (typeof obj.borshSerialize === "function") {
        obj.borshSerialize(writer);
        return;
    }
    const structSchema = schema.get(obj.constructor);
    if (!structSchema) throw new BorshError(`Class ${obj.constructor.name} is missing in schema`);
    if (structSchema.kind === "struct") structSchema.fields.map(([fieldName, fieldType])=>{
        serializeField(schema, fieldName, obj[fieldName], fieldType, writer);
    });
    else if (structSchema.kind === "enum") {
        const name = obj[structSchema.field];
        for(let idx = 0; idx < structSchema.values.length; ++idx){
            const [fieldName, fieldType] = structSchema.values[idx];
            if (fieldName === name) {
                writer.writeU8(idx);
                serializeField(schema, fieldName, obj[fieldName], fieldType, writer);
                break;
            }
        }
    } else throw new BorshError(`Unexpected schema kind: ${structSchema.kind} for ${obj.constructor.name}`);
}
/// Serialize given object using schema of the form:
/// { class_name -> [ [field_name, field_type], .. ], .. }
function serialize(schema, obj, Writer = BinaryWriter) {
    const writer = new Writer();
    serializeStruct(schema, obj, writer);
    return writer.toArray();
}
exports.serialize = serialize;
function deserializeField(schema, fieldName, fieldType, reader) {
    try {
        if (typeof fieldType === "string") return reader[`read${capitalizeFirstLetter(fieldType)}`]();
        if (fieldType instanceof Array) {
            if (typeof fieldType[0] === "number") return reader.readFixedArray(fieldType[0]);
            else if (typeof fieldType[1] === "number") {
                const arr = [];
                for(let i = 0; i < fieldType[1]; i++)arr.push(deserializeField(schema, null, fieldType[0], reader));
                return arr;
            } else return reader.readArray(()=>deserializeField(schema, fieldName, fieldType[0], reader));
        }
        if (fieldType.kind === "option") {
            const option = reader.readU8();
            if (option) return deserializeField(schema, fieldName, fieldType.type, reader);
            return undefined;
        }
        if (fieldType.kind === "map") {
            let map = new Map();
            const length = reader.readU32();
            for(let i = 0; i < length; i++){
                const key = deserializeField(schema, fieldName, fieldType.key, reader);
                const val = deserializeField(schema, fieldName, fieldType.value, reader);
                map.set(key, val);
            }
            return map;
        }
        return deserializeStruct(schema, fieldType, reader);
    } catch (error) {
        if (error instanceof BorshError) error.addToFieldPath(fieldName);
        throw error;
    }
}
function deserializeStruct(schema, classType, reader) {
    if (typeof classType.borshDeserialize === "function") return classType.borshDeserialize(reader);
    const structSchema = schema.get(classType);
    if (!structSchema) throw new BorshError(`Class ${classType.name} is missing in schema`);
    if (structSchema.kind === "struct") {
        const result = {};
        for (const [fieldName, fieldType] of schema.get(classType).fields)result[fieldName] = deserializeField(schema, fieldName, fieldType, reader);
        return new classType(result);
    }
    if (structSchema.kind === "enum") {
        const idx = reader.readU8();
        if (idx >= structSchema.values.length) throw new BorshError(`Enum index: ${idx} is out of range`);
        const [fieldName, fieldType] = structSchema.values[idx];
        const fieldValue = deserializeField(schema, fieldName, fieldType, reader);
        return new classType({
            [fieldName]: fieldValue
        });
    }
    throw new BorshError(`Unexpected schema kind: ${structSchema.kind} for ${classType.constructor.name}`);
}
/// Deserializes object from bytes using schema.
function deserialize(schema, classType, buffer, Reader = BinaryReader) {
    const reader = new Reader(buffer);
    const result = deserializeStruct(schema, classType, reader);
    if (reader.offset < buffer.length) throw new BorshError(`Unexpected ${buffer.length - reader.offset} bytes after deserialized data`);
    return result;
}
exports.deserialize = deserialize;
/// Deserializes object from bytes using schema, without checking the length read
function deserializeUnchecked(schema, classType, buffer, Reader = BinaryReader) {
    const reader = new Reader(buffer);
    return deserializeStruct(schema, classType, reader);
}
exports.deserializeUnchecked = deserializeUnchecked;

},{"699c164eb7aea5db":"fCgem","17e7c0a10366aaf7":"VopIn","d1e02929d3f43eae":"4ji3p","b378096fead01c9a":"feCA6"}],"feCA6":[function(require,module,exports) {
"use strict";
// This is free and unencumbered software released into the public domain.
// See LICENSE.md for more information.
//
// Utilities
//
/**
 * @param {number} a The number to test.
 * @param {number} min The minimum value in the range, inclusive.
 * @param {number} max The maximum value in the range, inclusive.
 * @return {boolean} True if a >= min and a <= max.
 */ function inRange(a, min, max) {
    return min <= a && a <= max;
}
/**
 * @param {*} o
 * @return {Object}
 */ function ToDictionary(o) {
    if (o === undefined) return {};
    if (o === Object(o)) return o;
    throw TypeError("Could not convert argument to dictionary");
}
/**
 * @param {string} string Input string of UTF-16 code units.
 * @return {!Array.<number>} Code points.
 */ function stringToCodePoints(string) {
    // https://heycam.github.io/webidl/#dfn-obtain-unicode
    // 1. Let S be the DOMString value.
    var s = String(string);
    // 2. Let n be the length of S.
    var n = s.length;
    // 3. Initialize i to 0.
    var i = 0;
    // 4. Initialize U to be an empty sequence of Unicode characters.
    var u = [];
    // 5. While i < n:
    while(i < n){
        // 1. Let c be the code unit in S at index i.
        var c = s.charCodeAt(i);
        // 2. Depending on the value of c:
        // c < 0xD800 or c > 0xDFFF
        if (c < 0xD800 || c > 0xDFFF) // Append to U the Unicode character with code point c.
        u.push(c);
        else if (0xDC00 <= c && c <= 0xDFFF) // Append to U a U+FFFD REPLACEMENT CHARACTER.
        u.push(0xFFFD);
        else if (0xD800 <= c && c <= 0xDBFF) {
            // 1. If i = n1, then append to U a U+FFFD REPLACEMENT
            // CHARACTER.
            if (i === n - 1) u.push(0xFFFD);
            else {
                // 1. Let d be the code unit in S at index i+1.
                var d = string.charCodeAt(i + 1);
                // 2. If 0xDC00  d  0xDFFF, then:
                if (0xDC00 <= d && d <= 0xDFFF) {
                    // 1. Let a be c & 0x3FF.
                    var a = c & 0x3FF;
                    // 2. Let b be d & 0x3FF.
                    var b = d & 0x3FF;
                    // 3. Append to U the Unicode character with code point
                    // 2^16+2^10*a+b.
                    u.push(0x10000 + (a << 10) + b);
                    // 4. Set i to i+1.
                    i += 1;
                } else u.push(0xFFFD);
            }
        }
        // 3. Set i to i+1.
        i += 1;
    }
    // 6. Return U.
    return u;
}
/**
 * @param {!Array.<number>} code_points Array of code points.
 * @return {string} string String of UTF-16 code units.
 */ function codePointsToString(code_points) {
    var s = "";
    for(var i = 0; i < code_points.length; ++i){
        var cp = code_points[i];
        if (cp <= 0xFFFF) s += String.fromCharCode(cp);
        else {
            cp -= 0x10000;
            s += String.fromCharCode((cp >> 10) + 0xD800, (cp & 0x3FF) + 0xDC00);
        }
    }
    return s;
}
//
// Implementation of Encoding specification
// https://encoding.spec.whatwg.org/
//
//
// 3. Terminology
//
/**
 * End-of-stream is a special token that signifies no more tokens
 * are in the stream.
 * @const
 */ var end_of_stream = -1;
/**
 * A stream represents an ordered sequence of tokens.
 *
 * @constructor
 * @param {!(Array.<number>|Uint8Array)} tokens Array of tokens that provide the
 * stream.
 */ function Stream(tokens) {
    /** @type {!Array.<number>} */ this.tokens = [].slice.call(tokens);
}
Stream.prototype = {
    /**
   * @return {boolean} True if end-of-stream has been hit.
   */ endOfStream: function() {
        return !this.tokens.length;
    },
    /**
   * When a token is read from a stream, the first token in the
   * stream must be returned and subsequently removed, and
   * end-of-stream must be returned otherwise.
   *
   * @return {number} Get the next token from the stream, or
   * end_of_stream.
   */ read: function() {
        if (!this.tokens.length) return end_of_stream;
        return this.tokens.shift();
    },
    /**
   * When one or more tokens are prepended to a stream, those tokens
   * must be inserted, in given order, before the first token in the
   * stream.
   *
   * @param {(number|!Array.<number>)} token The token(s) to prepend to the stream.
   */ prepend: function(token) {
        if (Array.isArray(token)) {
            var tokens = /**@type {!Array.<number>}*/ token;
            while(tokens.length)this.tokens.unshift(tokens.pop());
        } else this.tokens.unshift(token);
    },
    /**
   * When one or more tokens are pushed to a stream, those tokens
   * must be inserted, in given order, after the last token in the
   * stream.
   *
   * @param {(number|!Array.<number>)} token The tokens(s) to prepend to the stream.
   */ push: function(token) {
        if (Array.isArray(token)) {
            var tokens = /**@type {!Array.<number>}*/ token;
            while(tokens.length)this.tokens.push(tokens.shift());
        } else this.tokens.push(token);
    }
};
//
// 4. Encodings
//
// 4.1 Encoders and decoders
/** @const */ var finished = -1;
/**
 * @param {boolean} fatal If true, decoding errors raise an exception.
 * @param {number=} opt_code_point Override the standard fallback code point.
 * @return {number} The code point to insert on a decoding error.
 */ function decoderError(fatal, opt_code_point) {
    if (fatal) throw TypeError("Decoder error");
    return opt_code_point || 0xFFFD;
}
//
// 7. API
//
/** @const */ var DEFAULT_ENCODING = "utf-8";
// 7.1 Interface TextDecoder
/**
 * @constructor
 * @param {string=} encoding The label of the encoding;
 *     defaults to 'utf-8'.
 * @param {Object=} options
 */ function TextDecoder(encoding, options) {
    if (!(this instanceof TextDecoder)) return new TextDecoder(encoding, options);
    encoding = encoding !== undefined ? String(encoding).toLowerCase() : DEFAULT_ENCODING;
    if (encoding !== DEFAULT_ENCODING) throw new Error("Encoding not supported. Only utf-8 is supported");
    options = ToDictionary(options);
    /** @private @type {boolean} */ this._streaming = false;
    /** @private @type {boolean} */ this._BOMseen = false;
    /** @private @type {?Decoder} */ this._decoder = null;
    /** @private @type {boolean} */ this._fatal = Boolean(options["fatal"]);
    /** @private @type {boolean} */ this._ignoreBOM = Boolean(options["ignoreBOM"]);
    Object.defineProperty(this, "encoding", {
        value: "utf-8"
    });
    Object.defineProperty(this, "fatal", {
        value: this._fatal
    });
    Object.defineProperty(this, "ignoreBOM", {
        value: this._ignoreBOM
    });
}
TextDecoder.prototype = {
    /**
   * @param {ArrayBufferView=} input The buffer of bytes to decode.
   * @param {Object=} options
   * @return {string} The decoded string.
   */ decode: function decode(input, options) {
        var bytes;
        if (typeof input === "object" && input instanceof ArrayBuffer) bytes = new Uint8Array(input);
        else if (typeof input === "object" && "buffer" in input && input.buffer instanceof ArrayBuffer) bytes = new Uint8Array(input.buffer, input.byteOffset, input.byteLength);
        else bytes = new Uint8Array(0);
        options = ToDictionary(options);
        if (!this._streaming) {
            this._decoder = new UTF8Decoder({
                fatal: this._fatal
            });
            this._BOMseen = false;
        }
        this._streaming = Boolean(options["stream"]);
        var input_stream = new Stream(bytes);
        var code_points = [];
        /** @type {?(number|!Array.<number>)} */ var result;
        while(!input_stream.endOfStream()){
            result = this._decoder.handler(input_stream, input_stream.read());
            if (result === finished) break;
            if (result === null) continue;
            if (Array.isArray(result)) code_points.push.apply(code_points, /**@type {!Array.<number>}*/ result);
            else code_points.push(result);
        }
        if (!this._streaming) {
            do {
                result = this._decoder.handler(input_stream, input_stream.read());
                if (result === finished) break;
                if (result === null) continue;
                if (Array.isArray(result)) code_points.push.apply(code_points, /**@type {!Array.<number>}*/ result);
                else code_points.push(result);
            }while (!input_stream.endOfStream());
            this._decoder = null;
        }
        if (code_points.length) // If encoding is one of utf-8, utf-16be, and utf-16le, and
        // ignore BOM flag and BOM seen flag are unset, run these
        // subsubsteps:
        {
            if ([
                "utf-8"
            ].indexOf(this.encoding) !== -1 && !this._ignoreBOM && !this._BOMseen) {
                // If token is U+FEFF, set BOM seen flag.
                if (code_points[0] === 0xFEFF) {
                    this._BOMseen = true;
                    code_points.shift();
                } else // Otherwise, if token is not end-of-stream, set BOM seen
                // flag and append token to output.
                this._BOMseen = true;
            }
        }
        return codePointsToString(code_points);
    }
};
// 7.2 Interface TextEncoder
/**
 * @constructor
 * @param {string=} encoding The label of the encoding;
 *     defaults to 'utf-8'.
 * @param {Object=} options
 */ function TextEncoder(encoding, options) {
    if (!(this instanceof TextEncoder)) return new TextEncoder(encoding, options);
    encoding = encoding !== undefined ? String(encoding).toLowerCase() : DEFAULT_ENCODING;
    if (encoding !== DEFAULT_ENCODING) throw new Error("Encoding not supported. Only utf-8 is supported");
    options = ToDictionary(options);
    /** @private @type {boolean} */ this._streaming = false;
    /** @private @type {?Encoder} */ this._encoder = null;
    /** @private @type {{fatal: boolean}} */ this._options = {
        fatal: Boolean(options["fatal"])
    };
    Object.defineProperty(this, "encoding", {
        value: "utf-8"
    });
}
TextEncoder.prototype = {
    /**
   * @param {string=} opt_string The string to encode.
   * @param {Object=} options
   * @return {Uint8Array} Encoded bytes, as a Uint8Array.
   */ encode: function encode(opt_string, options) {
        opt_string = opt_string ? String(opt_string) : "";
        options = ToDictionary(options);
        // NOTE: This option is nonstandard. None of the encodings
        // permitted for encoding (i.e. UTF-8, UTF-16) are stateful,
        // so streaming is not necessary.
        if (!this._streaming) this._encoder = new UTF8Encoder(this._options);
        this._streaming = Boolean(options["stream"]);
        var bytes = [];
        var input_stream = new Stream(stringToCodePoints(opt_string));
        /** @type {?(number|!Array.<number>)} */ var result;
        while(!input_stream.endOfStream()){
            result = this._encoder.handler(input_stream, input_stream.read());
            if (result === finished) break;
            if (Array.isArray(result)) bytes.push.apply(bytes, /**@type {!Array.<number>}*/ result);
            else bytes.push(result);
        }
        if (!this._streaming) {
            while(true){
                result = this._encoder.handler(input_stream, input_stream.read());
                if (result === finished) break;
                if (Array.isArray(result)) bytes.push.apply(bytes, /**@type {!Array.<number>}*/ result);
                else bytes.push(result);
            }
            this._encoder = null;
        }
        return new Uint8Array(bytes);
    }
};
//
// 8. The encoding
//
// 8.1 utf-8
/**
 * @constructor
 * @implements {Decoder}
 * @param {{fatal: boolean}} options
 */ function UTF8Decoder(options) {
    var fatal = options.fatal;
    // utf-8's decoder's has an associated utf-8 code point, utf-8
    // bytes seen, and utf-8 bytes needed (all initially 0), a utf-8
    // lower boundary (initially 0x80), and a utf-8 upper boundary
    // (initially 0xBF).
    var /** @type {number} */ utf8_code_point = 0, /** @type {number} */ utf8_bytes_seen = 0, /** @type {number} */ utf8_bytes_needed = 0, /** @type {number} */ utf8_lower_boundary = 0x80, /** @type {number} */ utf8_upper_boundary = 0xBF;
    /**
   * @param {Stream} stream The stream of bytes being decoded.
   * @param {number} bite The next byte read from the stream.
   * @return {?(number|!Array.<number>)} The next code point(s)
   *     decoded, or null if not enough data exists in the input
   *     stream to decode a complete code point.
   */ this.handler = function(stream, bite) {
        // 1. If byte is end-of-stream and utf-8 bytes needed is not 0,
        // set utf-8 bytes needed to 0 and return error.
        if (bite === end_of_stream && utf8_bytes_needed !== 0) {
            utf8_bytes_needed = 0;
            return decoderError(fatal);
        }
        // 2. If byte is end-of-stream, return finished.
        if (bite === end_of_stream) return finished;
        // 3. If utf-8 bytes needed is 0, based on byte:
        if (utf8_bytes_needed === 0) {
            // 0x00 to 0x7F
            if (inRange(bite, 0x00, 0x7F)) // Return a code point whose value is byte.
            return bite;
            // 0xC2 to 0xDF
            if (inRange(bite, 0xC2, 0xDF)) {
                // Set utf-8 bytes needed to 1 and utf-8 code point to byte
                //  0xC0.
                utf8_bytes_needed = 1;
                utf8_code_point = bite - 0xC0;
            } else if (inRange(bite, 0xE0, 0xEF)) {
                // 1. If byte is 0xE0, set utf-8 lower boundary to 0xA0.
                if (bite === 0xE0) utf8_lower_boundary = 0xA0;
                // 2. If byte is 0xED, set utf-8 upper boundary to 0x9F.
                if (bite === 0xED) utf8_upper_boundary = 0x9F;
                // 3. Set utf-8 bytes needed to 2 and utf-8 code point to
                // byte  0xE0.
                utf8_bytes_needed = 2;
                utf8_code_point = bite - 0xE0;
            } else if (inRange(bite, 0xF0, 0xF4)) {
                // 1. If byte is 0xF0, set utf-8 lower boundary to 0x90.
                if (bite === 0xF0) utf8_lower_boundary = 0x90;
                // 2. If byte is 0xF4, set utf-8 upper boundary to 0x8F.
                if (bite === 0xF4) utf8_upper_boundary = 0x8F;
                // 3. Set utf-8 bytes needed to 3 and utf-8 code point to
                // byte  0xF0.
                utf8_bytes_needed = 3;
                utf8_code_point = bite - 0xF0;
            } else // Return error.
            return decoderError(fatal);
            // Then (byte is in the range 0xC2 to 0xF4) set utf-8 code
            // point to utf-8 code point << (6  utf-8 bytes needed) and
            // return continue.
            utf8_code_point = utf8_code_point << 6 * utf8_bytes_needed;
            return null;
        }
        // 4. If byte is not in the range utf-8 lower boundary to utf-8
        // upper boundary, run these substeps:
        if (!inRange(bite, utf8_lower_boundary, utf8_upper_boundary)) {
            // 1. Set utf-8 code point, utf-8 bytes needed, and utf-8
            // bytes seen to 0, set utf-8 lower boundary to 0x80, and set
            // utf-8 upper boundary to 0xBF.
            utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;
            utf8_lower_boundary = 0x80;
            utf8_upper_boundary = 0xBF;
            // 2. Prepend byte to stream.
            stream.prepend(bite);
            // 3. Return error.
            return decoderError(fatal);
        }
        // 5. Set utf-8 lower boundary to 0x80 and utf-8 upper boundary
        // to 0xBF.
        utf8_lower_boundary = 0x80;
        utf8_upper_boundary = 0xBF;
        // 6. Increase utf-8 bytes seen by one and set utf-8 code point
        // to utf-8 code point + (byte  0x80) << (6  (utf-8 bytes
        // needed  utf-8 bytes seen)).
        utf8_bytes_seen += 1;
        utf8_code_point += bite - 0x80 << 6 * (utf8_bytes_needed - utf8_bytes_seen);
        // 7. If utf-8 bytes seen is not equal to utf-8 bytes needed,
        // continue.
        if (utf8_bytes_seen !== utf8_bytes_needed) return null;
        // 8. Let code point be utf-8 code point.
        var code_point = utf8_code_point;
        // 9. Set utf-8 code point, utf-8 bytes needed, and utf-8 bytes
        // seen to 0.
        utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;
        // 10. Return a code point whose value is code point.
        return code_point;
    };
}
/**
 * @constructor
 * @implements {Encoder}
 * @param {{fatal: boolean}} options
 */ function UTF8Encoder(options) {
    var fatal = options.fatal;
    /**
   * @param {Stream} stream Input stream.
   * @param {number} code_point Next code point read from the stream.
   * @return {(number|!Array.<number>)} Byte(s) to emit.
   */ this.handler = function(stream, code_point) {
        // 1. If code point is end-of-stream, return finished.
        if (code_point === end_of_stream) return finished;
        // 2. If code point is in the range U+0000 to U+007F, return a
        // byte whose value is code point.
        if (inRange(code_point, 0x0000, 0x007f)) return code_point;
        // 3. Set count and offset based on the range code point is in:
        var count, offset;
        // U+0080 to U+07FF:    1 and 0xC0
        if (inRange(code_point, 0x0080, 0x07FF)) {
            count = 1;
            offset = 0xC0;
        } else if (inRange(code_point, 0x0800, 0xFFFF)) {
            count = 2;
            offset = 0xE0;
        } else if (inRange(code_point, 0x10000, 0x10FFFF)) {
            count = 3;
            offset = 0xF0;
        }
        // 4.Let bytes be a byte sequence whose first byte is (code
        // point >> (6  count)) + offset.
        var bytes = [
            (code_point >> 6 * count) + offset
        ];
        // 5. Run these substeps while count is greater than 0:
        while(count > 0){
            // 1. Set temp to code point >> (6  (count  1)).
            var temp = code_point >> 6 * (count - 1);
            // 2. Append to bytes 0x80 | (temp & 0x3F).
            bytes.push(0x80 | temp & 0x3F);
            // 3. Decrease count by one.
            count -= 1;
        }
        // 6. Return bytes bytes, in order.
        return bytes;
    };
}
exports.TextEncoder = TextEncoder;
exports.TextDecoder = TextDecoder;

},{}],"jD9A8":[function(require,module,exports) {
/* The MIT License (MIT)
 *
 * Copyright 2015-2018 Peter A. Bigot
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */ /**
 * Support for translating between Uint8Array instances and JavaScript
 * native types.
 *
 * {@link module:Layout~Layout|Layout} is the basis of a class
 * hierarchy that associates property names with sequences of encoded
 * bytes.
 *
 * Layouts are supported for these scalar (numeric) types:
 * * {@link module:Layout~UInt|Unsigned integers in little-endian
 *   format} with {@link module:Layout.u8|8-bit}, {@link
 *   module:Layout.u16|16-bit}, {@link module:Layout.u24|24-bit},
 *   {@link module:Layout.u32|32-bit}, {@link
 *   module:Layout.u40|40-bit}, and {@link module:Layout.u48|48-bit}
 *   representation ranges;
 * * {@link module:Layout~UIntBE|Unsigned integers in big-endian
 *   format} with {@link module:Layout.u16be|16-bit}, {@link
 *   module:Layout.u24be|24-bit}, {@link module:Layout.u32be|32-bit},
 *   {@link module:Layout.u40be|40-bit}, and {@link
 *   module:Layout.u48be|48-bit} representation ranges;
 * * {@link module:Layout~Int|Signed integers in little-endian
 *   format} with {@link module:Layout.s8|8-bit}, {@link
 *   module:Layout.s16|16-bit}, {@link module:Layout.s24|24-bit},
 *   {@link module:Layout.s32|32-bit}, {@link
 *   module:Layout.s40|40-bit}, and {@link module:Layout.s48|48-bit}
 *   representation ranges;
 * * {@link module:Layout~IntBE|Signed integers in big-endian format}
 *   with {@link module:Layout.s16be|16-bit}, {@link
 *   module:Layout.s24be|24-bit}, {@link module:Layout.s32be|32-bit},
 *   {@link module:Layout.s40be|40-bit}, and {@link
 *   module:Layout.s48be|48-bit} representation ranges;
 * * 64-bit integral values that decode to an exact (if magnitude is
 *   less than 2^53) or nearby integral Number in {@link
 *   module:Layout.nu64|unsigned little-endian}, {@link
 *   module:Layout.nu64be|unsigned big-endian}, {@link
 *   module:Layout.ns64|signed little-endian}, and {@link
 *   module:Layout.ns64be|unsigned big-endian} encodings;
 * * 32-bit floating point values with {@link
 *   module:Layout.f32|little-endian} and {@link
 *   module:Layout.f32be|big-endian} representations;
 * * 64-bit floating point values with {@link
 *   module:Layout.f64|little-endian} and {@link
 *   module:Layout.f64be|big-endian} representations;
 * * {@link module:Layout.const|Constants} that take no space in the
 *   encoded expression.
 *
 * and for these aggregate types:
 * * {@link module:Layout.seq|Sequence}s of instances of a {@link
 *   module:Layout~Layout|Layout}, with JavaScript representation as
 *   an Array and constant or data-dependent {@link
 *   module:Layout~Sequence#count|length};
 * * {@link module:Layout.struct|Structure}s that aggregate a
 *   heterogeneous sequence of {@link module:Layout~Layout|Layout}
 *   instances, with JavaScript representation as an Object;
 * * {@link module:Layout.union|Union}s that support multiple {@link
 *   module:Layout~VariantLayout|variant layouts} over a fixed
 *   (padded) or variable (not padded) span of bytes, using an
 *   unsigned integer at the start of the data or a separate {@link
 *   module:Layout.unionLayoutDiscriminator|layout element} to
 *   determine which layout to use when interpreting the buffer
 *   contents;
 * * {@link module:Layout.bits|BitStructure}s that contain a sequence
 *   of individual {@link
 *   module:Layout~BitStructure#addField|BitField}s packed into an 8,
 *   16, 24, or 32-bit unsigned integer starting at the least- or
 *   most-significant bit;
 * * {@link module:Layout.cstr|C strings} of varying length;
 * * {@link module:Layout.blob|Blobs} of fixed- or variable-{@link
 *   module:Layout~Blob#length|length} raw data.
 *
 * All {@link module:Layout~Layout|Layout} instances are immutable
 * after construction, to prevent internal state from becoming
 * inconsistent.
 *
 * @local Layout
 * @local ExternalLayout
 * @local GreedyCount
 * @local OffsetLayout
 * @local UInt
 * @local UIntBE
 * @local Int
 * @local IntBE
 * @local NearUInt64
 * @local NearUInt64BE
 * @local NearInt64
 * @local NearInt64BE
 * @local Float
 * @local FloatBE
 * @local Double
 * @local DoubleBE
 * @local Sequence
 * @local Structure
 * @local UnionDiscriminator
 * @local UnionLayoutDiscriminator
 * @local Union
 * @local VariantLayout
 * @local BitStructure
 * @local BitField
 * @local Boolean
 * @local Blob
 * @local CString
 * @local Constant
 * @local bindConstructorLayout
 * @module Layout
 * @license MIT
 * @author Peter A. Bigot
 * @see {@link https://github.com/pabigot/buffer-layout|buffer-layout on GitHub}
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.s16 = exports.s8 = exports.nu64be = exports.u48be = exports.u40be = exports.u32be = exports.u24be = exports.u16be = exports.nu64 = exports.u48 = exports.u40 = exports.u32 = exports.u24 = exports.u16 = exports.u8 = exports.offset = exports.greedy = exports.Constant = exports.UTF8 = exports.CString = exports.Blob = exports.Boolean = exports.BitField = exports.BitStructure = exports.VariantLayout = exports.Union = exports.UnionLayoutDiscriminator = exports.UnionDiscriminator = exports.Structure = exports.Sequence = exports.DoubleBE = exports.Double = exports.FloatBE = exports.Float = exports.NearInt64BE = exports.NearInt64 = exports.NearUInt64BE = exports.NearUInt64 = exports.IntBE = exports.Int = exports.UIntBE = exports.UInt = exports.OffsetLayout = exports.GreedyCount = exports.ExternalLayout = exports.bindConstructorLayout = exports.nameWithProperty = exports.Layout = exports.uint8ArrayToBuffer = exports.checkUint8Array = void 0;
exports.constant = exports.utf8 = exports.cstr = exports.blob = exports.unionLayoutDiscriminator = exports.union = exports.seq = exports.bits = exports.struct = exports.f64be = exports.f64 = exports.f32be = exports.f32 = exports.ns64be = exports.s48be = exports.s40be = exports.s32be = exports.s24be = exports.s16be = exports.ns64 = exports.s48 = exports.s40 = exports.s32 = exports.s24 = void 0;
const buffer_1 = require("fd98bf021fd3e926");
/* Check if a value is a Uint8Array.
 *
 * @ignore */ function checkUint8Array(b) {
    if (!(b instanceof Uint8Array)) throw new TypeError("b must be a Uint8Array");
}
exports.checkUint8Array = checkUint8Array;
/* Create a Buffer instance from a Uint8Array.
 *
 * @ignore */ function uint8ArrayToBuffer(b) {
    checkUint8Array(b);
    return buffer_1.Buffer.from(b.buffer, b.byteOffset, b.length);
}
exports.uint8ArrayToBuffer = uint8ArrayToBuffer;
/**
 * Base class for layout objects.
 *
 * **NOTE** This is an abstract base class; you can create instances
 * if it amuses you, but they won't support the {@link
 * Layout#encode|encode} or {@link Layout#decode|decode} functions.
 *
 * @param {Number} span - Initializer for {@link Layout#span|span}.  The
 * parameter must be an integer; a negative value signifies that the
 * span is {@link Layout#getSpan|value-specific}.
 *
 * @param {string} [property] - Initializer for {@link
 * Layout#property|property}.
 *
 * @abstract
 */ class Layout {
    constructor(span, property){
        if (!Number.isInteger(span)) throw new TypeError("span must be an integer");
        /** The span of the layout in bytes.
         *
         * Positive values are generally expected.
         *
         * Zero will only appear in {@link Constant}s and in {@link
         * Sequence}s where the {@link Sequence#count|count} is zero.
         *
         * A negative value indicates that the span is value-specific, and
         * must be obtained using {@link Layout#getSpan|getSpan}. */ this.span = span;
        /** The property name used when this layout is represented in an
         * Object.
         *
         * Used only for layouts that {@link Layout#decode|decode} to Object
         * instances.  If left undefined the span of the unnamed layout will
         * be treated as padding: it will not be mutated by {@link
         * Layout#encode|encode} nor represented as a property in the
         * decoded Object. */ this.property = property;
    }
    /** Function to create an Object into which decoded properties will
     * be written.
     *
     * Used only for layouts that {@link Layout#decode|decode} to Object
     * instances, which means:
     * * {@link Structure}
     * * {@link Union}
     * * {@link VariantLayout}
     * * {@link BitStructure}
     *
     * If left undefined the JavaScript representation of these layouts
     * will be Object instances.
     *
     * See {@link bindConstructorLayout}.
     */ makeDestinationObject() {
        return {};
    }
    /**
     * Calculate the span of a specific instance of a layout.
     *
     * @param {Uint8Array} b - the buffer that contains an encoded instance.
     *
     * @param {Number} [offset] - the offset at which the encoded instance
     * starts.  If absent a zero offset is inferred.
     *
     * @return {Number} - the number of bytes covered by the layout
     * instance.  If this method is not overridden in a subclass the
     * definition-time constant {@link Layout#span|span} will be
     * returned.
     *
     * @throws {RangeError} - if the length of the value cannot be
     * determined.
     */ getSpan(b, offset) {
        if (0 > this.span) throw new RangeError("indeterminate span");
        return this.span;
    }
    /**
     * Replicate the layout using a new property.
     *
     * This function must be used to get a structurally-equivalent layout
     * with a different name since all {@link Layout} instances are
     * immutable.
     *
     * **NOTE** This is a shallow copy.  All fields except {@link
     * Layout#property|property} are strictly equal to the origin layout.
     *
     * @param {String} property - the value for {@link
     * Layout#property|property} in the replica.
     *
     * @returns {Layout} - the copy with {@link Layout#property|property}
     * set to `property`.
     */ replicate(property) {
        const rv = Object.create(this.constructor.prototype);
        Object.assign(rv, this);
        rv.property = property;
        return rv;
    }
    /**
     * Create an object from layout properties and an array of values.
     *
     * **NOTE** This function returns `undefined` if invoked on a layout
     * that does not return its value as an Object.  Objects are
     * returned for things that are a {@link Structure}, which includes
     * {@link VariantLayout|variant layouts} if they are structures, and
     * excludes {@link Union}s.  If you want this feature for a union
     * you must use {@link Union.getVariant|getVariant} to select the
     * desired layout.
     *
     * @param {Array} values - an array of values that correspond to the
     * default order for properties.  As with {@link Layout#decode|decode}
     * layout elements that have no property name are skipped when
     * iterating over the array values.  Only the top-level properties are
     * assigned; arguments are not assigned to properties of contained
     * layouts.  Any unused values are ignored.
     *
     * @return {(Object|undefined)}
     */ fromArray(values) {
        return undefined;
    }
}
exports.Layout = Layout;
/* Provide text that carries a name (such as for a function that will
 * be throwing an error) annotated with the property of a given layout
 * (such as one for which the value was unacceptable).
 *
 * @ignore */ function nameWithProperty(name, lo) {
    if (lo.property) return name + "[" + lo.property + "]";
    return name;
}
exports.nameWithProperty = nameWithProperty;
/**
 * Augment a class so that instances can be encoded/decoded using a
 * given layout.
 *
 * Calling this function couples `Class` with `layout` in several ways:
 *
 * * `Class.layout_` becomes a static member property equal to `layout`;
 * * `layout.boundConstructor_` becomes a static member property equal
 *    to `Class`;
 * * The {@link Layout#makeDestinationObject|makeDestinationObject()}
 *   property of `layout` is set to a function that returns a `new
 *   Class()`;
 * * `Class.decode(b, offset)` becomes a static member function that
 *   delegates to {@link Layout#decode|layout.decode}.  The
 *   synthesized function may be captured and extended.
 * * `Class.prototype.encode(b, offset)` provides an instance member
 *   function that delegates to {@link Layout#encode|layout.encode}
 *   with `src` set to `this`.  The synthesized function may be
 *   captured and extended, but when the extension is invoked `this`
 *   must be explicitly bound to the instance.
 *
 * @param {class} Class - a JavaScript class with a nullary
 * constructor.
 *
 * @param {Layout} layout - the {@link Layout} instance used to encode
 * instances of `Class`.
 */ // `Class` must be a constructor Function, but the assignment of a `layout_` property to it makes it difficult to type
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
function bindConstructorLayout(Class, layout) {
    if ("function" !== typeof Class) throw new TypeError("Class must be constructor");
    if (Object.prototype.hasOwnProperty.call(Class, "layout_")) throw new Error("Class is already bound to a layout");
    if (!(layout && layout instanceof Layout)) throw new TypeError("layout must be a Layout");
    if (Object.prototype.hasOwnProperty.call(layout, "boundConstructor_")) throw new Error("layout is already bound to a constructor");
    Class.layout_ = layout;
    layout.boundConstructor_ = Class;
    layout.makeDestinationObject = ()=>new Class();
    Object.defineProperty(Class.prototype, "encode", {
        value (b, offset) {
            return layout.encode(this, b, offset);
        },
        writable: true
    });
    Object.defineProperty(Class, "decode", {
        value (b, offset) {
            return layout.decode(b, offset);
        },
        writable: true
    });
}
exports.bindConstructorLayout = bindConstructorLayout;
/**
 * An object that behaves like a layout but does not consume space
 * within its containing layout.
 *
 * This is primarily used to obtain metadata about a member, such as a
 * {@link OffsetLayout} that can provide data about a {@link
 * Layout#getSpan|value-specific span}.
 *
 * **NOTE** This is an abstract base class; you can create instances
 * if it amuses you, but they won't support {@link
 * ExternalLayout#isCount|isCount} or other {@link Layout} functions.
 *
 * @param {Number} span - initializer for {@link Layout#span|span}.
 * The parameter can range from 1 through 6.
 *
 * @param {string} [property] - initializer for {@link
 * Layout#property|property}.
 *
 * @abstract
 * @augments {Layout}
 */ class ExternalLayout extends Layout {
    /**
     * Return `true` iff the external layout decodes to an unsigned
     * integer layout.
     *
     * In that case it can be used as the source of {@link
     * Sequence#count|Sequence counts}, {@link Blob#length|Blob lengths},
     * or as {@link UnionLayoutDiscriminator#layout|external union
     * discriminators}.
     *
     * @abstract
     */ isCount() {
        throw new Error("ExternalLayout is abstract");
    }
}
exports.ExternalLayout = ExternalLayout;
/**
 * An {@link ExternalLayout} that determines its {@link
 * Layout#decode|value} based on offset into and length of the buffer
 * on which it is invoked.
 *
 * *Factory*: {@link module:Layout.greedy|greedy}
 *
 * @param {Number} [elementSpan] - initializer for {@link
 * GreedyCount#elementSpan|elementSpan}.
 *
 * @param {string} [property] - initializer for {@link
 * Layout#property|property}.
 *
 * @augments {ExternalLayout}
 */ class GreedyCount extends ExternalLayout {
    constructor(elementSpan = 1, property){
        if (!Number.isInteger(elementSpan) || 0 >= elementSpan) throw new TypeError("elementSpan must be a (positive) integer");
        super(-1, property);
        /** The layout for individual elements of the sequence.  The value
         * must be a positive integer.  If not provided, the value will be
         * 1. */ this.elementSpan = elementSpan;
    }
    /** @override */ isCount() {
        return true;
    }
    /** @override */ decode(b, offset = 0) {
        checkUint8Array(b);
        const rem = b.length - offset;
        return Math.floor(rem / this.elementSpan);
    }
    /** @override */ encode(src, b, offset) {
        return 0;
    }
}
exports.GreedyCount = GreedyCount;
/**
 * An {@link ExternalLayout} that supports accessing a {@link Layout}
 * at a fixed offset from the start of another Layout.  The offset may
 * be before, within, or after the base layout.
 *
 * *Factory*: {@link module:Layout.offset|offset}
 *
 * @param {Layout} layout - initializer for {@link
 * OffsetLayout#layout|layout}, modulo `property`.
 *
 * @param {Number} [offset] - Initializes {@link
 * OffsetLayout#offset|offset}.  Defaults to zero.
 *
 * @param {string} [property] - Optional new property name for a
 * {@link Layout#replicate| replica} of `layout` to be used as {@link
 * OffsetLayout#layout|layout}.  If not provided the `layout` is used
 * unchanged.
 *
 * @augments {Layout}
 */ class OffsetLayout extends ExternalLayout {
    constructor(layout, offset = 0, property){
        if (!(layout instanceof Layout)) throw new TypeError("layout must be a Layout");
        if (!Number.isInteger(offset)) throw new TypeError("offset must be integer or undefined");
        super(layout.span, property || layout.property);
        /** The subordinated layout. */ this.layout = layout;
        /** The location of {@link OffsetLayout#layout} relative to the
         * start of another layout.
         *
         * The value may be positive or negative, but an error will thrown
         * if at the point of use it goes outside the span of the Uint8Array
         * being accessed.  */ this.offset = offset;
    }
    /** @override */ isCount() {
        return this.layout instanceof UInt || this.layout instanceof UIntBE;
    }
    /** @override */ decode(b, offset = 0) {
        return this.layout.decode(b, offset + this.offset);
    }
    /** @override */ encode(src, b, offset = 0) {
        return this.layout.encode(src, b, offset + this.offset);
    }
}
exports.OffsetLayout = OffsetLayout;
/**
 * Represent an unsigned integer in little-endian format.
 *
 * *Factory*: {@link module:Layout.u8|u8}, {@link
 *  module:Layout.u16|u16}, {@link module:Layout.u24|u24}, {@link
 *  module:Layout.u32|u32}, {@link module:Layout.u40|u40}, {@link
 *  module:Layout.u48|u48}
 *
 * @param {Number} span - initializer for {@link Layout#span|span}.
 * The parameter can range from 1 through 6.
 *
 * @param {string} [property] - initializer for {@link
 * Layout#property|property}.
 *
 * @augments {Layout}
 */ class UInt extends Layout {
    constructor(span, property){
        super(span, property);
        if (6 < this.span) throw new RangeError("span must not exceed 6 bytes");
    }
    /** @override */ decode(b, offset = 0) {
        return uint8ArrayToBuffer(b).readUIntLE(offset, this.span);
    }
    /** @override */ encode(src, b, offset = 0) {
        uint8ArrayToBuffer(b).writeUIntLE(src, offset, this.span);
        return this.span;
    }
}
exports.UInt = UInt;
/**
 * Represent an unsigned integer in big-endian format.
 *
 * *Factory*: {@link module:Layout.u8be|u8be}, {@link
 * module:Layout.u16be|u16be}, {@link module:Layout.u24be|u24be},
 * {@link module:Layout.u32be|u32be}, {@link
 * module:Layout.u40be|u40be}, {@link module:Layout.u48be|u48be}
 *
 * @param {Number} span - initializer for {@link Layout#span|span}.
 * The parameter can range from 1 through 6.
 *
 * @param {string} [property] - initializer for {@link
 * Layout#property|property}.
 *
 * @augments {Layout}
 */ class UIntBE extends Layout {
    constructor(span, property){
        super(span, property);
        if (6 < this.span) throw new RangeError("span must not exceed 6 bytes");
    }
    /** @override */ decode(b, offset = 0) {
        return uint8ArrayToBuffer(b).readUIntBE(offset, this.span);
    }
    /** @override */ encode(src, b, offset = 0) {
        uint8ArrayToBuffer(b).writeUIntBE(src, offset, this.span);
        return this.span;
    }
}
exports.UIntBE = UIntBE;
/**
 * Represent a signed integer in little-endian format.
 *
 * *Factory*: {@link module:Layout.s8|s8}, {@link
 *  module:Layout.s16|s16}, {@link module:Layout.s24|s24}, {@link
 *  module:Layout.s32|s32}, {@link module:Layout.s40|s40}, {@link
 *  module:Layout.s48|s48}
 *
 * @param {Number} span - initializer for {@link Layout#span|span}.
 * The parameter can range from 1 through 6.
 *
 * @param {string} [property] - initializer for {@link
 * Layout#property|property}.
 *
 * @augments {Layout}
 */ class Int extends Layout {
    constructor(span, property){
        super(span, property);
        if (6 < this.span) throw new RangeError("span must not exceed 6 bytes");
    }
    /** @override */ decode(b, offset = 0) {
        return uint8ArrayToBuffer(b).readIntLE(offset, this.span);
    }
    /** @override */ encode(src, b, offset = 0) {
        uint8ArrayToBuffer(b).writeIntLE(src, offset, this.span);
        return this.span;
    }
}
exports.Int = Int;
/**
 * Represent a signed integer in big-endian format.
 *
 * *Factory*: {@link module:Layout.s8be|s8be}, {@link
 * module:Layout.s16be|s16be}, {@link module:Layout.s24be|s24be},
 * {@link module:Layout.s32be|s32be}, {@link
 * module:Layout.s40be|s40be}, {@link module:Layout.s48be|s48be}
 *
 * @param {Number} span - initializer for {@link Layout#span|span}.
 * The parameter can range from 1 through 6.
 *
 * @param {string} [property] - initializer for {@link
 * Layout#property|property}.
 *
 * @augments {Layout}
 */ class IntBE extends Layout {
    constructor(span, property){
        super(span, property);
        if (6 < this.span) throw new RangeError("span must not exceed 6 bytes");
    }
    /** @override */ decode(b, offset = 0) {
        return uint8ArrayToBuffer(b).readIntBE(offset, this.span);
    }
    /** @override */ encode(src, b, offset = 0) {
        uint8ArrayToBuffer(b).writeIntBE(src, offset, this.span);
        return this.span;
    }
}
exports.IntBE = IntBE;
const V2E32 = Math.pow(2, 32);
/* True modulus high and low 32-bit words, where low word is always
 * non-negative. */ function divmodInt64(src) {
    const hi32 = Math.floor(src / V2E32);
    const lo32 = src - hi32 * V2E32;
    return {
        hi32,
        lo32
    };
}
/* Reconstruct Number from quotient and non-negative remainder */ function roundedInt64(hi32, lo32) {
    return hi32 * V2E32 + lo32;
}
/**
 * Represent an unsigned 64-bit integer in little-endian format when
 * encoded and as a near integral JavaScript Number when decoded.
 *
 * *Factory*: {@link module:Layout.nu64|nu64}
 *
 * **NOTE** Values with magnitude greater than 2^52 may not decode to
 * the exact value of the encoded representation.
 *
 * @augments {Layout}
 */ class NearUInt64 extends Layout {
    constructor(property){
        super(8, property);
    }
    /** @override */ decode(b, offset = 0) {
        const buffer = uint8ArrayToBuffer(b);
        const lo32 = buffer.readUInt32LE(offset);
        const hi32 = buffer.readUInt32LE(offset + 4);
        return roundedInt64(hi32, lo32);
    }
    /** @override */ encode(src, b, offset = 0) {
        const split = divmodInt64(src);
        const buffer = uint8ArrayToBuffer(b);
        buffer.writeUInt32LE(split.lo32, offset);
        buffer.writeUInt32LE(split.hi32, offset + 4);
        return 8;
    }
}
exports.NearUInt64 = NearUInt64;
/**
 * Represent an unsigned 64-bit integer in big-endian format when
 * encoded and as a near integral JavaScript Number when decoded.
 *
 * *Factory*: {@link module:Layout.nu64be|nu64be}
 *
 * **NOTE** Values with magnitude greater than 2^52 may not decode to
 * the exact value of the encoded representation.
 *
 * @augments {Layout}
 */ class NearUInt64BE extends Layout {
    constructor(property){
        super(8, property);
    }
    /** @override */ decode(b, offset = 0) {
        const buffer = uint8ArrayToBuffer(b);
        const hi32 = buffer.readUInt32BE(offset);
        const lo32 = buffer.readUInt32BE(offset + 4);
        return roundedInt64(hi32, lo32);
    }
    /** @override */ encode(src, b, offset = 0) {
        const split = divmodInt64(src);
        const buffer = uint8ArrayToBuffer(b);
        buffer.writeUInt32BE(split.hi32, offset);
        buffer.writeUInt32BE(split.lo32, offset + 4);
        return 8;
    }
}
exports.NearUInt64BE = NearUInt64BE;
/**
 * Represent a signed 64-bit integer in little-endian format when
 * encoded and as a near integral JavaScript Number when decoded.
 *
 * *Factory*: {@link module:Layout.ns64|ns64}
 *
 * **NOTE** Values with magnitude greater than 2^52 may not decode to
 * the exact value of the encoded representation.
 *
 * @augments {Layout}
 */ class NearInt64 extends Layout {
    constructor(property){
        super(8, property);
    }
    /** @override */ decode(b, offset = 0) {
        const buffer = uint8ArrayToBuffer(b);
        const lo32 = buffer.readUInt32LE(offset);
        const hi32 = buffer.readInt32LE(offset + 4);
        return roundedInt64(hi32, lo32);
    }
    /** @override */ encode(src, b, offset = 0) {
        const split = divmodInt64(src);
        const buffer = uint8ArrayToBuffer(b);
        buffer.writeUInt32LE(split.lo32, offset);
        buffer.writeInt32LE(split.hi32, offset + 4);
        return 8;
    }
}
exports.NearInt64 = NearInt64;
/**
 * Represent a signed 64-bit integer in big-endian format when
 * encoded and as a near integral JavaScript Number when decoded.
 *
 * *Factory*: {@link module:Layout.ns64be|ns64be}
 *
 * **NOTE** Values with magnitude greater than 2^52 may not decode to
 * the exact value of the encoded representation.
 *
 * @augments {Layout}
 */ class NearInt64BE extends Layout {
    constructor(property){
        super(8, property);
    }
    /** @override */ decode(b, offset = 0) {
        const buffer = uint8ArrayToBuffer(b);
        const hi32 = buffer.readInt32BE(offset);
        const lo32 = buffer.readUInt32BE(offset + 4);
        return roundedInt64(hi32, lo32);
    }
    /** @override */ encode(src, b, offset = 0) {
        const split = divmodInt64(src);
        const buffer = uint8ArrayToBuffer(b);
        buffer.writeInt32BE(split.hi32, offset);
        buffer.writeUInt32BE(split.lo32, offset + 4);
        return 8;
    }
}
exports.NearInt64BE = NearInt64BE;
/**
 * Represent a 32-bit floating point number in little-endian format.
 *
 * *Factory*: {@link module:Layout.f32|f32}
 *
 * @param {string} [property] - initializer for {@link
 * Layout#property|property}.
 *
 * @augments {Layout}
 */ class Float extends Layout {
    constructor(property){
        super(4, property);
    }
    /** @override */ decode(b, offset = 0) {
        return uint8ArrayToBuffer(b).readFloatLE(offset);
    }
    /** @override */ encode(src, b, offset = 0) {
        uint8ArrayToBuffer(b).writeFloatLE(src, offset);
        return 4;
    }
}
exports.Float = Float;
/**
 * Represent a 32-bit floating point number in big-endian format.
 *
 * *Factory*: {@link module:Layout.f32be|f32be}
 *
 * @param {string} [property] - initializer for {@link
 * Layout#property|property}.
 *
 * @augments {Layout}
 */ class FloatBE extends Layout {
    constructor(property){
        super(4, property);
    }
    /** @override */ decode(b, offset = 0) {
        return uint8ArrayToBuffer(b).readFloatBE(offset);
    }
    /** @override */ encode(src, b, offset = 0) {
        uint8ArrayToBuffer(b).writeFloatBE(src, offset);
        return 4;
    }
}
exports.FloatBE = FloatBE;
/**
 * Represent a 64-bit floating point number in little-endian format.
 *
 * *Factory*: {@link module:Layout.f64|f64}
 *
 * @param {string} [property] - initializer for {@link
 * Layout#property|property}.
 *
 * @augments {Layout}
 */ class Double extends Layout {
    constructor(property){
        super(8, property);
    }
    /** @override */ decode(b, offset = 0) {
        return uint8ArrayToBuffer(b).readDoubleLE(offset);
    }
    /** @override */ encode(src, b, offset = 0) {
        uint8ArrayToBuffer(b).writeDoubleLE(src, offset);
        return 8;
    }
}
exports.Double = Double;
/**
 * Represent a 64-bit floating point number in big-endian format.
 *
 * *Factory*: {@link module:Layout.f64be|f64be}
 *
 * @param {string} [property] - initializer for {@link
 * Layout#property|property}.
 *
 * @augments {Layout}
 */ class DoubleBE extends Layout {
    constructor(property){
        super(8, property);
    }
    /** @override */ decode(b, offset = 0) {
        return uint8ArrayToBuffer(b).readDoubleBE(offset);
    }
    /** @override */ encode(src, b, offset = 0) {
        uint8ArrayToBuffer(b).writeDoubleBE(src, offset);
        return 8;
    }
}
exports.DoubleBE = DoubleBE;
/**
 * Represent a contiguous sequence of a specific layout as an Array.
 *
 * *Factory*: {@link module:Layout.seq|seq}
 *
 * @param {Layout} elementLayout - initializer for {@link
 * Sequence#elementLayout|elementLayout}.
 *
 * @param {(Number|ExternalLayout)} count - initializer for {@link
 * Sequence#count|count}.  The parameter must be either a positive
 * integer or an instance of {@link ExternalLayout}.
 *
 * @param {string} [property] - initializer for {@link
 * Layout#property|property}.
 *
 * @augments {Layout}
 */ class Sequence extends Layout {
    constructor(elementLayout, count, property){
        if (!(elementLayout instanceof Layout)) throw new TypeError("elementLayout must be a Layout");
        if (!(count instanceof ExternalLayout && count.isCount() || Number.isInteger(count) && 0 <= count)) throw new TypeError("count must be non-negative integer or an unsigned integer ExternalLayout");
        let span = -1;
        if (!(count instanceof ExternalLayout) && 0 < elementLayout.span) span = count * elementLayout.span;
        super(span, property);
        /** The layout for individual elements of the sequence. */ this.elementLayout = elementLayout;
        /** The number of elements in the sequence.
         *
         * This will be either a non-negative integer or an instance of
         * {@link ExternalLayout} for which {@link
         * ExternalLayout#isCount|isCount()} is `true`. */ this.count = count;
    }
    /** @override */ getSpan(b, offset = 0) {
        if (0 <= this.span) return this.span;
        let span = 0;
        let count = this.count;
        if (count instanceof ExternalLayout) count = count.decode(b, offset);
        if (0 < this.elementLayout.span) span = count * this.elementLayout.span;
        else {
            let idx = 0;
            while(idx < count){
                span += this.elementLayout.getSpan(b, offset + span);
                ++idx;
            }
        }
        return span;
    }
    /** @override */ decode(b, offset = 0) {
        const rv = [];
        let i = 0;
        let count = this.count;
        if (count instanceof ExternalLayout) count = count.decode(b, offset);
        while(i < count){
            rv.push(this.elementLayout.decode(b, offset));
            offset += this.elementLayout.getSpan(b, offset);
            i += 1;
        }
        return rv;
    }
    /** Implement {@link Layout#encode|encode} for {@link Sequence}.
     *
     * **NOTE** If `src` is shorter than {@link Sequence#count|count} then
     * the unused space in the buffer is left unchanged.  If `src` is
     * longer than {@link Sequence#count|count} the unneeded elements are
     * ignored.
     *
     * **NOTE** If {@link Layout#count|count} is an instance of {@link
     * ExternalLayout} then the length of `src` will be encoded as the
     * count after `src` is encoded. */ encode(src, b, offset = 0) {
        const elo = this.elementLayout;
        const span = src.reduce((span, v)=>{
            return span + elo.encode(v, b, offset + span);
        }, 0);
        if (this.count instanceof ExternalLayout) this.count.encode(src.length, b, offset);
        return span;
    }
}
exports.Sequence = Sequence;
/**
 * Represent a contiguous sequence of arbitrary layout elements as an
 * Object.
 *
 * *Factory*: {@link module:Layout.struct|struct}
 *
 * **NOTE** The {@link Layout#span|span} of the structure is variable
 * if any layout in {@link Structure#fields|fields} has a variable
 * span.  When {@link Layout#encode|encoding} we must have a value for
 * all variable-length fields, or we wouldn't be able to figure out
 * how much space to use for storage.  We can only identify the value
 * for a field when it has a {@link Layout#property|property}.  As
 * such, although a structure may contain both unnamed fields and
 * variable-length fields, it cannot contain an unnamed
 * variable-length field.
 *
 * @param {Layout[]} fields - initializer for {@link
 * Structure#fields|fields}.  An error is raised if this contains a
 * variable-length field for which a {@link Layout#property|property}
 * is not defined.
 *
 * @param {string} [property] - initializer for {@link
 * Layout#property|property}.
 *
 * @param {Boolean} [decodePrefixes] - initializer for {@link
 * Structure#decodePrefixes|property}.
 *
 * @throws {Error} - if `fields` contains an unnamed variable-length
 * layout.
 *
 * @augments {Layout}
 */ class Structure extends Layout {
    constructor(fields, property, decodePrefixes){
        if (!(Array.isArray(fields) && fields.reduce((acc, v)=>acc && v instanceof Layout, true))) throw new TypeError("fields must be array of Layout instances");
        if ("boolean" === typeof property && undefined === decodePrefixes) {
            decodePrefixes = property;
            property = undefined;
        }
        /* Verify absence of unnamed variable-length fields. */ for (const fd of fields){
            if (0 > fd.span && undefined === fd.property) throw new Error("fields cannot contain unnamed variable-length layout");
        }
        let span = -1;
        try {
            span = fields.reduce((span, fd)=>span + fd.getSpan(), 0);
        } catch (e) {
        // ignore error
        }
        super(span, property);
        /** The sequence of {@link Layout} values that comprise the
         * structure.
         *
         * The individual elements need not be the same type, and may be
         * either scalar or aggregate layouts.  If a member layout leaves
         * its {@link Layout#property|property} undefined the
         * corresponding region of the buffer associated with the element
         * will not be mutated.
         *
         * @type {Layout[]} */ this.fields = fields;
        /** Control behavior of {@link Layout#decode|decode()} given short
         * buffers.
         *
         * In some situations a structure many be extended with additional
         * fields over time, with older installations providing only a
         * prefix of the full structure.  If this property is `true`
         * decoding will accept those buffers and leave subsequent fields
         * undefined, as long as the buffer ends at a field boundary.
         * Defaults to `false`. */ this.decodePrefixes = !!decodePrefixes;
    }
    /** @override */ getSpan(b, offset = 0) {
        if (0 <= this.span) return this.span;
        let span = 0;
        try {
            span = this.fields.reduce((span, fd)=>{
                const fsp = fd.getSpan(b, offset);
                offset += fsp;
                return span + fsp;
            }, 0);
        } catch (e) {
            throw new RangeError("indeterminate span");
        }
        return span;
    }
    /** @override */ decode(b, offset = 0) {
        checkUint8Array(b);
        const dest = this.makeDestinationObject();
        for (const fd of this.fields){
            if (undefined !== fd.property) dest[fd.property] = fd.decode(b, offset);
            offset += fd.getSpan(b, offset);
            if (this.decodePrefixes && b.length === offset) break;
        }
        return dest;
    }
    /** Implement {@link Layout#encode|encode} for {@link Structure}.
     *
     * If `src` is missing a property for a member with a defined {@link
     * Layout#property|property} the corresponding region of the buffer is
     * left unmodified. */ encode(src, b, offset = 0) {
        const firstOffset = offset;
        let lastOffset = 0;
        let lastWrote = 0;
        for (const fd of this.fields){
            let span = fd.span;
            lastWrote = 0 < span ? span : 0;
            if (undefined !== fd.property) {
                const fv = src[fd.property];
                if (undefined !== fv) {
                    lastWrote = fd.encode(fv, b, offset);
                    if (0 > span) /* Read the as-encoded span, which is not necessarily the
                         * same as what we wrote. */ span = fd.getSpan(b, offset);
                }
            }
            lastOffset = offset;
            offset += span;
        }
        /* Use (lastOffset + lastWrote) instead of offset because the last
         * item may have had a dynamic length and we don't want to include
         * the padding between it and the end of the space reserved for
         * it. */ return lastOffset + lastWrote - firstOffset;
    }
    /** @override */ fromArray(values) {
        const dest = this.makeDestinationObject();
        for (const fd of this.fields)if (undefined !== fd.property && 0 < values.length) dest[fd.property] = values.shift();
        return dest;
    }
    /**
     * Get access to the layout of a given property.
     *
     * @param {String} property - the structure member of interest.
     *
     * @return {Layout} - the layout associated with `property`, or
     * undefined if there is no such property.
     */ layoutFor(property) {
        if ("string" !== typeof property) throw new TypeError("property must be string");
        for (const fd of this.fields){
            if (fd.property === property) return fd;
        }
        return undefined;
    }
    /**
     * Get the offset of a structure member.
     *
     * @param {String} property - the structure member of interest.
     *
     * @return {Number} - the offset in bytes to the start of `property`
     * within the structure, or undefined if `property` is not a field
     * within the structure.  If the property is a member but follows a
     * variable-length structure member a negative number will be
     * returned.
     */ offsetOf(property) {
        if ("string" !== typeof property) throw new TypeError("property must be string");
        let offset = 0;
        for (const fd of this.fields){
            if (fd.property === property) return offset;
            if (0 > fd.span) offset = -1;
            else if (0 <= offset) offset += fd.span;
        }
        return undefined;
    }
}
exports.Structure = Structure;
/**
 * An object that can provide a {@link
 * Union#discriminator|discriminator} API for {@link Union}.
 *
 * **NOTE** This is an abstract base class; you can create instances
 * if it amuses you, but they won't support the {@link
 * UnionDiscriminator#encode|encode} or {@link
 * UnionDiscriminator#decode|decode} functions.
 *
 * @param {string} [property] - Default for {@link
 * UnionDiscriminator#property|property}.
 *
 * @abstract
 */ class UnionDiscriminator {
    constructor(property){
        /** The {@link Layout#property|property} to be used when the
         * discriminator is referenced in isolation (generally when {@link
         * Union#decode|Union decode} cannot delegate to a specific
         * variant). */ this.property = property;
    }
    /** Analog to {@link Layout#decode|Layout decode} for union discriminators.
     *
     * The implementation of this method need not reference the buffer if
     * variant information is available through other means. */ decode(b, offset) {
        throw new Error("UnionDiscriminator is abstract");
    }
    /** Analog to {@link Layout#decode|Layout encode} for union discriminators.
     *
     * The implementation of this method need not store the value if
     * variant information is maintained through other means. */ encode(src, b, offset) {
        throw new Error("UnionDiscriminator is abstract");
    }
}
exports.UnionDiscriminator = UnionDiscriminator;
/**
 * An object that can provide a {@link
 * UnionDiscriminator|discriminator API} for {@link Union} using an
 * unsigned integral {@link Layout} instance located either inside or
 * outside the union.
 *
 * @param {ExternalLayout} layout - initializes {@link
 * UnionLayoutDiscriminator#layout|layout}.  Must satisfy {@link
 * ExternalLayout#isCount|isCount()}.
 *
 * @param {string} [property] - Default for {@link
 * UnionDiscriminator#property|property}, superseding the property
 * from `layout`, but defaulting to `variant` if neither `property`
 * nor layout provide a property name.
 *
 * @augments {UnionDiscriminator}
 */ class UnionLayoutDiscriminator extends UnionDiscriminator {
    constructor(layout, property){
        if (!(layout instanceof ExternalLayout && layout.isCount())) throw new TypeError("layout must be an unsigned integer ExternalLayout");
        super(property || layout.property || "variant");
        /** The {@link ExternalLayout} used to access the discriminator
         * value. */ this.layout = layout;
    }
    /** Delegate decoding to {@link UnionLayoutDiscriminator#layout|layout}. */ decode(b, offset) {
        return this.layout.decode(b, offset);
    }
    /** Delegate encoding to {@link UnionLayoutDiscriminator#layout|layout}. */ encode(src, b, offset) {
        return this.layout.encode(src, b, offset);
    }
}
exports.UnionLayoutDiscriminator = UnionLayoutDiscriminator;
/**
 * Represent any number of span-compatible layouts.
 *
 * *Factory*: {@link module:Layout.union|union}
 *
 * If the union has a {@link Union#defaultLayout|default layout} that
 * layout must have a non-negative {@link Layout#span|span}.  The span
 * of a fixed-span union includes its {@link
 * Union#discriminator|discriminator} if the variant is a {@link
 * Union#usesPrefixDiscriminator|prefix of the union}, plus the span
 * of its {@link Union#defaultLayout|default layout}.
 *
 * If the union does not have a default layout then the encoded span
 * of the union depends on the encoded span of its variant (which may
 * be fixed or variable).
 *
 * {@link VariantLayout#layout|Variant layout}s are added through
 * {@link Union#addVariant|addVariant}.  If the union has a default
 * layout, the span of the {@link VariantLayout#layout|layout
 * contained by the variant} must not exceed the span of the {@link
 * Union#defaultLayout|default layout} (minus the span of a {@link
 * Union#usesPrefixDiscriminator|prefix disriminator}, if used).  The
 * span of the variant will equal the span of the union itself.
 *
 * The variant for a buffer can only be identified from the {@link
 * Union#discriminator|discriminator} {@link
 * UnionDiscriminator#property|property} (in the case of the {@link
 * Union#defaultLayout|default layout}), or by using {@link
 * Union#getVariant|getVariant} and examining the resulting {@link
 * VariantLayout} instance.
 *
 * A variant compatible with a JavaScript object can be identified
 * using {@link Union#getSourceVariant|getSourceVariant}.
 *
 * @param {(UnionDiscriminator|ExternalLayout|Layout)} discr - How to
 * identify the layout used to interpret the union contents.  The
 * parameter must be an instance of {@link UnionDiscriminator}, an
 * {@link ExternalLayout} that satisfies {@link
 * ExternalLayout#isCount|isCount()}, or {@link UInt} (or {@link
 * UIntBE}).  When a non-external layout element is passed the layout
 * appears at the start of the union.  In all cases the (synthesized)
 * {@link UnionDiscriminator} instance is recorded as {@link
 * Union#discriminator|discriminator}.
 *
 * @param {(Layout|null)} defaultLayout - initializer for {@link
 * Union#defaultLayout|defaultLayout}.  If absent defaults to `null`.
 * If `null` there is no default layout: the union has data-dependent
 * length and attempts to decode or encode unrecognized variants will
 * throw an exception.  A {@link Layout} instance must have a
 * non-negative {@link Layout#span|span}, and if it lacks a {@link
 * Layout#property|property} the {@link
 * Union#defaultLayout|defaultLayout} will be a {@link
 * Layout#replicate|replica} with property `content`.
 *
 * @param {string} [property] - initializer for {@link
 * Layout#property|property}.
 *
 * @augments {Layout}
 */ class Union extends Layout {
    constructor(discr, defaultLayout, property){
        let discriminator;
        if (discr instanceof UInt || discr instanceof UIntBE) discriminator = new UnionLayoutDiscriminator(new OffsetLayout(discr));
        else if (discr instanceof ExternalLayout && discr.isCount()) discriminator = new UnionLayoutDiscriminator(discr);
        else if (!(discr instanceof UnionDiscriminator)) throw new TypeError("discr must be a UnionDiscriminator or an unsigned integer layout");
        else discriminator = discr;
        if (undefined === defaultLayout) defaultLayout = null;
        if (!(null === defaultLayout || defaultLayout instanceof Layout)) throw new TypeError("defaultLayout must be null or a Layout");
        if (null !== defaultLayout) {
            if (0 > defaultLayout.span) throw new Error("defaultLayout must have constant span");
            if (undefined === defaultLayout.property) defaultLayout = defaultLayout.replicate("content");
        }
        /* The union span can be estimated only if there's a default
         * layout.  The union spans its default layout, plus any prefix
         * variant layout.  By construction both layouts, if present, have
         * non-negative span. */ let span = -1;
        if (defaultLayout) {
            span = defaultLayout.span;
            if (0 <= span && (discr instanceof UInt || discr instanceof UIntBE)) span += discriminator.layout.span;
        }
        super(span, property);
        /** The interface for the discriminator value in isolation.
         *
         * This a {@link UnionDiscriminator} either passed to the
         * constructor or synthesized from the `discr` constructor
         * argument.  {@link
         * Union#usesPrefixDiscriminator|usesPrefixDiscriminator} will be
         * `true` iff the `discr` parameter was a non-offset {@link
         * Layout} instance. */ this.discriminator = discriminator;
        /** `true` if the {@link Union#discriminator|discriminator} is the
         * first field in the union.
         *
         * If `false` the discriminator is obtained from somewhere
         * else. */ this.usesPrefixDiscriminator = discr instanceof UInt || discr instanceof UIntBE;
        /** The layout for non-discriminator content when the value of the
         * discriminator is not recognized.
         *
         * This is the value passed to the constructor.  It is
         * structurally equivalent to the second component of {@link
         * Union#layout|layout} but may have a different property
         * name. */ this.defaultLayout = defaultLayout;
        /** A registry of allowed variants.
         *
         * The keys are unsigned integers which should be compatible with
         * {@link Union.discriminator|discriminator}.  The property value
         * is the corresponding {@link VariantLayout} instances assigned
         * to this union by {@link Union#addVariant|addVariant}.
         *
         * **NOTE** The registry remains mutable so that variants can be
         * {@link Union#addVariant|added} at any time.  Users should not
         * manipulate the content of this property. */ this.registry = {};
        /* Private variable used when invoking getSourceVariant */ let boundGetSourceVariant = this.defaultGetSourceVariant.bind(this);
        /** Function to infer the variant selected by a source object.
         *
         * Defaults to {@link
         * Union#defaultGetSourceVariant|defaultGetSourceVariant} but may
         * be overridden using {@link
         * Union#configGetSourceVariant|configGetSourceVariant}.
         *
         * @param {Object} src - as with {@link
         * Union#defaultGetSourceVariant|defaultGetSourceVariant}.
         *
         * @returns {(undefined|VariantLayout)} The default variant
         * (`undefined`) or first registered variant that uses a property
         * available in `src`. */ this.getSourceVariant = function(src) {
            return boundGetSourceVariant(src);
        };
        /** Function to override the implementation of {@link
         * Union#getSourceVariant|getSourceVariant}.
         *
         * Use this if the desired variant cannot be identified using the
         * algorithm of {@link
         * Union#defaultGetSourceVariant|defaultGetSourceVariant}.
         *
         * **NOTE** The provided function will be invoked bound to this
         * Union instance, providing local access to {@link
         * Union#registry|registry}.
         *
         * @param {Function} gsv - a function that follows the API of
         * {@link Union#defaultGetSourceVariant|defaultGetSourceVariant}. */ this.configGetSourceVariant = function(gsv) {
            boundGetSourceVariant = gsv.bind(this);
        };
    }
    /** @override */ getSpan(b, offset = 0) {
        if (0 <= this.span) return this.span;
        /* Default layouts always have non-negative span, so we don't have
         * one and we have to recognize the variant which will in turn
         * determine the span. */ const vlo = this.getVariant(b, offset);
        if (!vlo) throw new Error("unable to determine span for unrecognized variant");
        return vlo.getSpan(b, offset);
    }
    /**
     * Method to infer a registered Union variant compatible with `src`.
     *
     * The first satisfied rule in the following sequence defines the
     * return value:
     * * If `src` has properties matching the Union discriminator and
     *   the default layout, `undefined` is returned regardless of the
     *   value of the discriminator property (this ensures the default
     *   layout will be used);
     * * If `src` has a property matching the Union discriminator, the
     *   value of the discriminator identifies a registered variant, and
     *   either (a) the variant has no layout, or (b) `src` has the
     *   variant's property, then the variant is returned (because the
     *   source satisfies the constraints of the variant it identifies);
     * * If `src` does not have a property matching the Union
     *   discriminator, but does have a property matching a registered
     *   variant, then the variant is returned (because the source
     *   matches a variant without an explicit conflict);
     * * An error is thrown (because we either can't identify a variant,
     *   or we were explicitly told the variant but can't satisfy it).
     *
     * @param {Object} src - an object presumed to be compatible with
     * the content of the Union.
     *
     * @return {(undefined|VariantLayout)} - as described above.
     *
     * @throws {Error} - if `src` cannot be associated with a default or
     * registered variant.
     */ defaultGetSourceVariant(src) {
        if (Object.prototype.hasOwnProperty.call(src, this.discriminator.property)) {
            if (this.defaultLayout && this.defaultLayout.property && Object.prototype.hasOwnProperty.call(src, this.defaultLayout.property)) return undefined;
            const vlo = this.registry[src[this.discriminator.property]];
            if (vlo && (!vlo.layout || vlo.property && Object.prototype.hasOwnProperty.call(src, vlo.property))) return vlo;
        } else for(const tag in this.registry){
            const vlo = this.registry[tag];
            if (vlo.property && Object.prototype.hasOwnProperty.call(src, vlo.property)) return vlo;
        }
        throw new Error("unable to infer src variant");
    }
    /** Implement {@link Layout#decode|decode} for {@link Union}.
     *
     * If the variant is {@link Union#addVariant|registered} the return
     * value is an instance of that variant, with no explicit
     * discriminator.  Otherwise the {@link Union#defaultLayout|default
     * layout} is used to decode the content. */ decode(b, offset = 0) {
        let dest;
        const dlo = this.discriminator;
        const discr = dlo.decode(b, offset);
        const clo = this.registry[discr];
        if (undefined === clo) {
            const defaultLayout = this.defaultLayout;
            let contentOffset = 0;
            if (this.usesPrefixDiscriminator) contentOffset = dlo.layout.span;
            dest = this.makeDestinationObject();
            dest[dlo.property] = discr;
            // defaultLayout.property can be undefined, but this is allowed by buffer-layout
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            dest[defaultLayout.property] = defaultLayout.decode(b, offset + contentOffset);
        } else dest = clo.decode(b, offset);
        return dest;
    }
    /** Implement {@link Layout#encode|encode} for {@link Union}.
     *
     * This API assumes the `src` object is consistent with the union's
     * {@link Union#defaultLayout|default layout}.  To encode variants
     * use the appropriate variant-specific {@link VariantLayout#encode}
     * method. */ encode(src, b, offset = 0) {
        const vlo = this.getSourceVariant(src);
        if (undefined === vlo) {
            const dlo = this.discriminator;
            // this.defaultLayout is not undefined when vlo is undefined
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            const clo = this.defaultLayout;
            let contentOffset = 0;
            if (this.usesPrefixDiscriminator) contentOffset = dlo.layout.span;
            dlo.encode(src[dlo.property], b, offset);
            // clo.property is not undefined when vlo is undefined
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            return contentOffset + clo.encode(src[clo.property], b, offset + contentOffset);
        }
        return vlo.encode(src, b, offset);
    }
    /** Register a new variant structure within a union.  The newly
     * created variant is returned.
     *
     * @param {Number} variant - initializer for {@link
     * VariantLayout#variant|variant}.
     *
     * @param {Layout} layout - initializer for {@link
     * VariantLayout#layout|layout}.
     *
     * @param {String} property - initializer for {@link
     * Layout#property|property}.
     *
     * @return {VariantLayout} */ addVariant(variant, layout, property) {
        const rv = new VariantLayout(this, variant, layout, property);
        this.registry[variant] = rv;
        return rv;
    }
    /**
     * Get the layout associated with a registered variant.
     *
     * If `vb` does not produce a registered variant the function returns
     * `undefined`.
     *
     * @param {(Number|Uint8Array)} vb - either the variant number, or a
     * buffer from which the discriminator is to be read.
     *
     * @param {Number} offset - offset into `vb` for the start of the
     * union.  Used only when `vb` is an instance of {Uint8Array}.
     *
     * @return {({VariantLayout}|undefined)}
     */ getVariant(vb, offset = 0) {
        let variant;
        if (vb instanceof Uint8Array) variant = this.discriminator.decode(vb, offset);
        else variant = vb;
        return this.registry[variant];
    }
}
exports.Union = Union;
/**
 * Represent a specific variant within a containing union.
 *
 * **NOTE** The {@link Layout#span|span} of the variant may include
 * the span of the {@link Union#discriminator|discriminator} used to
 * identify it, but values read and written using the variant strictly
 * conform to the content of {@link VariantLayout#layout|layout}.
 *
 * **NOTE** User code should not invoke this constructor directly.  Use
 * the union {@link Union#addVariant|addVariant} helper method.
 *
 * @param {Union} union - initializer for {@link
 * VariantLayout#union|union}.
 *
 * @param {Number} variant - initializer for {@link
 * VariantLayout#variant|variant}.
 *
 * @param {Layout} [layout] - initializer for {@link
 * VariantLayout#layout|layout}.  If absent the variant carries no
 * data.
 *
 * @param {String} [property] - initializer for {@link
 * Layout#property|property}.  Unlike many other layouts, variant
 * layouts normally include a property name so they can be identified
 * within their containing {@link Union}.  The property identifier may
 * be absent only if `layout` is is absent.
 *
 * @augments {Layout}
 */ class VariantLayout extends Layout {
    constructor(union, variant, layout, property){
        if (!(union instanceof Union)) throw new TypeError("union must be a Union");
        if (!Number.isInteger(variant) || 0 > variant) throw new TypeError("variant must be a (non-negative) integer");
        if ("string" === typeof layout && undefined === property) {
            property = layout;
            layout = null;
        }
        if (layout) {
            if (!(layout instanceof Layout)) throw new TypeError("layout must be a Layout");
            if (null !== union.defaultLayout && 0 <= layout.span && layout.span > union.defaultLayout.span) throw new Error("variant span exceeds span of containing union");
            if ("string" !== typeof property) throw new TypeError("variant must have a String property");
        }
        let span = union.span;
        if (0 > union.span) {
            span = layout ? layout.span : 0;
            if (0 <= span && union.usesPrefixDiscriminator) span += union.discriminator.layout.span;
        }
        super(span, property);
        /** The {@link Union} to which this variant belongs. */ this.union = union;
        /** The unsigned integral value identifying this variant within
         * the {@link Union#discriminator|discriminator} of the containing
         * union. */ this.variant = variant;
        /** The {@link Layout} to be used when reading/writing the
         * non-discriminator part of the {@link
         * VariantLayout#union|union}.  If `null` the variant carries no
         * data. */ this.layout = layout || null;
    }
    /** @override */ getSpan(b, offset = 0) {
        if (0 <= this.span) /* Will be equal to the containing union span if that is not
             * variable. */ return this.span;
        let contentOffset = 0;
        if (this.union.usesPrefixDiscriminator) contentOffset = this.union.discriminator.layout.span;
        /* Span is defined solely by the variant (and prefix discriminator) */ let span = 0;
        if (this.layout) span = this.layout.getSpan(b, offset + contentOffset);
        return contentOffset + span;
    }
    /** @override */ decode(b, offset = 0) {
        const dest = this.makeDestinationObject();
        if (this !== this.union.getVariant(b, offset)) throw new Error("variant mismatch");
        let contentOffset = 0;
        if (this.union.usesPrefixDiscriminator) contentOffset = this.union.discriminator.layout.span;
        if (this.layout) dest[this.property] = this.layout.decode(b, offset + contentOffset);
        else if (this.property) dest[this.property] = true;
        else if (this.union.usesPrefixDiscriminator) dest[this.union.discriminator.property] = this.variant;
        return dest;
    }
    /** @override */ encode(src, b, offset = 0) {
        let contentOffset = 0;
        if (this.union.usesPrefixDiscriminator) contentOffset = this.union.discriminator.layout.span;
        if (this.layout && !Object.prototype.hasOwnProperty.call(src, this.property)) throw new TypeError("variant lacks property " + this.property);
        this.union.discriminator.encode(this.variant, b, offset);
        let span = contentOffset;
        if (this.layout) {
            this.layout.encode(src[this.property], b, offset + contentOffset);
            span += this.layout.getSpan(b, offset + contentOffset);
            if (0 <= this.union.span && span > this.union.span) throw new Error("encoded variant overruns containing union");
        }
        return span;
    }
    /** Delegate {@link Layout#fromArray|fromArray} to {@link
     * VariantLayout#layout|layout}. */ fromArray(values) {
        if (this.layout) return this.layout.fromArray(values);
        return undefined;
    }
}
exports.VariantLayout = VariantLayout;
/** JavaScript chose to define bitwise operations as operating on
 * signed 32-bit values in 2's complement form, meaning any integer
 * with bit 31 set is going to look negative.  For right shifts that's
 * not a problem, because `>>>` is a logical shift, but for every
 * other bitwise operator we have to compensate for possible negative
 * results. */ function fixBitwiseResult(v) {
    if (0 > v) v += 0x100000000;
    return v;
}
/**
 * Contain a sequence of bit fields as an unsigned integer.
 *
 * *Factory*: {@link module:Layout.bits|bits}
 *
 * This is a container element; within it there are {@link BitField}
 * instances that provide the extracted properties.  The container
 * simply defines the aggregate representation and its bit ordering.
 * The representation is an object containing properties with numeric
 * or {@link Boolean} values.
 *
 * {@link BitField}s are added with the {@link
 * BitStructure#addField|addField} and {@link
 * BitStructure#addBoolean|addBoolean} methods.

 * @param {Layout} word - initializer for {@link
 * BitStructure#word|word}.  The parameter must be an instance of
 * {@link UInt} (or {@link UIntBE}) that is no more than 4 bytes wide.
 *
 * @param {bool} [msb] - `true` if the bit numbering starts at the
 * most significant bit of the containing word; `false` (default) if
 * it starts at the least significant bit of the containing word.  If
 * the parameter at this position is a string and `property` is
 * `undefined` the value of this argument will instead be used as the
 * value of `property`.
 *
 * @param {string} [property] - initializer for {@link
 * Layout#property|property}.
 *
 * @augments {Layout}
 */ class BitStructure extends Layout {
    constructor(word, msb, property){
        if (!(word instanceof UInt || word instanceof UIntBE)) throw new TypeError("word must be a UInt or UIntBE layout");
        if ("string" === typeof msb && undefined === property) {
            property = msb;
            msb = false;
        }
        if (4 < word.span) throw new RangeError("word cannot exceed 32 bits");
        super(word.span, property);
        /** The layout used for the packed value.  {@link BitField}
         * instances are packed sequentially depending on {@link
         * BitStructure#msb|msb}. */ this.word = word;
        /** Whether the bit sequences are packed starting at the most
         * significant bit growing down (`true`), or the least significant
         * bit growing up (`false`).
         *
         * **NOTE** Regardless of this value, the least significant bit of
         * any {@link BitField} value is the least significant bit of the
         * corresponding section of the packed value. */ this.msb = !!msb;
        /** The sequence of {@link BitField} layouts that comprise the
         * packed structure.
         *
         * **NOTE** The array remains mutable to allow fields to be {@link
         * BitStructure#addField|added} after construction.  Users should
         * not manipulate the content of this property.*/ this.fields = [];
        /* Storage for the value.  Capture a variable instead of using an
         * instance property because we don't want anything to change the
         * value without going through the mutator. */ let value = 0;
        this._packedSetValue = function(v) {
            value = fixBitwiseResult(v);
            return this;
        };
        this._packedGetValue = function() {
            return value;
        };
    }
    /** @override */ decode(b, offset = 0) {
        const dest = this.makeDestinationObject();
        const value = this.word.decode(b, offset);
        this._packedSetValue(value);
        for (const fd of this.fields)if (undefined !== fd.property) dest[fd.property] = fd.decode(b);
        return dest;
    }
    /** Implement {@link Layout#encode|encode} for {@link BitStructure}.
     *
     * If `src` is missing a property for a member with a defined {@link
     * Layout#property|property} the corresponding region of the packed
     * value is left unmodified.  Unused bits are also left unmodified. */ encode(src, b, offset = 0) {
        const value = this.word.decode(b, offset);
        this._packedSetValue(value);
        for (const fd of this.fields)if (undefined !== fd.property) {
            const fv = src[fd.property];
            if (undefined !== fv) fd.encode(fv);
        }
        return this.word.encode(this._packedGetValue(), b, offset);
    }
    /** Register a new bitfield with a containing bit structure.  The
     * resulting bitfield is returned.
     *
     * @param {Number} bits - initializer for {@link BitField#bits|bits}.
     *
     * @param {string} property - initializer for {@link
     * Layout#property|property}.
     *
     * @return {BitField} */ addField(bits, property) {
        const bf = new BitField(this, bits, property);
        this.fields.push(bf);
        return bf;
    }
    /** As with {@link BitStructure#addField|addField} for single-bit
     * fields with `boolean` value representation.
     *
     * @param {string} property - initializer for {@link
     * Layout#property|property}.
     *
     * @return {Boolean} */ // `Boolean` conflicts with the native primitive type
    // eslint-disable-next-line @typescript-eslint/ban-types
    addBoolean(property) {
        // This is my Boolean, not the Javascript one.
        const bf = new Boolean(this, property);
        this.fields.push(bf);
        return bf;
    }
    /**
     * Get access to the bit field for a given property.
     *
     * @param {String} property - the bit field of interest.
     *
     * @return {BitField} - the field associated with `property`, or
     * undefined if there is no such property.
     */ fieldFor(property) {
        if ("string" !== typeof property) throw new TypeError("property must be string");
        for (const fd of this.fields){
            if (fd.property === property) return fd;
        }
        return undefined;
    }
}
exports.BitStructure = BitStructure;
/**
 * Represent a sequence of bits within a {@link BitStructure}.
 *
 * All bit field values are represented as unsigned integers.
 *
 * **NOTE** User code should not invoke this constructor directly.
 * Use the container {@link BitStructure#addField|addField} helper
 * method.
 *
 * **NOTE** BitField instances are not instances of {@link Layout}
 * since {@link Layout#span|span} measures 8-bit units.
 *
 * @param {BitStructure} container - initializer for {@link
 * BitField#container|container}.
 *
 * @param {Number} bits - initializer for {@link BitField#bits|bits}.
 *
 * @param {string} [property] - initializer for {@link
 * Layout#property|property}.
 */ class BitField {
    constructor(container, bits, property){
        if (!(container instanceof BitStructure)) throw new TypeError("container must be a BitStructure");
        if (!Number.isInteger(bits) || 0 >= bits) throw new TypeError("bits must be positive integer");
        const totalBits = 8 * container.span;
        const usedBits = container.fields.reduce((sum, fd)=>sum + fd.bits, 0);
        if (bits + usedBits > totalBits) throw new Error("bits too long for span remainder (" + (totalBits - usedBits) + " of " + totalBits + " remain)");
        /** The {@link BitStructure} instance to which this bit field
         * belongs. */ this.container = container;
        /** The span of this value in bits. */ this.bits = bits;
        /** A mask of {@link BitField#bits|bits} bits isolating value bits
         * that fit within the field.
         *
         * That is, it masks a value that has not yet been shifted into
         * position within its containing packed integer. */ this.valueMask = (1 << bits) - 1;
        if (32 === bits) this.valueMask = 0xFFFFFFFF;
        /** The offset of the value within the containing packed unsigned
         * integer.  The least significant bit of the packed value is at
         * offset zero, regardless of bit ordering used. */ this.start = usedBits;
        if (this.container.msb) this.start = totalBits - usedBits - bits;
        /** A mask of {@link BitField#bits|bits} isolating the field value
         * within the containing packed unsigned integer. */ this.wordMask = fixBitwiseResult(this.valueMask << this.start);
        /** The property name used when this bitfield is represented in an
         * Object.
         *
         * Intended to be functionally equivalent to {@link
         * Layout#property}.
         *
         * If left undefined the corresponding span of bits will be
         * treated as padding: it will not be mutated by {@link
         * Layout#encode|encode} nor represented as a property in the
         * decoded Object. */ this.property = property;
    }
    /** Store a value into the corresponding subsequence of the containing
     * bit field. */ decode(b, offset) {
        const word = this.container._packedGetValue();
        const wordValue = fixBitwiseResult(word & this.wordMask);
        const value = wordValue >>> this.start;
        return value;
    }
    /** Store a value into the corresponding subsequence of the containing
     * bit field.
     *
     * **NOTE** This is not a specialization of {@link
     * Layout#encode|Layout.encode} and there is no return value. */ encode(value) {
        if ("number" !== typeof value || !Number.isInteger(value) || value !== fixBitwiseResult(value & this.valueMask)) throw new TypeError(nameWithProperty("BitField.encode", this) + " value must be integer not exceeding " + this.valueMask);
        const word = this.container._packedGetValue();
        const wordValue = fixBitwiseResult(value << this.start);
        this.container._packedSetValue(fixBitwiseResult(word & ~this.wordMask) | wordValue);
    }
}
exports.BitField = BitField;
/**
 * Represent a single bit within a {@link BitStructure} as a
 * JavaScript boolean.
 *
 * **NOTE** User code should not invoke this constructor directly.
 * Use the container {@link BitStructure#addBoolean|addBoolean} helper
 * method.
 *
 * @param {BitStructure} container - initializer for {@link
 * BitField#container|container}.
 *
 * @param {string} [property] - initializer for {@link
 * Layout#property|property}.
 *
 * @augments {BitField}
 */ /* eslint-disable no-extend-native */ class Boolean extends BitField {
    constructor(container, property){
        super(container, 1, property);
    }
    /** Override {@link BitField#decode|decode} for {@link Boolean|Boolean}.
     *
     * @returns {boolean} */ decode(b, offset) {
        return !!super.decode(b, offset);
    }
    /** @override */ encode(value) {
        if ("boolean" === typeof value) // BitField requires integer values
        value = +value;
        super.encode(value);
    }
}
exports.Boolean = Boolean;
/* eslint-enable no-extend-native */ /**
 * Contain a fixed-length block of arbitrary data, represented as a
 * Uint8Array.
 *
 * *Factory*: {@link module:Layout.blob|blob}
 *
 * @param {(Number|ExternalLayout)} length - initializes {@link
 * Blob#length|length}.
 *
 * @param {String} [property] - initializer for {@link
 * Layout#property|property}.
 *
 * @augments {Layout}
 */ class Blob extends Layout {
    constructor(length, property){
        if (!(length instanceof ExternalLayout && length.isCount() || Number.isInteger(length) && 0 <= length)) throw new TypeError("length must be positive integer or an unsigned integer ExternalLayout");
        let span = -1;
        if (!(length instanceof ExternalLayout)) span = length;
        super(span, property);
        /** The number of bytes in the blob.
         *
         * This may be a non-negative integer, or an instance of {@link
         * ExternalLayout} that satisfies {@link
         * ExternalLayout#isCount|isCount()}. */ this.length = length;
    }
    /** @override */ getSpan(b, offset) {
        let span = this.span;
        if (0 > span) span = this.length.decode(b, offset);
        return span;
    }
    /** @override */ decode(b, offset = 0) {
        let span = this.span;
        if (0 > span) span = this.length.decode(b, offset);
        return uint8ArrayToBuffer(b).slice(offset, offset + span);
    }
    /** Implement {@link Layout#encode|encode} for {@link Blob}.
     *
     * **NOTE** If {@link Layout#count|count} is an instance of {@link
     * ExternalLayout} then the length of `src` will be encoded as the
     * count after `src` is encoded. */ encode(src, b, offset) {
        let span = this.length;
        if (this.length instanceof ExternalLayout) span = src.length;
        if (!(src instanceof Uint8Array && span === src.length)) throw new TypeError(nameWithProperty("Blob.encode", this) + " requires (length " + span + ") Uint8Array as src");
        if (offset + span > b.length) throw new RangeError("encoding overruns Uint8Array");
        const srcBuffer = uint8ArrayToBuffer(src);
        uint8ArrayToBuffer(b).write(srcBuffer.toString("hex"), offset, span, "hex");
        if (this.length instanceof ExternalLayout) this.length.encode(span, b, offset);
        return span;
    }
}
exports.Blob = Blob;
/**
 * Contain a `NUL`-terminated UTF8 string.
 *
 * *Factory*: {@link module:Layout.cstr|cstr}
 *
 * **NOTE** Any UTF8 string that incorporates a zero-valued byte will
 * not be correctly decoded by this layout.
 *
 * @param {String} [property] - initializer for {@link
 * Layout#property|property}.
 *
 * @augments {Layout}
 */ class CString extends Layout {
    constructor(property){
        super(-1, property);
    }
    /** @override */ getSpan(b, offset = 0) {
        checkUint8Array(b);
        let idx = offset;
        while(idx < b.length && 0 !== b[idx])idx += 1;
        return 1 + idx - offset;
    }
    /** @override */ decode(b, offset = 0) {
        const span = this.getSpan(b, offset);
        return uint8ArrayToBuffer(b).slice(offset, offset + span - 1).toString("utf-8");
    }
    /** @override */ encode(src, b, offset = 0) {
        /* Must force this to a string, lest it be a number and the
         * "utf8-encoding" below actually allocate a buffer of length
         * src */ if ("string" !== typeof src) src = String(src);
        const srcb = buffer_1.Buffer.from(src, "utf8");
        const span = srcb.length;
        if (offset + span > b.length) throw new RangeError("encoding overruns Buffer");
        const buffer = uint8ArrayToBuffer(b);
        srcb.copy(buffer, offset);
        buffer[offset + span] = 0;
        return span + 1;
    }
}
exports.CString = CString;
/**
 * Contain a UTF8 string with implicit length.
 *
 * *Factory*: {@link module:Layout.utf8|utf8}
 *
 * **NOTE** Because the length is implicit in the size of the buffer
 * this layout should be used only in isolation, or in a situation
 * where the length can be expressed by operating on a slice of the
 * containing buffer.
 *
 * @param {Number} [maxSpan] - the maximum length allowed for encoded
 * string content.  If not provided there is no bound on the allowed
 * content.
 *
 * @param {String} [property] - initializer for {@link
 * Layout#property|property}.
 *
 * @augments {Layout}
 */ class UTF8 extends Layout {
    constructor(maxSpan, property){
        if ("string" === typeof maxSpan && undefined === property) {
            property = maxSpan;
            maxSpan = undefined;
        }
        if (undefined === maxSpan) maxSpan = -1;
        else if (!Number.isInteger(maxSpan)) throw new TypeError("maxSpan must be an integer");
        super(-1, property);
        /** The maximum span of the layout in bytes.
         *
         * Positive values are generally expected.  Zero is abnormal.
         * Attempts to encode or decode a value that exceeds this length
         * will throw a `RangeError`.
         *
         * A negative value indicates that there is no bound on the length
         * of the content. */ this.maxSpan = maxSpan;
    }
    /** @override */ getSpan(b, offset = 0) {
        checkUint8Array(b);
        return b.length - offset;
    }
    /** @override */ decode(b, offset = 0) {
        const span = this.getSpan(b, offset);
        if (0 <= this.maxSpan && this.maxSpan < span) throw new RangeError("text length exceeds maxSpan");
        return uint8ArrayToBuffer(b).slice(offset, offset + span).toString("utf-8");
    }
    /** @override */ encode(src, b, offset = 0) {
        /* Must force this to a string, lest it be a number and the
         * "utf8-encoding" below actually allocate a buffer of length
         * src */ if ("string" !== typeof src) src = String(src);
        const srcb = buffer_1.Buffer.from(src, "utf8");
        const span = srcb.length;
        if (0 <= this.maxSpan && this.maxSpan < span) throw new RangeError("text length exceeds maxSpan");
        if (offset + span > b.length) throw new RangeError("encoding overruns Buffer");
        srcb.copy(uint8ArrayToBuffer(b), offset);
        return span;
    }
}
exports.UTF8 = UTF8;
/**
 * Contain a constant value.
 *
 * This layout may be used in cases where a JavaScript value can be
 * inferred without an expression in the binary encoding.  An example
 * would be a {@link VariantLayout|variant layout} where the content
 * is implied by the union {@link Union#discriminator|discriminator}.
 *
 * @param {Object|Number|String} value - initializer for {@link
 * Constant#value|value}.  If the value is an object (or array) and
 * the application intends the object to remain unchanged regardless
 * of what is done to values decoded by this layout, the value should
 * be frozen prior passing it to this constructor.
 *
 * @param {String} [property] - initializer for {@link
 * Layout#property|property}.
 *
 * @augments {Layout}
 */ class Constant extends Layout {
    constructor(value, property){
        super(0, property);
        /** The value produced by this constant when the layout is {@link
         * Constant#decode|decoded}.
         *
         * Any JavaScript value including `null` and `undefined` is
         * permitted.
         *
         * **WARNING** If `value` passed in the constructor was not
         * frozen, it is possible for users of decoded values to change
         * the content of the value. */ this.value = value;
    }
    /** @override */ decode(b, offset) {
        return this.value;
    }
    /** @override */ encode(src, b, offset) {
        /* Constants take no space */ return 0;
    }
}
exports.Constant = Constant;
/** Factory for {@link GreedyCount}. */ exports.greedy = (elementSpan, property)=>new GreedyCount(elementSpan, property);
/** Factory for {@link OffsetLayout}. */ exports.offset = (layout, offset, property)=>new OffsetLayout(layout, offset, property);
/** Factory for {@link UInt|unsigned int layouts} spanning one
 * byte. */ exports.u8 = (property)=>new UInt(1, property);
/** Factory for {@link UInt|little-endian unsigned int layouts}
 * spanning two bytes. */ exports.u16 = (property)=>new UInt(2, property);
/** Factory for {@link UInt|little-endian unsigned int layouts}
 * spanning three bytes. */ exports.u24 = (property)=>new UInt(3, property);
/** Factory for {@link UInt|little-endian unsigned int layouts}
 * spanning four bytes. */ exports.u32 = (property)=>new UInt(4, property);
/** Factory for {@link UInt|little-endian unsigned int layouts}
 * spanning five bytes. */ exports.u40 = (property)=>new UInt(5, property);
/** Factory for {@link UInt|little-endian unsigned int layouts}
 * spanning six bytes. */ exports.u48 = (property)=>new UInt(6, property);
/** Factory for {@link NearUInt64|little-endian unsigned int
 * layouts} interpreted as Numbers. */ exports.nu64 = (property)=>new NearUInt64(property);
/** Factory for {@link UInt|big-endian unsigned int layouts}
 * spanning two bytes. */ exports.u16be = (property)=>new UIntBE(2, property);
/** Factory for {@link UInt|big-endian unsigned int layouts}
 * spanning three bytes. */ exports.u24be = (property)=>new UIntBE(3, property);
/** Factory for {@link UInt|big-endian unsigned int layouts}
 * spanning four bytes. */ exports.u32be = (property)=>new UIntBE(4, property);
/** Factory for {@link UInt|big-endian unsigned int layouts}
 * spanning five bytes. */ exports.u40be = (property)=>new UIntBE(5, property);
/** Factory for {@link UInt|big-endian unsigned int layouts}
 * spanning six bytes. */ exports.u48be = (property)=>new UIntBE(6, property);
/** Factory for {@link NearUInt64BE|big-endian unsigned int
 * layouts} interpreted as Numbers. */ exports.nu64be = (property)=>new NearUInt64BE(property);
/** Factory for {@link Int|signed int layouts} spanning one
 * byte. */ exports.s8 = (property)=>new Int(1, property);
/** Factory for {@link Int|little-endian signed int layouts}
 * spanning two bytes. */ exports.s16 = (property)=>new Int(2, property);
/** Factory for {@link Int|little-endian signed int layouts}
 * spanning three bytes. */ exports.s24 = (property)=>new Int(3, property);
/** Factory for {@link Int|little-endian signed int layouts}
 * spanning four bytes. */ exports.s32 = (property)=>new Int(4, property);
/** Factory for {@link Int|little-endian signed int layouts}
 * spanning five bytes. */ exports.s40 = (property)=>new Int(5, property);
/** Factory for {@link Int|little-endian signed int layouts}
 * spanning six bytes. */ exports.s48 = (property)=>new Int(6, property);
/** Factory for {@link NearInt64|little-endian signed int layouts}
 * interpreted as Numbers. */ exports.ns64 = (property)=>new NearInt64(property);
/** Factory for {@link Int|big-endian signed int layouts}
 * spanning two bytes. */ exports.s16be = (property)=>new IntBE(2, property);
/** Factory for {@link Int|big-endian signed int layouts}
 * spanning three bytes. */ exports.s24be = (property)=>new IntBE(3, property);
/** Factory for {@link Int|big-endian signed int layouts}
 * spanning four bytes. */ exports.s32be = (property)=>new IntBE(4, property);
/** Factory for {@link Int|big-endian signed int layouts}
 * spanning five bytes. */ exports.s40be = (property)=>new IntBE(5, property);
/** Factory for {@link Int|big-endian signed int layouts}
 * spanning six bytes. */ exports.s48be = (property)=>new IntBE(6, property);
/** Factory for {@link NearInt64BE|big-endian signed int layouts}
 * interpreted as Numbers. */ exports.ns64be = (property)=>new NearInt64BE(property);
/** Factory for {@link Float|little-endian 32-bit floating point} values. */ exports.f32 = (property)=>new Float(property);
/** Factory for {@link FloatBE|big-endian 32-bit floating point} values. */ exports.f32be = (property)=>new FloatBE(property);
/** Factory for {@link Double|little-endian 64-bit floating point} values. */ exports.f64 = (property)=>new Double(property);
/** Factory for {@link DoubleBE|big-endian 64-bit floating point} values. */ exports.f64be = (property)=>new DoubleBE(property);
/** Factory for {@link Structure} values. */ exports.struct = (fields, property, decodePrefixes)=>new Structure(fields, property, decodePrefixes);
/** Factory for {@link BitStructure} values. */ exports.bits = (word, msb, property)=>new BitStructure(word, msb, property);
/** Factory for {@link Sequence} values. */ exports.seq = (elementLayout, count, property)=>new Sequence(elementLayout, count, property);
/** Factory for {@link Union} values. */ exports.union = (discr, defaultLayout, property)=>new Union(discr, defaultLayout, property);
/** Factory for {@link UnionLayoutDiscriminator} values. */ exports.unionLayoutDiscriminator = (layout, property)=>new UnionLayoutDiscriminator(layout, property);
/** Factory for {@link Blob} values. */ exports.blob = (length, property)=>new Blob(length, property);
/** Factory for {@link CString} values. */ exports.cstr = (property)=>new CString(property);
/** Factory for {@link UTF8} values. */ exports.utf8 = (maxSpan, property)=>new UTF8(maxSpan, property);
/** Factory for {@link Constant} values. */ exports.constant = (value, property)=>new Constant(value, property);

},{"fd98bf021fd3e926":"fCgem"}],"b5EGn":[function(require,module,exports) {
var Buffer = require("5fa2fb9efb36be62").Buffer;
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
let converter;
/**
 * Convert a little-endian buffer into a BigInt.
 * @param buf The little-endian buffer to convert
 * @returns A BigInt with the little-endian representation of buf.
 */ function toBigIntLE(buf) {
    {
        const reversed = Buffer.from(buf);
        reversed.reverse();
        const hex = reversed.toString("hex");
        if (hex.length === 0) return BigInt(0);
        return BigInt(`0x${hex}`);
    }
    return converter.toBigInt(buf, false);
}
exports.toBigIntLE = toBigIntLE;
/**
 * Convert a big-endian buffer into a BigInt
 * @param buf The big-endian buffer to convert.
 * @returns A BigInt with the big-endian representation of buf.
 */ function toBigIntBE(buf) {
    {
        const hex = buf.toString("hex");
        if (hex.length === 0) return BigInt(0);
        return BigInt(`0x${hex}`);
    }
    return converter.toBigInt(buf, true);
}
exports.toBigIntBE = toBigIntBE;
/**
 * Convert a BigInt to a little-endian buffer.
 * @param num   The BigInt to convert.
 * @param width The number of bytes that the resulting buffer should be.
 * @returns A little-endian buffer representation of num.
 */ function toBufferLE(num, width) {
    {
        const hex = num.toString(16);
        const buffer = Buffer.from(hex.padStart(width * 2, "0").slice(0, width * 2), "hex");
        buffer.reverse();
        return buffer;
    }
    // Allocation is done here, since it is slower using napi in C
    return converter.fromBigInt(num, Buffer.allocUnsafe(width), false);
}
exports.toBufferLE = toBufferLE;
/**
 * Convert a BigInt to a big-endian buffer.
 * @param num   The BigInt to convert.
 * @param width The number of bytes that the resulting buffer should be.
 * @returns A big-endian buffer representation of num.
 */ function toBufferBE(num, width) {
    {
        const hex = num.toString(16);
        return Buffer.from(hex.padStart(width * 2, "0").slice(0, width * 2), "hex");
    }
    return converter.fromBigInt(num, Buffer.allocUnsafe(width), true);
}
exports.toBufferBE = toBufferBE;

},{"5fa2fb9efb36be62":"fCgem"}],"lC06T":[function(require,module,exports) {
/**
 * A `StructFailure` represents a single specific failure in validation.
 */ /**
 * `StructError` objects are thrown (or returned) when validation fails.
 *
 * Validation logic is design to exit early for maximum performance. The error
 * represents the first error encountered during validation. For more detail,
 * the `error.failures` property is a generator function that can be run to
 * continue validation and receive all the failures in the data.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Struct", ()=>Struct);
parcelHelpers.export(exports, "StructError", ()=>StructError);
parcelHelpers.export(exports, "any", ()=>any);
parcelHelpers.export(exports, "array", ()=>array);
parcelHelpers.export(exports, "assert", ()=>assert);
parcelHelpers.export(exports, "assign", ()=>assign);
parcelHelpers.export(exports, "bigint", ()=>bigint);
parcelHelpers.export(exports, "boolean", ()=>boolean);
parcelHelpers.export(exports, "coerce", ()=>coerce);
parcelHelpers.export(exports, "create", ()=>create);
parcelHelpers.export(exports, "date", ()=>date);
parcelHelpers.export(exports, "defaulted", ()=>defaulted);
parcelHelpers.export(exports, "define", ()=>define);
parcelHelpers.export(exports, "deprecated", ()=>deprecated);
parcelHelpers.export(exports, "dynamic", ()=>dynamic);
parcelHelpers.export(exports, "empty", ()=>empty);
parcelHelpers.export(exports, "enums", ()=>enums);
parcelHelpers.export(exports, "func", ()=>func);
parcelHelpers.export(exports, "instance", ()=>instance);
parcelHelpers.export(exports, "integer", ()=>integer);
parcelHelpers.export(exports, "intersection", ()=>intersection);
parcelHelpers.export(exports, "is", ()=>is);
parcelHelpers.export(exports, "lazy", ()=>lazy);
parcelHelpers.export(exports, "literal", ()=>literal);
parcelHelpers.export(exports, "map", ()=>map);
parcelHelpers.export(exports, "mask", ()=>mask);
parcelHelpers.export(exports, "max", ()=>max);
parcelHelpers.export(exports, "min", ()=>min);
parcelHelpers.export(exports, "never", ()=>never);
parcelHelpers.export(exports, "nonempty", ()=>nonempty);
parcelHelpers.export(exports, "nullable", ()=>nullable);
parcelHelpers.export(exports, "number", ()=>number);
parcelHelpers.export(exports, "object", ()=>object);
parcelHelpers.export(exports, "omit", ()=>omit);
parcelHelpers.export(exports, "optional", ()=>optional);
parcelHelpers.export(exports, "partial", ()=>partial);
parcelHelpers.export(exports, "pattern", ()=>pattern);
parcelHelpers.export(exports, "pick", ()=>pick);
parcelHelpers.export(exports, "record", ()=>record);
parcelHelpers.export(exports, "refine", ()=>refine);
parcelHelpers.export(exports, "regexp", ()=>regexp);
parcelHelpers.export(exports, "set", ()=>set);
parcelHelpers.export(exports, "size", ()=>size);
parcelHelpers.export(exports, "string", ()=>string);
parcelHelpers.export(exports, "struct", ()=>struct);
parcelHelpers.export(exports, "trimmed", ()=>trimmed);
parcelHelpers.export(exports, "tuple", ()=>tuple);
parcelHelpers.export(exports, "type", ()=>type);
parcelHelpers.export(exports, "union", ()=>union);
parcelHelpers.export(exports, "unknown", ()=>unknown);
parcelHelpers.export(exports, "validate", ()=>validate);
class StructError extends TypeError {
    constructor(failure, failures){
        let cached;
        const { message, explanation, ...rest } = failure;
        const { path } = failure;
        const msg = path.length === 0 ? message : `At path: ${path.join(".")} -- ${message}`;
        super(explanation ?? msg);
        if (explanation != null) this.cause = msg;
        Object.assign(this, rest);
        this.name = this.constructor.name;
        this.failures = ()=>{
            return cached ?? (cached = [
                failure,
                ...failures()
            ]);
        };
    }
}
/**
 * Check if a value is an iterator.
 */ function isIterable(x) {
    return isObject(x) && typeof x[Symbol.iterator] === "function";
}
/**
 * Check if a value is a plain object.
 */ function isObject(x) {
    return typeof x === "object" && x != null;
}
/**
 * Check if a value is a non-array object.
 */ function isNonArrayObject(x) {
    return isObject(x) && !Array.isArray(x);
}
/**
 * Check if a value is a plain object.
 */ function isPlainObject(x) {
    if (Object.prototype.toString.call(x) !== "[object Object]") return false;
    const prototype = Object.getPrototypeOf(x);
    return prototype === null || prototype === Object.prototype;
}
/**
 * Return a value as a printable string.
 */ function print(value) {
    if (typeof value === "symbol") return value.toString();
    return typeof value === "string" ? JSON.stringify(value) : `${value}`;
}
/**
 * Shifts (removes and returns) the first value from the `input` iterator.
 * Like `Array.prototype.shift()` but for an `Iterator`.
 */ function shiftIterator(input) {
    const { done, value } = input.next();
    return done ? undefined : value;
}
/**
 * Convert a single validation result to a failure.
 */ function toFailure(result, context, struct, value) {
    if (result === true) return;
    else if (result === false) result = {};
    else if (typeof result === "string") result = {
        message: result
    };
    const { path, branch } = context;
    const { type } = struct;
    const { refinement, message = `Expected a value of type \`${type}\`${refinement ? ` with refinement \`${refinement}\`` : ""}, but received: \`${print(value)}\`` } = result;
    return {
        value,
        type,
        refinement,
        key: path[path.length - 1],
        path,
        branch,
        ...result,
        message
    };
}
/**
 * Convert a validation result to an iterable of failures.
 */ function* toFailures(result, context, struct, value) {
    if (!isIterable(result)) result = [
        result
    ];
    for (const r of result){
        const failure = toFailure(r, context, struct, value);
        if (failure) yield failure;
    }
}
/**
 * Check a value against a struct, traversing deeply into nested values, and
 * returning an iterator of failures or success.
 */ function* run(value, struct, options = {}) {
    const { path = [], branch = [
        value
    ], coerce = false, mask = false } = options;
    const ctx = {
        path,
        branch,
        mask
    };
    if (coerce) value = struct.coercer(value, ctx);
    let status = "valid";
    for (const failure of struct.validator(value, ctx)){
        failure.explanation = options.message;
        status = "not_valid";
        yield [
            failure,
            undefined
        ];
    }
    for (let [k, v, s] of struct.entries(value, ctx)){
        const ts = run(v, s, {
            path: k === undefined ? path : [
                ...path,
                k
            ],
            branch: k === undefined ? branch : [
                ...branch,
                v
            ],
            coerce,
            mask,
            message: options.message
        });
        for (const t of ts){
            if (t[0]) {
                status = t[0].refinement != null ? "not_refined" : "not_valid";
                yield [
                    t[0],
                    undefined
                ];
            } else if (coerce) {
                v = t[1];
                if (k === undefined) value = v;
                else if (value instanceof Map) value.set(k, v);
                else if (value instanceof Set) value.add(v);
                else if (isObject(value)) {
                    if (v !== undefined || k in value) value[k] = v;
                }
            }
        }
    }
    if (status !== "not_valid") for (const failure of struct.refiner(value, ctx)){
        failure.explanation = options.message;
        status = "not_refined";
        yield [
            failure,
            undefined
        ];
    }
    if (status === "valid") yield [
        undefined,
        value
    ];
}
/**
 * `Struct` objects encapsulate the validation logic for a specific type of
 * values. Once constructed, you use the `assert`, `is` or `validate` helpers to
 * validate unknown input data against the struct.
 */ class Struct {
    constructor(props){
        const { type, schema, validator, refiner, coercer = (value)=>value, entries = function*() {} } = props;
        this.type = type;
        this.schema = schema;
        this.entries = entries;
        this.coercer = coercer;
        if (validator) this.validator = (value, context)=>{
            const result = validator(value, context);
            return toFailures(result, context, this, value);
        };
        else this.validator = ()=>[];
        if (refiner) this.refiner = (value, context)=>{
            const result = refiner(value, context);
            return toFailures(result, context, this, value);
        };
        else this.refiner = ()=>[];
    }
    /**
     * Assert that a value passes the struct's validation, throwing if it doesn't.
     */ assert(value, message) {
        return assert(value, this, message);
    }
    /**
     * Create a value with the struct's coercion logic, then validate it.
     */ create(value, message) {
        return create(value, this, message);
    }
    /**
     * Check if a value passes the struct's validation.
     */ is(value) {
        return is(value, this);
    }
    /**
     * Mask a value, coercing and validating it, but returning only the subset of
     * properties defined by the struct's schema. Masking applies recursively to
     * props of `object` structs only.
     */ mask(value, message) {
        return mask(value, this, message);
    }
    /**
     * Validate a value with the struct's validation logic, returning a tuple
     * representing the result.
     *
     * You may optionally pass `true` for the `coerce` argument to coerce
     * the value before attempting to validate it. If you do, the result will
     * contain the coerced result when successful. Also, `mask` will turn on
     * masking of the unknown `object` props recursively if passed.
     */ validate(value, options = {}) {
        return validate(value, this, options);
    }
}
/**
 * Assert that a value passes a struct, throwing if it doesn't.
 */ function assert(value, struct, message) {
    const result = validate(value, struct, {
        message
    });
    if (result[0]) throw result[0];
}
/**
 * Create a value with the coercion logic of struct and validate it.
 */ function create(value, struct, message) {
    const result = validate(value, struct, {
        coerce: true,
        message
    });
    if (result[0]) throw result[0];
    else return result[1];
}
/**
 * Mask a value, returning only the subset of properties defined by a struct.
 */ function mask(value, struct, message) {
    const result = validate(value, struct, {
        coerce: true,
        mask: true,
        message
    });
    if (result[0]) throw result[0];
    else return result[1];
}
/**
 * Check if a value passes a struct.
 */ function is(value, struct) {
    const result = validate(value, struct);
    return !result[0];
}
/**
 * Validate a value against a struct, returning an error if invalid, or the
 * value (with potential coercion) if valid.
 */ function validate(value, struct, options = {}) {
    const tuples = run(value, struct, options);
    const tuple = shiftIterator(tuples);
    if (tuple[0]) {
        const error = new StructError(tuple[0], function*() {
            for (const t of tuples)if (t[0]) yield t[0];
        });
        return [
            error,
            undefined
        ];
    } else {
        const v = tuple[1];
        return [
            undefined,
            v
        ];
    }
}
function assign(...Structs) {
    const isType = Structs[0].type === "type";
    const schemas = Structs.map((s)=>s.schema);
    const schema = Object.assign({}, ...schemas);
    return isType ? type(schema) : object(schema);
}
/**
 * Define a new struct type with a custom validation function.
 */ function define(name, validator) {
    return new Struct({
        type: name,
        schema: null,
        validator
    });
}
/**
 * Create a new struct based on an existing struct, but the value is allowed to
 * be `undefined`. `log` will be called if the value is not `undefined`.
 */ function deprecated(struct, log) {
    return new Struct({
        ...struct,
        refiner: (value, ctx)=>value === undefined || struct.refiner(value, ctx),
        validator (value, ctx) {
            if (value === undefined) return true;
            else {
                log(value, ctx);
                return struct.validator(value, ctx);
            }
        }
    });
}
/**
 * Create a struct with dynamic validation logic.
 *
 * The callback will receive the value currently being validated, and must
 * return a struct object to validate it with. This can be useful to model
 * validation logic that changes based on its input.
 */ function dynamic(fn) {
    return new Struct({
        type: "dynamic",
        schema: null,
        *entries (value, ctx) {
            const struct = fn(value, ctx);
            yield* struct.entries(value, ctx);
        },
        validator (value, ctx) {
            const struct = fn(value, ctx);
            return struct.validator(value, ctx);
        },
        coercer (value, ctx) {
            const struct = fn(value, ctx);
            return struct.coercer(value, ctx);
        },
        refiner (value, ctx) {
            const struct = fn(value, ctx);
            return struct.refiner(value, ctx);
        }
    });
}
/**
 * Create a struct with lazily evaluated validation logic.
 *
 * The first time validation is run with the struct, the callback will be called
 * and must return a struct object to use. This is useful for cases where you
 * want to have self-referential structs for nested data structures to avoid a
 * circular definition problem.
 */ function lazy(fn) {
    let struct;
    return new Struct({
        type: "lazy",
        schema: null,
        *entries (value, ctx) {
            struct ?? (struct = fn());
            yield* struct.entries(value, ctx);
        },
        validator (value, ctx) {
            struct ?? (struct = fn());
            return struct.validator(value, ctx);
        },
        coercer (value, ctx) {
            struct ?? (struct = fn());
            return struct.coercer(value, ctx);
        },
        refiner (value, ctx) {
            struct ?? (struct = fn());
            return struct.refiner(value, ctx);
        }
    });
}
/**
 * Create a new struct based on an existing object struct, but excluding
 * specific properties.
 *
 * Like TypeScript's `Omit` utility.
 */ function omit(struct, keys) {
    const { schema } = struct;
    const subschema = {
        ...schema
    };
    for (const key of keys)delete subschema[key];
    switch(struct.type){
        case "type":
            return type(subschema);
        default:
            return object(subschema);
    }
}
/**
 * Create a new struct based on an existing object struct, but with all of its
 * properties allowed to be `undefined`.
 *
 * Like TypeScript's `Partial` utility.
 */ function partial(struct) {
    const isStruct = struct instanceof Struct;
    const schema = isStruct ? {
        ...struct.schema
    } : {
        ...struct
    };
    for(const key in schema)schema[key] = optional(schema[key]);
    if (isStruct && struct.type === "type") return type(schema);
    return object(schema);
}
/**
 * Create a new struct based on an existing object struct, but only including
 * specific properties.
 *
 * Like TypeScript's `Pick` utility.
 */ function pick(struct, keys) {
    const { schema } = struct;
    const subschema = {};
    for (const key of keys)subschema[key] = schema[key];
    switch(struct.type){
        case "type":
            return type(subschema);
        default:
            return object(subschema);
    }
}
/**
 * Define a new struct type with a custom validation function.
 *
 * @deprecated This function has been renamed to `define`.
 */ function struct(name, validator) {
    console.warn("superstruct@0.11 - The `struct` helper has been renamed to `define`.");
    return define(name, validator);
}
/**
 * Ensure that any value passes validation.
 */ function any() {
    return define("any", ()=>true);
}
function array(Element) {
    return new Struct({
        type: "array",
        schema: Element,
        *entries (value) {
            if (Element && Array.isArray(value)) for (const [i, v] of value.entries())yield [
                i,
                v,
                Element
            ];
        },
        coercer (value) {
            return Array.isArray(value) ? value.slice() : value;
        },
        validator (value) {
            return Array.isArray(value) || `Expected an array value, but received: ${print(value)}`;
        }
    });
}
/**
 * Ensure that a value is a bigint.
 */ function bigint() {
    return define("bigint", (value)=>{
        return typeof value === "bigint";
    });
}
/**
 * Ensure that a value is a boolean.
 */ function boolean() {
    return define("boolean", (value)=>{
        return typeof value === "boolean";
    });
}
/**
 * Ensure that a value is a valid `Date`.
 *
 * Note: this also ensures that the value is *not* an invalid `Date` object,
 * which can occur when parsing a date fails but still returns a `Date`.
 */ function date() {
    return define("date", (value)=>{
        return value instanceof Date && !isNaN(value.getTime()) || `Expected a valid \`Date\` object, but received: ${print(value)}`;
    });
}
function enums(values) {
    const schema = {};
    const description = values.map((v)=>print(v)).join();
    for (const key of values)schema[key] = key;
    return new Struct({
        type: "enums",
        schema,
        validator (value) {
            return values.includes(value) || `Expected one of \`${description}\`, but received: ${print(value)}`;
        }
    });
}
/**
 * Ensure that a value is a function.
 */ function func() {
    return define("func", (value)=>{
        return typeof value === "function" || `Expected a function, but received: ${print(value)}`;
    });
}
/**
 * Ensure that a value is an instance of a specific class.
 */ function instance(Class) {
    return define("instance", (value)=>{
        return value instanceof Class || `Expected a \`${Class.name}\` instance, but received: ${print(value)}`;
    });
}
/**
 * Ensure that a value is an integer.
 */ function integer() {
    return define("integer", (value)=>{
        return typeof value === "number" && !isNaN(value) && Number.isInteger(value) || `Expected an integer, but received: ${print(value)}`;
    });
}
/**
 * Ensure that a value matches all of a set of types.
 */ function intersection(Structs) {
    return new Struct({
        type: "intersection",
        schema: null,
        *entries (value, ctx) {
            for (const S of Structs)yield* S.entries(value, ctx);
        },
        *validator (value, ctx) {
            for (const S of Structs)yield* S.validator(value, ctx);
        },
        *refiner (value, ctx) {
            for (const S of Structs)yield* S.refiner(value, ctx);
        }
    });
}
function literal(constant) {
    const description = print(constant);
    const t = typeof constant;
    return new Struct({
        type: "literal",
        schema: t === "string" || t === "number" || t === "boolean" ? constant : null,
        validator (value) {
            return value === constant || `Expected the literal \`${description}\`, but received: ${print(value)}`;
        }
    });
}
function map(Key, Value) {
    return new Struct({
        type: "map",
        schema: null,
        *entries (value) {
            if (Key && Value && value instanceof Map) for (const [k, v] of value.entries()){
                yield [
                    k,
                    k,
                    Key
                ];
                yield [
                    k,
                    v,
                    Value
                ];
            }
        },
        coercer (value) {
            return value instanceof Map ? new Map(value) : value;
        },
        validator (value) {
            return value instanceof Map || `Expected a \`Map\` object, but received: ${print(value)}`;
        }
    });
}
/**
 * Ensure that no value ever passes validation.
 */ function never() {
    return define("never", ()=>false);
}
/**
 * Augment an existing struct to allow `null` values.
 */ function nullable(struct) {
    return new Struct({
        ...struct,
        validator: (value, ctx)=>value === null || struct.validator(value, ctx),
        refiner: (value, ctx)=>value === null || struct.refiner(value, ctx)
    });
}
/**
 * Ensure that a value is a number.
 */ function number() {
    return define("number", (value)=>{
        return typeof value === "number" && !isNaN(value) || `Expected a number, but received: ${print(value)}`;
    });
}
function object(schema) {
    const knowns = schema ? Object.keys(schema) : [];
    const Never = never();
    return new Struct({
        type: "object",
        schema: schema ? schema : null,
        *entries (value) {
            if (schema && isObject(value)) {
                const unknowns = new Set(Object.keys(value));
                for (const key of knowns){
                    unknowns.delete(key);
                    yield [
                        key,
                        value[key],
                        schema[key]
                    ];
                }
                for (const key of unknowns)yield [
                    key,
                    value[key],
                    Never
                ];
            }
        },
        validator (value) {
            return isNonArrayObject(value) || `Expected an object, but received: ${print(value)}`;
        },
        coercer (value, ctx) {
            if (!isNonArrayObject(value)) return value;
            const coerced = {
                ...value
            };
            // The `object` struct has special behaviour enabled by the mask flag.
            // When masking, properties that are not in the schema are deleted from
            // the coerced object instead of eventually failing validaiton.
            if (ctx.mask && schema) {
                for(const key in coerced)if (schema[key] === undefined) delete coerced[key];
            }
            return coerced;
        }
    });
}
/**
 * Augment a struct to allow `undefined` values.
 */ function optional(struct) {
    return new Struct({
        ...struct,
        validator: (value, ctx)=>value === undefined || struct.validator(value, ctx),
        refiner: (value, ctx)=>value === undefined || struct.refiner(value, ctx)
    });
}
/**
 * Ensure that a value is an object with keys and values of specific types, but
 * without ensuring any specific shape of properties.
 *
 * Like TypeScript's `Record` utility.
 */ function record(Key, Value) {
    return new Struct({
        type: "record",
        schema: null,
        *entries (value) {
            if (isObject(value)) for(const k in value){
                const v = value[k];
                yield [
                    k,
                    k,
                    Key
                ];
                yield [
                    k,
                    v,
                    Value
                ];
            }
        },
        validator (value) {
            return isNonArrayObject(value) || `Expected an object, but received: ${print(value)}`;
        },
        coercer (value) {
            return isNonArrayObject(value) ? {
                ...value
            } : value;
        }
    });
}
/**
 * Ensure that a value is a `RegExp`.
 *
 * Note: this does not test the value against the regular expression! For that
 * you need to use the `pattern()` refinement.
 */ function regexp() {
    return define("regexp", (value)=>{
        return value instanceof RegExp;
    });
}
function set(Element) {
    return new Struct({
        type: "set",
        schema: null,
        *entries (value) {
            if (Element && value instanceof Set) for (const v of value)yield [
                v,
                v,
                Element
            ];
        },
        coercer (value) {
            return value instanceof Set ? new Set(value) : value;
        },
        validator (value) {
            return value instanceof Set || `Expected a \`Set\` object, but received: ${print(value)}`;
        }
    });
}
/**
 * Ensure that a value is a string.
 */ function string() {
    return define("string", (value)=>{
        return typeof value === "string" || `Expected a string, but received: ${print(value)}`;
    });
}
/**
 * Ensure that a value is a tuple of a specific length, and that each of its
 * elements is of a specific type.
 */ function tuple(Structs) {
    const Never = never();
    return new Struct({
        type: "tuple",
        schema: null,
        *entries (value) {
            if (Array.isArray(value)) {
                const length = Math.max(Structs.length, value.length);
                for(let i = 0; i < length; i++)yield [
                    i,
                    value[i],
                    Structs[i] || Never
                ];
            }
        },
        validator (value) {
            return Array.isArray(value) || `Expected an array, but received: ${print(value)}`;
        },
        coercer (value) {
            return Array.isArray(value) ? value.slice() : value;
        }
    });
}
/**
 * Ensure that a value has a set of known properties of specific types.
 *
 * Note: Unrecognized properties are allowed and untouched. This is similar to
 * how TypeScript's structural typing works.
 */ function type(schema) {
    const keys = Object.keys(schema);
    return new Struct({
        type: "type",
        schema,
        *entries (value) {
            if (isObject(value)) for (const k of keys)yield [
                k,
                value[k],
                schema[k]
            ];
        },
        validator (value) {
            return isNonArrayObject(value) || `Expected an object, but received: ${print(value)}`;
        },
        coercer (value) {
            return isNonArrayObject(value) ? {
                ...value
            } : value;
        }
    });
}
/**
 * Ensure that a value matches one of a set of types.
 */ function union(Structs) {
    const description = Structs.map((s)=>s.type).join(" | ");
    return new Struct({
        type: "union",
        schema: null,
        coercer (value, ctx) {
            for (const S of Structs){
                const [error, coerced] = S.validate(value, {
                    coerce: true,
                    mask: ctx.mask
                });
                if (!error) return coerced;
            }
            return value;
        },
        validator (value, ctx) {
            const failures = [];
            for (const S of Structs){
                const [...tuples] = run(value, S, ctx);
                const [first] = tuples;
                if (!first[0]) return [];
                else {
                    for (const [failure] of tuples)if (failure) failures.push(failure);
                }
            }
            return [
                `Expected the value to satisfy a union of \`${description}\`, but received: ${print(value)}`,
                ...failures
            ];
        }
    });
}
/**
 * Ensure that any value passes validation, without widening its type to `any`.
 */ function unknown() {
    return define("unknown", ()=>true);
}
/**
 * Augment a `Struct` to add an additional coercion step to its input.
 *
 * This allows you to transform input data before validating it, to increase the
 * likelihood that it passes validationfor example for default values, parsing
 * different formats, etc.
 *
 * Note: You must use `create(value, Struct)` on the value to have the coercion
 * take effect! Using simply `assert()` or `is()` will not use coercion.
 */ function coerce(struct, condition, coercer) {
    return new Struct({
        ...struct,
        coercer: (value, ctx)=>{
            return is(value, condition) ? struct.coercer(coercer(value, ctx), ctx) : struct.coercer(value, ctx);
        }
    });
}
/**
 * Augment a struct to replace `undefined` values with a default.
 *
 * Note: You must use `create(value, Struct)` on the value to have the coercion
 * take effect! Using simply `assert()` or `is()` will not use coercion.
 */ function defaulted(struct, fallback, options = {}) {
    return coerce(struct, unknown(), (x)=>{
        const f = typeof fallback === "function" ? fallback() : fallback;
        if (x === undefined) return f;
        if (!options.strict && isPlainObject(x) && isPlainObject(f)) {
            const ret = {
                ...x
            };
            let changed = false;
            for(const key in f)if (ret[key] === undefined) {
                ret[key] = f[key];
                changed = true;
            }
            if (changed) return ret;
        }
        return x;
    });
}
/**
 * Augment a struct to trim string inputs.
 *
 * Note: You must use `create(value, Struct)` on the value to have the coercion
 * take effect! Using simply `assert()` or `is()` will not use coercion.
 */ function trimmed(struct) {
    return coerce(struct, string(), (x)=>x.trim());
}
/**
 * Ensure that a string, array, map, or set is empty.
 */ function empty(struct) {
    return refine(struct, "empty", (value)=>{
        const size = getSize(value);
        return size === 0 || `Expected an empty ${struct.type} but received one with a size of \`${size}\``;
    });
}
function getSize(value) {
    if (value instanceof Map || value instanceof Set) return value.size;
    else return value.length;
}
/**
 * Ensure that a number or date is below a threshold.
 */ function max(struct, threshold, options = {}) {
    const { exclusive } = options;
    return refine(struct, "max", (value)=>{
        return exclusive ? value < threshold : value <= threshold || `Expected a ${struct.type} less than ${exclusive ? "" : "or equal to "}${threshold} but received \`${value}\``;
    });
}
/**
 * Ensure that a number or date is above a threshold.
 */ function min(struct, threshold, options = {}) {
    const { exclusive } = options;
    return refine(struct, "min", (value)=>{
        return exclusive ? value > threshold : value >= threshold || `Expected a ${struct.type} greater than ${exclusive ? "" : "or equal to "}${threshold} but received \`${value}\``;
    });
}
/**
 * Ensure that a string, array, map or set is not empty.
 */ function nonempty(struct) {
    return refine(struct, "nonempty", (value)=>{
        const size = getSize(value);
        return size > 0 || `Expected a nonempty ${struct.type} but received an empty one`;
    });
}
/**
 * Ensure that a string matches a regular expression.
 */ function pattern(struct, regexp) {
    return refine(struct, "pattern", (value)=>{
        return regexp.test(value) || `Expected a ${struct.type} matching \`/${regexp.source}/\` but received "${value}"`;
    });
}
/**
 * Ensure that a string, array, number, date, map, or set has a size (or length, or time) between `min` and `max`.
 */ function size(struct, min, max = min) {
    const expected = `Expected a ${struct.type}`;
    const of = min === max ? `of \`${min}\`` : `between \`${min}\` and \`${max}\``;
    return refine(struct, "size", (value)=>{
        if (typeof value === "number" || value instanceof Date) return min <= value && value <= max || `${expected} ${of} but received \`${value}\``;
        else if (value instanceof Map || value instanceof Set) {
            const { size } = value;
            return min <= size && size <= max || `${expected} with a size ${of} but received one with a size of \`${size}\``;
        } else {
            const { length } = value;
            return min <= length && length <= max || `${expected} with a length ${of} but received one with a length of \`${length}\``;
        }
    });
}
/**
 * Augment a `Struct` to add an additional refinement to the validation.
 *
 * The refiner function is guaranteed to receive a value of the struct's type,
 * because the struct's existing validation will already have passed. This
 * allows you to layer additional validation on top of existing structs.
 */ function refine(struct, name, refiner) {
    return new Struct({
        ...struct,
        *refiner (value, ctx) {
            yield* struct.refiner(value, ctx);
            const result = refiner(value, ctx);
            const failures = toFailures(result, ctx, struct, value);
            for (const failure of failures)yield {
                ...failure,
                refinement: name
            };
        }
    });
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gkKU3":[function(require,module,exports) {
exports.interopDefault = function(a) {
    return a && a.__esModule ? a : {
        default: a
    };
};
exports.defineInteropFlag = function(a) {
    Object.defineProperty(a, "__esModule", {
        value: true
    });
};
exports.exportAll = function(source, dest) {
    Object.keys(source).forEach(function(key) {
        if (key === "default" || key === "__esModule" || Object.prototype.hasOwnProperty.call(dest, key)) return;
        Object.defineProperty(dest, key, {
            enumerable: true,
            get: function() {
                return source[key];
            }
        });
    });
    return dest;
};
exports.export = function(dest, destName, get) {
    Object.defineProperty(dest, destName, {
        enumerable: true,
        get: get
    });
};

},{}],"ckwy4":[function(require,module,exports) {
"use strict";
const uuid = require("c6d58fba4d04c1bc").v4;
const generateRequest = require("808ab8c72eb6d807");
/**
 * Constructor for a Jayson Browser Client that does not depend any node.js core libraries
 * @class ClientBrowser
 * @param {Function} callServer Method that calls the server, receives the stringified request and a regular node-style callback
 * @param {Object} [options]
 * @param {Function} [options.reviver] Reviver function for JSON
 * @param {Function} [options.replacer] Replacer function for JSON
 * @param {Number} [options.version=2] JSON-RPC version to use (1|2)
 * @param {Function} [options.generator] Function to use for generating request IDs
 *  @param {Boolean} [options.notificationIdNull=false] When true, version 2 requests will set id to null instead of omitting it
 * @return {ClientBrowser}
 */ const ClientBrowser = function(callServer, options) {
    if (!(this instanceof ClientBrowser)) return new ClientBrowser(callServer, options);
    if (!options) options = {};
    this.options = {
        reviver: typeof options.reviver !== "undefined" ? options.reviver : null,
        replacer: typeof options.replacer !== "undefined" ? options.replacer : null,
        generator: typeof options.generator !== "undefined" ? options.generator : function() {
            return uuid();
        },
        version: typeof options.version !== "undefined" ? options.version : 2,
        notificationIdNull: typeof options.notificationIdNull === "boolean" ? options.notificationIdNull : false
    };
    this.callServer = callServer;
};
module.exports = ClientBrowser;
/**
 *  Creates a request and dispatches it if given a callback.
 *  @param {String|Array} method A batch request if passed an Array, or a method name if passed a String
 *  @param {Array|Object} [params] Parameters for the method
 *  @param {String|Number} [id] Optional id. If undefined an id will be generated. If null it creates a notification request
 *  @param {Function} [callback] Request callback. If specified, executes the request rather than only returning it.
 *  @throws {TypeError} Invalid parameters
 *  @return {Object} JSON-RPC 1.0 or 2.0 compatible request
 */ ClientBrowser.prototype.request = function(method, params, id, callback) {
    const self = this;
    let request = null;
    // is this a batch request?
    const isBatch = Array.isArray(method) && typeof params === "function";
    if (this.options.version === 1 && isBatch) throw new TypeError("JSON-RPC 1.0 does not support batching");
    // is this a raw request?
    const isRaw = !isBatch && method && typeof method === "object" && typeof params === "function";
    if (isBatch || isRaw) {
        callback = params;
        request = method;
    } else {
        if (typeof id === "function") {
            callback = id;
            // specifically undefined because "null" is a notification request
            id = undefined;
        }
        const hasCallback = typeof callback === "function";
        try {
            request = generateRequest(method, params, id, {
                generator: this.options.generator,
                version: this.options.version,
                notificationIdNull: this.options.notificationIdNull
            });
        } catch (err) {
            if (hasCallback) return callback(err);
            throw err;
        }
        // no callback means we should just return a raw request
        if (!hasCallback) return request;
    }
    let message;
    try {
        message = JSON.stringify(request, this.options.replacer);
    } catch (err) {
        return callback(err);
    }
    this.callServer(message, function(err, response) {
        self._parseResponse(err, response, callback);
    });
    // always return the raw request
    return request;
};
/**
 * Parses a response from a server
 * @param {Object} err Error to pass on that is unrelated to the actual response
 * @param {String} responseText JSON-RPC 1.0 or 2.0 response
 * @param {Function} callback Callback that will receive different arguments depending on the amount of parameters
 * @private
 */ ClientBrowser.prototype._parseResponse = function(err, responseText, callback) {
    if (err) {
        callback(err);
        return;
    }
    if (!responseText) // empty response text, assume that is correct because it could be a
    // notification which jayson does not give any body for
    return callback();
    let response;
    try {
        response = JSON.parse(responseText, this.options.reviver);
    } catch (err) {
        return callback(err);
    }
    if (callback.length === 3) {
        // if callback length is 3, we split callback arguments on error and response
        // is batch response?
        if (Array.isArray(response)) {
            // neccesary to split strictly on validity according to spec here
            const isError = function(res) {
                return typeof res.error !== "undefined";
            };
            const isNotError = function(res) {
                return !isError(res);
            };
            return callback(null, response.filter(isError), response.filter(isNotError));
        } else // split regardless of validity
        return callback(null, response.error, response.result);
    }
    callback(null, response);
};

},{"c6d58fba4d04c1bc":"j4KJi","808ab8c72eb6d807":"10Eev"}],"j4KJi":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "v1", ()=>(0, _v1JsDefault.default));
parcelHelpers.export(exports, "v3", ()=>(0, _v3JsDefault.default));
parcelHelpers.export(exports, "v4", ()=>(0, _v4JsDefault.default));
parcelHelpers.export(exports, "v5", ()=>(0, _v5JsDefault.default));
parcelHelpers.export(exports, "NIL", ()=>(0, _nilJsDefault.default));
parcelHelpers.export(exports, "version", ()=>(0, _versionJsDefault.default));
parcelHelpers.export(exports, "validate", ()=>(0, _validateJsDefault.default));
parcelHelpers.export(exports, "stringify", ()=>(0, _stringifyJsDefault.default));
parcelHelpers.export(exports, "parse", ()=>(0, _parseJsDefault.default));
var _v1Js = require("./v1.js");
var _v1JsDefault = parcelHelpers.interopDefault(_v1Js);
var _v3Js = require("./v3.js");
var _v3JsDefault = parcelHelpers.interopDefault(_v3Js);
var _v4Js = require("./v4.js");
var _v4JsDefault = parcelHelpers.interopDefault(_v4Js);
var _v5Js = require("./v5.js");
var _v5JsDefault = parcelHelpers.interopDefault(_v5Js);
var _nilJs = require("./nil.js");
var _nilJsDefault = parcelHelpers.interopDefault(_nilJs);
var _versionJs = require("./version.js");
var _versionJsDefault = parcelHelpers.interopDefault(_versionJs);
var _validateJs = require("./validate.js");
var _validateJsDefault = parcelHelpers.interopDefault(_validateJs);
var _stringifyJs = require("./stringify.js");
var _stringifyJsDefault = parcelHelpers.interopDefault(_stringifyJs);
var _parseJs = require("./parse.js");
var _parseJsDefault = parcelHelpers.interopDefault(_parseJs);

},{"./v1.js":"9qfh9","./v3.js":"3RlI2","./v4.js":"8zJtu","./v5.js":"i3cfs","./nil.js":"kcLFq","./version.js":"gvRcF","./validate.js":"eHPgI","./stringify.js":"5Y9F1","./parse.js":"6aVVs","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9qfh9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _rngJs = require("./rng.js");
var _rngJsDefault = parcelHelpers.interopDefault(_rngJs);
var _stringifyJs = require("./stringify.js"); // **`v1()` - Generate time-based UUID**
var _stringifyJsDefault = parcelHelpers.interopDefault(_stringifyJs);
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html
var _nodeId;
var _clockseq; // Previous uuid creation time
var _lastMSecs = 0;
var _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details
function v1(options, buf, offset) {
    var i = buf && offset || 0;
    var b = buf || new Array(16);
    options = options || {};
    var node = options.node || _nodeId;
    var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not
    // specified.  We do this lazily to minimize issues related to insufficient
    // system entropy.  See #189
    if (node == null || clockseq == null) {
        var seedBytes = options.random || (options.rng || (0, _rngJsDefault.default))();
        if (node == null) // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
        node = _nodeId = [
            seedBytes[0] | 0x01,
            seedBytes[1],
            seedBytes[2],
            seedBytes[3],
            seedBytes[4],
            seedBytes[5]
        ];
        if (clockseq == null) // Per 4.2.2, randomize (14 bit) clockseq
        clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;
    } // UUID timestamps are 100 nano-second units since the Gregorian epoch,
    // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
    // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
    // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.
    var msecs = options.msecs !== undefined ? options.msecs : Date.now(); // Per 4.2.1.2, use count of uuid's generated during the current clock
    // cycle to simulate higher resolution clock
    var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)
    var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression
    if (dt < 0 && options.clockseq === undefined) clockseq = clockseq + 1 & 0x3fff;
     // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
    // time interval
    if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) nsecs = 0;
     // Per 4.2.1.2 Throw error if too many uuids are requested
    if (nsecs >= 10000) throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
    _lastMSecs = msecs;
    _lastNSecs = nsecs;
    _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch
    msecs += 12219292800000; // `time_low`
    var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
    b[i++] = tl >>> 24 & 0xff;
    b[i++] = tl >>> 16 & 0xff;
    b[i++] = tl >>> 8 & 0xff;
    b[i++] = tl & 0xff; // `time_mid`
    var tmh = msecs / 0x100000000 * 10000 & 0xfffffff;
    b[i++] = tmh >>> 8 & 0xff;
    b[i++] = tmh & 0xff; // `time_high_and_version`
    b[i++] = tmh >>> 24 & 0xf | 0x10; // include version
    b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)
    b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`
    b[i++] = clockseq & 0xff; // `node`
    for(var n = 0; n < 6; ++n)b[i + n] = node[n];
    return buf || (0, _stringifyJsDefault.default)(b);
}
exports.default = v1;

},{"./rng.js":"2psyE","./stringify.js":"5Y9F1","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2psyE":[function(require,module,exports) {
// Unique ID creation requires a high quality random # generator. In the browser we therefore
// require the crypto API and do not support built-in fallback to lower quality random number
// generators (like Math.random()).
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>rng);
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
    // lazy load so that environments that need to polyfill have a chance to do so
    if (!getRandomValues) {
        // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation. Also,
        // find the complete implementation of crypto (msCrypto) on IE11.
        getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== "undefined" && typeof msCrypto.getRandomValues === "function" && msCrypto.getRandomValues.bind(msCrypto);
        if (!getRandomValues) throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
    return getRandomValues(rnds8);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5Y9F1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _validateJs = require("./validate.js");
var _validateJsDefault = parcelHelpers.interopDefault(_validateJs);
/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */ var byteToHex = [];
for(var i = 0; i < 256; ++i)byteToHex.push((i + 0x100).toString(16).substr(1));
function stringify(arr) {
    var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    // Note: Be careful editing this code!  It's been tuned for performance
    // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
    var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one
    // of the following:
    // - One or more input array values don't map to a hex octet (leading to
    // "undefined" in the uuid)
    // - Invalid input values for the RFC `version` or `variant` fields
    if (!(0, _validateJsDefault.default)(uuid)) throw TypeError("Stringified UUID is invalid");
    return uuid;
}
exports.default = stringify;

},{"./validate.js":"eHPgI","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eHPgI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _regexJs = require("./regex.js");
var _regexJsDefault = parcelHelpers.interopDefault(_regexJs);
function validate(uuid) {
    return typeof uuid === "string" && (0, _regexJsDefault.default).test(uuid);
}
exports.default = validate;

},{"./regex.js":"bUa5g","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bUa5g":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3RlI2":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _v35Js = require("./v35.js");
var _v35JsDefault = parcelHelpers.interopDefault(_v35Js);
var _md5Js = require("./md5.js");
var _md5JsDefault = parcelHelpers.interopDefault(_md5Js);
var v3 = (0, _v35JsDefault.default)("v3", 0x30, (0, _md5JsDefault.default));
exports.default = v3;

},{"./v35.js":"f7cVj","./md5.js":"k0SFu","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"f7cVj":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DNS", ()=>DNS);
parcelHelpers.export(exports, "URL", ()=>URL);
parcelHelpers.export(exports, "default", ()=>function(name, version, hashfunc) {
        function generateUUID(value, namespace, buf, offset) {
            if (typeof value === "string") value = stringToBytes(value);
            if (typeof namespace === "string") namespace = (0, _parseJsDefault.default)(namespace);
            if (namespace.length !== 16) throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
             // Compute hash of namespace and value, Per 4.3
            // Future: Use spread syntax when supported on all platforms, e.g. `bytes =
            // hashfunc([...namespace, ... value])`
            var bytes = new Uint8Array(16 + value.length);
            bytes.set(namespace);
            bytes.set(value, namespace.length);
            bytes = hashfunc(bytes);
            bytes[6] = bytes[6] & 0x0f | version;
            bytes[8] = bytes[8] & 0x3f | 0x80;
            if (buf) {
                offset = offset || 0;
                for(var i = 0; i < 16; ++i)buf[offset + i] = bytes[i];
                return buf;
            }
            return (0, _stringifyJsDefault.default)(bytes);
        } // Function#name is not settable on some platforms (#270)
        try {
            generateUUID.name = name; // eslint-disable-next-line no-empty
        } catch (err) {} // For CommonJS default export support
        generateUUID.DNS = DNS;
        generateUUID.URL = URL;
        return generateUUID;
    });
var _stringifyJs = require("./stringify.js");
var _stringifyJsDefault = parcelHelpers.interopDefault(_stringifyJs);
var _parseJs = require("./parse.js");
var _parseJsDefault = parcelHelpers.interopDefault(_parseJs);
function stringToBytes(str) {
    str = unescape(encodeURIComponent(str)); // UTF8 escape
    var bytes = [];
    for(var i = 0; i < str.length; ++i)bytes.push(str.charCodeAt(i));
    return bytes;
}
var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
var URL = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";

},{"./stringify.js":"5Y9F1","./parse.js":"6aVVs","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6aVVs":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _validateJs = require("./validate.js");
var _validateJsDefault = parcelHelpers.interopDefault(_validateJs);
function parse(uuid) {
    if (!(0, _validateJsDefault.default)(uuid)) throw TypeError("Invalid UUID");
    var v;
    var arr = new Uint8Array(16); // Parse ########-....-....-....-............
    arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
    arr[1] = v >>> 16 & 0xff;
    arr[2] = v >>> 8 & 0xff;
    arr[3] = v & 0xff; // Parse ........-####-....-....-............
    arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
    arr[5] = v & 0xff; // Parse ........-....-####-....-............
    arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
    arr[7] = v & 0xff; // Parse ........-....-....-####-............
    arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
    arr[9] = v & 0xff; // Parse ........-....-....-....-############
    // (Use "/" to avoid 32-bit truncation when bit-shifting high-order bytes)
    arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;
    arr[11] = v / 0x100000000 & 0xff;
    arr[12] = v >>> 24 & 0xff;
    arr[13] = v >>> 16 & 0xff;
    arr[14] = v >>> 8 & 0xff;
    arr[15] = v & 0xff;
    return arr;
}
exports.default = parse;

},{"./validate.js":"eHPgI","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"k0SFu":[function(require,module,exports) {
/*
 * Browser-compatible JavaScript MD5
 *
 * Modification of JavaScript MD5
 * https://github.com/blueimp/JavaScript-MD5
 *
 * Copyright 2011, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * https://opensource.org/licenses/MIT
 *
 * Based on
 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
 * Digest Algorithm, as defined in RFC 1321.
 * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for more info.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function md5(bytes) {
    if (typeof bytes === "string") {
        var msg = unescape(encodeURIComponent(bytes)); // UTF8 escape
        bytes = new Uint8Array(msg.length);
        for(var i = 0; i < msg.length; ++i)bytes[i] = msg.charCodeAt(i);
    }
    return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
}
/*
 * Convert an array of little-endian words to an array of bytes
 */ function md5ToHexEncodedArray(input) {
    var output = [];
    var length32 = input.length * 32;
    var hexTab = "0123456789abcdef";
    for(var i = 0; i < length32; i += 8){
        var x = input[i >> 5] >>> i % 32 & 0xff;
        var hex = parseInt(hexTab.charAt(x >>> 4 & 0x0f) + hexTab.charAt(x & 0x0f), 16);
        output.push(hex);
    }
    return output;
}
/**
 * Calculate output length with padding and bit length
 */ function getOutputLength(inputLength8) {
    return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
/*
 * Calculate the MD5 of an array of little-endian words, and a bit length.
 */ function wordsToMd5(x, len) {
    /* append padding */ x[len >> 5] |= 0x80 << len % 32;
    x[getOutputLength(len) - 1] = len;
    var a = 1732584193;
    var b = -271733879;
    var c = -1732584194;
    var d = 271733878;
    for(var i = 0; i < x.length; i += 16){
        var olda = a;
        var oldb = b;
        var oldc = c;
        var oldd = d;
        a = md5ff(a, b, c, d, x[i], 7, -680876936);
        d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
        c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
        b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
        a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
        d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
        c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
        b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
        a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
        d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
        c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
        b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
        a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
        d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
        c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
        b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);
        a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
        d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
        c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
        b = md5gg(b, c, d, a, x[i], 20, -373897302);
        a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
        d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
        c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
        b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
        a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
        d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
        c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
        b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
        a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
        d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
        c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
        b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);
        a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
        d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
        c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
        b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
        a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
        d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
        c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
        b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
        a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
        d = md5hh(d, a, b, c, x[i], 11, -358537222);
        c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
        b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
        a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
        d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
        c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
        b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);
        a = md5ii(a, b, c, d, x[i], 6, -198630844);
        d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
        c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
        b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
        a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
        d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
        c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
        b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
        a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
        d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
        c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
        b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
        a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
        d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
        c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
        b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);
        a = safeAdd(a, olda);
        b = safeAdd(b, oldb);
        c = safeAdd(c, oldc);
        d = safeAdd(d, oldd);
    }
    return [
        a,
        b,
        c,
        d
    ];
}
/*
 * Convert an array bytes to an array of little-endian words
 * Characters >255 have their high-byte silently ignored.
 */ function bytesToWords(input) {
    if (input.length === 0) return [];
    var length8 = input.length * 8;
    var output = new Uint32Array(getOutputLength(length8));
    for(var i = 0; i < length8; i += 8)output[i >> 5] |= (input[i / 8] & 0xff) << i % 32;
    return output;
}
/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */ function safeAdd(x, y) {
    var lsw = (x & 0xffff) + (y & 0xffff);
    var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
    return msw << 16 | lsw & 0xffff;
}
/*
 * Bitwise rotate a 32-bit number to the left.
 */ function bitRotateLeft(num, cnt) {
    return num << cnt | num >>> 32 - cnt;
}
/*
 * These functions implement the four basic operations the algorithm uses.
 */ function md5cmn(q, a, b, x, s, t) {
    return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);
}
function md5ff(a, b, c, d, x, s, t) {
    return md5cmn(b & c | ~b & d, a, b, x, s, t);
}
function md5gg(a, b, c, d, x, s, t) {
    return md5cmn(b & d | c & ~d, a, b, x, s, t);
}
function md5hh(a, b, c, d, x, s, t) {
    return md5cmn(b ^ c ^ d, a, b, x, s, t);
}
function md5ii(a, b, c, d, x, s, t) {
    return md5cmn(c ^ (b | ~d), a, b, x, s, t);
}
exports.default = md5;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8zJtu":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _rngJs = require("./rng.js");
var _rngJsDefault = parcelHelpers.interopDefault(_rngJs);
var _stringifyJs = require("./stringify.js");
var _stringifyJsDefault = parcelHelpers.interopDefault(_stringifyJs);
function v4(options, buf, offset) {
    options = options || {};
    var rnds = options.random || (options.rng || (0, _rngJsDefault.default))(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
    rnds[6] = rnds[6] & 0x0f | 0x40;
    rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided
    if (buf) {
        offset = offset || 0;
        for(var i = 0; i < 16; ++i)buf[offset + i] = rnds[i];
        return buf;
    }
    return (0, _stringifyJsDefault.default)(rnds);
}
exports.default = v4;

},{"./rng.js":"2psyE","./stringify.js":"5Y9F1","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"i3cfs":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _v35Js = require("./v35.js");
var _v35JsDefault = parcelHelpers.interopDefault(_v35Js);
var _sha1Js = require("./sha1.js");
var _sha1JsDefault = parcelHelpers.interopDefault(_sha1Js);
var v5 = (0, _v35JsDefault.default)("v5", 0x50, (0, _sha1JsDefault.default));
exports.default = v5;

},{"./v35.js":"f7cVj","./sha1.js":"BVVut","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"BVVut":[function(require,module,exports) {
// Adapted from Chris Veness' SHA1 code at
// http://www.movable-type.co.uk/scripts/sha1.html
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function f(s, x, y, z) {
    switch(s){
        case 0:
            return x & y ^ ~x & z;
        case 1:
            return x ^ y ^ z;
        case 2:
            return x & y ^ x & z ^ y & z;
        case 3:
            return x ^ y ^ z;
    }
}
function ROTL(x, n) {
    return x << n | x >>> 32 - n;
}
function sha1(bytes) {
    var K = [
        0x5a827999,
        0x6ed9eba1,
        0x8f1bbcdc,
        0xca62c1d6
    ];
    var H = [
        0x67452301,
        0xefcdab89,
        0x98badcfe,
        0x10325476,
        0xc3d2e1f0
    ];
    if (typeof bytes === "string") {
        var msg = unescape(encodeURIComponent(bytes)); // UTF8 escape
        bytes = [];
        for(var i = 0; i < msg.length; ++i)bytes.push(msg.charCodeAt(i));
    } else if (!Array.isArray(bytes)) // Convert Array-like to Array
    bytes = Array.prototype.slice.call(bytes);
    bytes.push(0x80);
    var l = bytes.length / 4 + 2;
    var N = Math.ceil(l / 16);
    var M = new Array(N);
    for(var _i = 0; _i < N; ++_i){
        var arr = new Uint32Array(16);
        for(var j = 0; j < 16; ++j)arr[j] = bytes[_i * 64 + j * 4] << 24 | bytes[_i * 64 + j * 4 + 1] << 16 | bytes[_i * 64 + j * 4 + 2] << 8 | bytes[_i * 64 + j * 4 + 3];
        M[_i] = arr;
    }
    M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
    M[N - 1][14] = Math.floor(M[N - 1][14]);
    M[N - 1][15] = (bytes.length - 1) * 8 & 0xffffffff;
    for(var _i2 = 0; _i2 < N; ++_i2){
        var W = new Uint32Array(80);
        for(var t = 0; t < 16; ++t)W[t] = M[_i2][t];
        for(var _t = 16; _t < 80; ++_t)W[_t] = ROTL(W[_t - 3] ^ W[_t - 8] ^ W[_t - 14] ^ W[_t - 16], 1);
        var a = H[0];
        var b = H[1];
        var c = H[2];
        var d = H[3];
        var e = H[4];
        for(var _t2 = 0; _t2 < 80; ++_t2){
            var s = Math.floor(_t2 / 20);
            var T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[_t2] >>> 0;
            e = d;
            d = c;
            c = ROTL(b, 30) >>> 0;
            b = a;
            a = T;
        }
        H[0] = H[0] + a >>> 0;
        H[1] = H[1] + b >>> 0;
        H[2] = H[2] + c >>> 0;
        H[3] = H[3] + d >>> 0;
        H[4] = H[4] + e >>> 0;
    }
    return [
        H[0] >> 24 & 0xff,
        H[0] >> 16 & 0xff,
        H[0] >> 8 & 0xff,
        H[0] & 0xff,
        H[1] >> 24 & 0xff,
        H[1] >> 16 & 0xff,
        H[1] >> 8 & 0xff,
        H[1] & 0xff,
        H[2] >> 24 & 0xff,
        H[2] >> 16 & 0xff,
        H[2] >> 8 & 0xff,
        H[2] & 0xff,
        H[3] >> 24 & 0xff,
        H[3] >> 16 & 0xff,
        H[3] >> 8 & 0xff,
        H[3] & 0xff,
        H[4] >> 24 & 0xff,
        H[4] >> 16 & 0xff,
        H[4] >> 8 & 0xff,
        H[4] & 0xff
    ];
}
exports.default = sha1;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kcLFq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = "00000000-0000-0000-0000-000000000000";

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gvRcF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _validateJs = require("./validate.js");
var _validateJsDefault = parcelHelpers.interopDefault(_validateJs);
function version(uuid) {
    if (!(0, _validateJsDefault.default)(uuid)) throw TypeError("Invalid UUID");
    return parseInt(uuid.substr(14, 1), 16);
}
exports.default = version;

},{"./validate.js":"eHPgI","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"10Eev":[function(require,module,exports) {
"use strict";
const uuid = require("9b4bb9ec494f18ae").v4;
/**
 *  Generates a JSON-RPC 1.0 or 2.0 request
 *  @param {String} method Name of method to call
 *  @param {Array|Object} params Array of parameters passed to the method as specified, or an object of parameter names and corresponding value
 *  @param {String|Number|null} [id] Request ID can be a string, number, null for explicit notification or left out for automatic generation
 *  @param {Object} [options]
 *  @param {Number} [options.version=2] JSON-RPC version to use (1 or 2)
 *  @param {Boolean} [options.notificationIdNull=false] When true, version 2 requests will set id to null instead of omitting it
 *  @param {Function} [options.generator] Passed the request, and the options object and is expected to return a request ID
 *  @throws {TypeError} If any of the parameters are invalid
 *  @return {Object} A JSON-RPC 1.0 or 2.0 request
 *  @memberOf Utils
 */ const generateRequest = function(method, params, id, options) {
    if (typeof method !== "string") throw new TypeError(method + " must be a string");
    options = options || {};
    // check valid version provided
    const version = typeof options.version === "number" ? options.version : 2;
    if (version !== 1 && version !== 2) throw new TypeError(version + " must be 1 or 2");
    const request = {
        method: method
    };
    if (version === 2) request.jsonrpc = "2.0";
    if (params) {
        // params given, but invalid?
        if (typeof params !== "object" && !Array.isArray(params)) throw new TypeError(params + " must be an object, array or omitted");
        request.params = params;
    }
    // if id was left out, generate one (null means explicit notification)
    if (typeof id === "undefined") {
        const generator = typeof options.generator === "function" ? options.generator : function() {
            return uuid();
        };
        request.id = generator(request, options);
    } else if (version === 2 && id === null) // we have a version 2 notification
    {
        if (options.notificationIdNull) request.id = null; // id will not be set at all unless option provided
    } else request.id = id;
    return request;
};
module.exports = generateRequest;

},{"9b4bb9ec494f18ae":"j4KJi"}],"261rv":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Client", ()=>Client) //# sourceMappingURL=out.js.map
;
parcelHelpers.export(exports, "CommonClient", ()=>CommonClient);
parcelHelpers.export(exports, "DefaultDataPack", ()=>DefaultDataPack);
parcelHelpers.export(exports, "WebSocket", ()=>WebSocket);
var _buffer = require("buffer");
var _eventemitter3 = require("eventemitter3");
// node_modules/esbuild-plugin-polyfill-node/polyfills/buffer.js
var WebSocketBrowserImpl = class extends (0, _eventemitter3.EventEmitter) {
    socket;
    /** Instantiate a WebSocket class
  * @constructor
  * @param {String} address - url to a websocket server
  * @param {(Object)} options - websocket options
  * @param {(String|Array)} protocols - a list of protocols
  * @return {WebSocketBrowserImpl} - returns a WebSocket instance
  */ constructor(address, options, protocols){
        super();
        this.socket = new window.WebSocket(address, protocols);
        this.socket.onopen = ()=>this.emit("open");
        this.socket.onmessage = (event)=>this.emit("message", event.data);
        this.socket.onerror = (error)=>this.emit("error", error);
        this.socket.onclose = (event)=>{
            this.emit("close", event.code, event.reason);
        };
    }
    /**
  * Sends data through a websocket connection
  * @method
  * @param {(String|Object)} data - data to be sent via websocket
  * @param {Object} optionsOrCallback - ws options
  * @param {Function} callback - a callback called once the data is sent
  * @return {Undefined}
  */ send(data, optionsOrCallback, callback) {
        const cb = callback || optionsOrCallback;
        try {
            this.socket.send(data);
            cb();
        } catch (error) {
            cb(error);
        }
    }
    /**
  * Closes an underlying socket
  * @method
  * @param {Number} code - status code explaining why the connection is being closed
  * @param {String} reason - a description why the connection is closing
  * @return {Undefined}
  * @throws {Error}
  */ close(code, reason) {
        this.socket.close(code, reason);
    }
    addEventListener(type, listener, options) {
        this.socket.addEventListener(type, listener, options);
    }
};
function WebSocket(address, options) {
    return new WebSocketBrowserImpl(address, options);
}
// src/lib/utils.ts
var DefaultDataPack = class {
    encode(value) {
        return JSON.stringify(value);
    }
    decode(value) {
        return JSON.parse(value);
    }
};
// src/lib/client.ts
var CommonClient = class extends (0, _eventemitter3.EventEmitter) {
    address;
    rpc_id;
    queue;
    options;
    autoconnect;
    ready;
    reconnect;
    reconnect_timer_id;
    reconnect_interval;
    max_reconnects;
    rest_options;
    current_reconnects;
    generate_request_id;
    socket;
    webSocketFactory;
    dataPack;
    /**
  * Instantiate a Client class.
  * @constructor
  * @param {webSocketFactory} webSocketFactory - factory method for WebSocket
  * @param {String} address - url to a websocket server
  * @param {Object} options - ws options object with reconnect parameters
  * @param {Function} generate_request_id - custom generation request Id
  * @param {DataPack} dataPack - data pack contains encoder and decoder
  * @return {CommonClient}
  */ constructor(webSocketFactory, address = "ws://localhost:8080", { autoconnect = true, reconnect = true, reconnect_interval = 1e3, max_reconnects = 5, ...rest_options } = {}, generate_request_id, dataPack){
        super();
        this.webSocketFactory = webSocketFactory;
        this.queue = {};
        this.rpc_id = 0;
        this.address = address;
        this.autoconnect = autoconnect;
        this.ready = false;
        this.reconnect = reconnect;
        this.reconnect_timer_id = void 0;
        this.reconnect_interval = reconnect_interval;
        this.max_reconnects = max_reconnects;
        this.rest_options = rest_options;
        this.current_reconnects = 0;
        this.generate_request_id = generate_request_id || (()=>++this.rpc_id);
        if (!dataPack) this.dataPack = new DefaultDataPack();
        else this.dataPack = dataPack;
        if (this.autoconnect) this._connect(this.address, {
            autoconnect: this.autoconnect,
            reconnect: this.reconnect,
            reconnect_interval: this.reconnect_interval,
            max_reconnects: this.max_reconnects,
            ...this.rest_options
        });
    }
    /**
  * Connects to a defined server if not connected already.
  * @method
  * @return {Undefined}
  */ connect() {
        if (this.socket) return;
        this._connect(this.address, {
            autoconnect: this.autoconnect,
            reconnect: this.reconnect,
            reconnect_interval: this.reconnect_interval,
            max_reconnects: this.max_reconnects,
            ...this.rest_options
        });
    }
    /**
  * Calls a registered RPC method on server.
  * @method
  * @param {String} method - RPC method name
  * @param {Object|Array} params - optional method parameters
  * @param {Number} timeout - RPC reply timeout value
  * @param {Object} ws_opts - options passed to ws
  * @return {Promise}
  */ call(method, params, timeout, ws_opts) {
        if (!ws_opts && "object" === typeof timeout) {
            ws_opts = timeout;
            timeout = null;
        }
        return new Promise((resolve, reject)=>{
            if (!this.ready) return reject(new Error("socket not ready"));
            const rpc_id = this.generate_request_id(method, params);
            const message = {
                jsonrpc: "2.0",
                method,
                params: params || void 0,
                id: rpc_id
            };
            this.socket.send(this.dataPack.encode(message), ws_opts, (error)=>{
                if (error) return reject(error);
                this.queue[rpc_id] = {
                    promise: [
                        resolve,
                        reject
                    ]
                };
                if (timeout) this.queue[rpc_id].timeout = setTimeout(()=>{
                    delete this.queue[rpc_id];
                    reject(new Error("reply timeout"));
                }, timeout);
            });
        });
    }
    /**
  * Logins with the other side of the connection.
  * @method
  * @param {Object} params - Login credentials object
  * @return {Promise}
  */ async login(params) {
        const resp = await this.call("rpc.login", params);
        if (!resp) throw new Error("authentication failed");
        return resp;
    }
    /**
  * Fetches a list of client's methods registered on server.
  * @method
  * @return {Array}
  */ async listMethods() {
        return await this.call("__listMethods");
    }
    /**
  * Sends a JSON-RPC 2.0 notification to server.
  * @method
  * @param {String} method - RPC method name
  * @param {Object} params - optional method parameters
  * @return {Promise}
  */ notify(method, params) {
        return new Promise((resolve, reject)=>{
            if (!this.ready) return reject(new Error("socket not ready"));
            const message = {
                jsonrpc: "2.0",
                method,
                params
            };
            this.socket.send(this.dataPack.encode(message), (error)=>{
                if (error) return reject(error);
                resolve();
            });
        });
    }
    /**
  * Subscribes for a defined event.
  * @method
  * @param {String|Array} event - event name
  * @return {Undefined}
  * @throws {Error}
  */ async subscribe(event) {
        if (typeof event === "string") event = [
            event
        ];
        const result = await this.call("rpc.on", event);
        if (typeof event === "string" && result[event] !== "ok") throw new Error("Failed subscribing to an event '" + event + "' with: " + result[event]);
        return result;
    }
    /**
  * Unsubscribes from a defined event.
  * @method
  * @param {String|Array} event - event name
  * @return {Undefined}
  * @throws {Error}
  */ async unsubscribe(event) {
        if (typeof event === "string") event = [
            event
        ];
        const result = await this.call("rpc.off", event);
        if (typeof event === "string" && result[event] !== "ok") throw new Error("Failed unsubscribing from an event with: " + result);
        return result;
    }
    /**
  * Closes a WebSocket connection gracefully.
  * @method
  * @param {Number} code - socket close code
  * @param {String} data - optional data to be sent before closing
  * @return {Undefined}
  */ close(code, data) {
        this.socket.close(code || 1e3, data);
    }
    /**
  * Enable / disable automatic reconnection.
  * @method
  * @param {Boolean} reconnect - enable / disable reconnection
  * @return {Undefined}
  */ setAutoReconnect(reconnect) {
        this.reconnect = reconnect;
    }
    /**
  * Set the interval between reconnection attempts.
  * @method
  * @param {Number} interval - reconnection interval in milliseconds
  * @return {Undefined}
  */ setReconnectInterval(interval) {
        this.reconnect_interval = interval;
    }
    /**
  * Set the maximum number of reconnection attempts.
  * @method
  * @param {Number} max_reconnects - maximum reconnection attempts
  * @return {Undefined}
  */ setMaxReconnects(max_reconnects) {
        this.max_reconnects = max_reconnects;
    }
    /**
  * Connection/Message handler.
  * @method
  * @private
  * @param {String} address - WebSocket API address
  * @param {Object} options - ws options object
  * @return {Undefined}
  */ _connect(address, options) {
        clearTimeout(this.reconnect_timer_id);
        this.socket = this.webSocketFactory(address, options);
        this.socket.addEventListener("open", ()=>{
            this.ready = true;
            this.emit("open");
            this.current_reconnects = 0;
        });
        this.socket.addEventListener("message", ({ data: message })=>{
            if (message instanceof ArrayBuffer) message = (0, _buffer.Buffer).from(message).toString();
            try {
                message = this.dataPack.decode(message);
            } catch (error) {
                return;
            }
            if (message.notification && this.listeners(message.notification).length) {
                if (!Object.keys(message.params).length) return this.emit(message.notification);
                const args = [
                    message.notification
                ];
                if (message.params.constructor === Object) args.push(message.params);
                else for(let i = 0; i < message.params.length; i++)args.push(message.params[i]);
                return Promise.resolve().then(()=>{
                    this.emit.apply(this, args);
                });
            }
            if (!this.queue[message.id]) {
                if (message.method) return Promise.resolve().then(()=>{
                    this.emit(message.method, message?.params);
                });
                return;
            }
            if ("error" in message === "result" in message) this.queue[message.id].promise[1](new Error('Server response malformed. Response must include either "result" or "error", but not both.'));
            if (this.queue[message.id].timeout) clearTimeout(this.queue[message.id].timeout);
            if (message.error) this.queue[message.id].promise[1](message.error);
            else this.queue[message.id].promise[0](message.result);
            delete this.queue[message.id];
        });
        this.socket.addEventListener("error", (error)=>this.emit("error", error));
        this.socket.addEventListener("close", ({ code, reason })=>{
            if (this.ready) setTimeout(()=>this.emit("close", code, reason), 0);
            this.ready = false;
            this.socket = void 0;
            if (code === 1e3) return;
            this.current_reconnects++;
            if (this.reconnect && (this.max_reconnects > this.current_reconnects || this.max_reconnects === 0)) this.reconnect_timer_id = setTimeout(()=>this._connect(address, options), this.reconnect_interval);
        });
    }
};
// src/index.browser.ts
var Client = class extends CommonClient {
    constructor(address = "ws://localhost:8080", { autoconnect = true, reconnect = true, reconnect_interval = 1e3, max_reconnects = 5 } = {}, generate_request_id){
        super(WebSocket, address, {
            autoconnect,
            reconnect,
            reconnect_interval,
            max_reconnects
        }, generate_request_id);
    }
};

},{"buffer":"fCgem","eventemitter3":"3fnfh","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3fnfh":[function(require,module,exports) {
"use strict";
var has = Object.prototype.hasOwnProperty, prefix = "~";
/**
 * Constructor to create a storage for our `EE` objects.
 * An `Events` instance is a plain object whose properties are event names.
 *
 * @constructor
 * @private
 */ function Events() {}
//
// We try to not inherit from `Object.prototype`. In some engines creating an
// instance in this way is faster than calling `Object.create(null)` directly.
// If `Object.create(null)` is not supported we prefix the event names with a
// character to make sure that the built-in object properties are not
// overridden or used as an attack vector.
//
if (Object.create) {
    Events.prototype = Object.create(null);
    //
    // This hack is needed because the `__proto__` property is still inherited in
    // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.
    //
    if (!new Events().__proto__) prefix = false;
}
/**
 * Representation of a single event listener.
 *
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
 * @constructor
 * @private
 */ function EE(fn, context, once) {
    this.fn = fn;
    this.context = context;
    this.once = once || false;
}
/**
 * Add a listener for a given event.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} once Specify if the listener is a one-time listener.
 * @returns {EventEmitter}
 * @private
 */ function addListener(emitter, event, fn, context, once) {
    if (typeof fn !== "function") throw new TypeError("The listener must be a function");
    var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
    if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
    else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
    else emitter._events[evt] = [
        emitter._events[evt],
        listener
    ];
    return emitter;
}
/**
 * Clear event by name.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} evt The Event name.
 * @private
 */ function clearEvent(emitter, evt) {
    if (--emitter._eventsCount === 0) emitter._events = new Events();
    else delete emitter._events[evt];
}
/**
 * Minimal `EventEmitter` interface that is molded against the Node.js
 * `EventEmitter` interface.
 *
 * @constructor
 * @public
 */ function EventEmitter() {
    this._events = new Events();
    this._eventsCount = 0;
}
/**
 * Return an array listing the events for which the emitter has registered
 * listeners.
 *
 * @returns {Array}
 * @public
 */ EventEmitter.prototype.eventNames = function eventNames() {
    var names = [], events, name;
    if (this._eventsCount === 0) return names;
    for(name in events = this._events)if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
    if (Object.getOwnPropertySymbols) return names.concat(Object.getOwnPropertySymbols(events));
    return names;
};
/**
 * Return the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Array} The registered listeners.
 * @public
 */ EventEmitter.prototype.listeners = function listeners(event) {
    var evt = prefix ? prefix + event : event, handlers = this._events[evt];
    if (!handlers) return [];
    if (handlers.fn) return [
        handlers.fn
    ];
    for(var i = 0, l = handlers.length, ee = new Array(l); i < l; i++)ee[i] = handlers[i].fn;
    return ee;
};
/**
 * Return the number of listeners listening to a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Number} The number of listeners.
 * @public
 */ EventEmitter.prototype.listenerCount = function listenerCount(event) {
    var evt = prefix ? prefix + event : event, listeners = this._events[evt];
    if (!listeners) return 0;
    if (listeners.fn) return 1;
    return listeners.length;
};
/**
 * Calls each of the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Boolean} `true` if the event had listeners, else `false`.
 * @public
 */ EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt]) return false;
    var listeners = this._events[evt], len = arguments.length, args, i;
    if (listeners.fn) {
        if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);
        switch(len){
            case 1:
                return listeners.fn.call(listeners.context), true;
            case 2:
                return listeners.fn.call(listeners.context, a1), true;
            case 3:
                return listeners.fn.call(listeners.context, a1, a2), true;
            case 4:
                return listeners.fn.call(listeners.context, a1, a2, a3), true;
            case 5:
                return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
            case 6:
                return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for(i = 1, args = new Array(len - 1); i < len; i++)args[i - 1] = arguments[i];
        listeners.fn.apply(listeners.context, args);
    } else {
        var length = listeners.length, j;
        for(i = 0; i < length; i++){
            if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);
            switch(len){
                case 1:
                    listeners[i].fn.call(listeners[i].context);
                    break;
                case 2:
                    listeners[i].fn.call(listeners[i].context, a1);
                    break;
                case 3:
                    listeners[i].fn.call(listeners[i].context, a1, a2);
                    break;
                case 4:
                    listeners[i].fn.call(listeners[i].context, a1, a2, a3);
                    break;
                default:
                    if (!args) for(j = 1, args = new Array(len - 1); j < len; j++)args[j - 1] = arguments[j];
                    listeners[i].fn.apply(listeners[i].context, args);
            }
        }
    }
    return true;
};
/**
 * Add a listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */ EventEmitter.prototype.on = function on(event, fn, context) {
    return addListener(this, event, fn, context, false);
};
/**
 * Add a one-time listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */ EventEmitter.prototype.once = function once(event, fn, context) {
    return addListener(this, event, fn, context, true);
};
/**
 * Remove the listeners of a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn Only remove the listeners that match this function.
 * @param {*} context Only remove the listeners that have this context.
 * @param {Boolean} once Only remove one-time listeners.
 * @returns {EventEmitter} `this`.
 * @public
 */ EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt]) return this;
    if (!fn) {
        clearEvent(this, evt);
        return this;
    }
    var listeners = this._events[evt];
    if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) clearEvent(this, evt);
    } else {
        for(var i = 0, events = [], length = listeners.length; i < length; i++)if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) events.push(listeners[i]);
        //
        // Reset the array, or remove it completely if we have no more listeners.
        //
        if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
        else clearEvent(this, evt);
    }
    return this;
};
/**
 * Remove all listeners, or those of the specified event.
 *
 * @param {(String|Symbol)} [event] The event name.
 * @returns {EventEmitter} `this`.
 * @public
 */ EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
    var evt;
    if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt]) clearEvent(this, evt);
    } else {
        this._events = new Events();
        this._eventsCount = 0;
    }
    return this;
};
//
// Alias methods names because people roll like that.
//
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.addListener = EventEmitter.prototype.on;
//
// Expose the prefix.
//
EventEmitter.prefixed = prefix;
//
// Allow `EventEmitter` to be imported as module namespace.
//
EventEmitter.EventEmitter = EventEmitter;
module.exports = EventEmitter;

},{}],"7YJSg":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.shake256 = exports.shake128 = exports.keccak_512 = exports.keccak_384 = exports.keccak_256 = exports.keccak_224 = exports.sha3_512 = exports.sha3_384 = exports.sha3_256 = exports.sha3_224 = exports.Keccak = void 0;
exports.keccakP = keccakP;
const _assert_js_1 = require("14db7b8ea2b5bceb");
const _u64_js_1 = require("45e8a44e40fd6b7f");
const utils_js_1 = require("5a04751f3e786b49");
// SHA3 (keccak) is based on a new design: basically, the internal state is bigger than output size.
// It's called a sponge function.
// Various per round constants calculations
const SHA3_PI = [];
const SHA3_ROTL = [];
const _SHA3_IOTA = [];
const _0n = /* @__PURE__ */ BigInt(0);
const _1n = /* @__PURE__ */ BigInt(1);
const _2n = /* @__PURE__ */ BigInt(2);
const _7n = /* @__PURE__ */ BigInt(7);
const _256n = /* @__PURE__ */ BigInt(256);
const _0x71n = /* @__PURE__ */ BigInt(0x71);
for(let round = 0, R = _1n, x = 1, y = 0; round < 24; round++){
    // Pi
    [x, y] = [
        y,
        (2 * x + 3 * y) % 5
    ];
    SHA3_PI.push(2 * (5 * y + x));
    // Rotational
    SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
    // Iota
    let t = _0n;
    for(let j = 0; j < 7; j++){
        R = (R << _1n ^ (R >> _7n) * _0x71n) % _256n;
        if (R & _2n) t ^= _1n << (_1n << /* @__PURE__ */ BigInt(j)) - _1n;
    }
    _SHA3_IOTA.push(t);
}
const [SHA3_IOTA_H, SHA3_IOTA_L] = /* @__PURE__ */ (0, _u64_js_1.split)(_SHA3_IOTA, true);
// Left rotation (without 0, 32, 64)
const rotlH = (h, l, s)=>s > 32 ? (0, _u64_js_1.rotlBH)(h, l, s) : (0, _u64_js_1.rotlSH)(h, l, s);
const rotlL = (h, l, s)=>s > 32 ? (0, _u64_js_1.rotlBL)(h, l, s) : (0, _u64_js_1.rotlSL)(h, l, s);
// Same as keccakf1600, but allows to skip some rounds
function keccakP(s, rounds = 24) {
    const B = new Uint32Array(10);
    // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)
    for(let round = 24 - rounds; round < 24; round++){
        // Theta 
        for(let x = 0; x < 10; x++)B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
        for(let x = 0; x < 10; x += 2){
            const idx1 = (x + 8) % 10;
            const idx0 = (x + 2) % 10;
            const B0 = B[idx0];
            const B1 = B[idx0 + 1];
            const Th = rotlH(B0, B1, 1) ^ B[idx1];
            const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
            for(let y = 0; y < 50; y += 10){
                s[x + y] ^= Th;
                s[x + y + 1] ^= Tl;
            }
        }
        // Rho () and Pi ()
        let curH = s[2];
        let curL = s[3];
        for(let t = 0; t < 24; t++){
            const shift = SHA3_ROTL[t];
            const Th = rotlH(curH, curL, shift);
            const Tl = rotlL(curH, curL, shift);
            const PI = SHA3_PI[t];
            curH = s[PI];
            curL = s[PI + 1];
            s[PI] = Th;
            s[PI + 1] = Tl;
        }
        // Chi ()
        for(let y = 0; y < 50; y += 10){
            for(let x = 0; x < 10; x++)B[x] = s[y + x];
            for(let x = 0; x < 10; x++)s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
        }
        // Iota ()
        s[0] ^= SHA3_IOTA_H[round];
        s[1] ^= SHA3_IOTA_L[round];
    }
    B.fill(0);
}
class Keccak extends utils_js_1.Hash {
    // NOTE: we accept arguments in bytes instead of bits here.
    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24){
        super();
        this.blockLen = blockLen;
        this.suffix = suffix;
        this.outputLen = outputLen;
        this.enableXOF = enableXOF;
        this.rounds = rounds;
        this.pos = 0;
        this.posOut = 0;
        this.finished = false;
        this.destroyed = false;
        // Can be passed from user as dkLen
        (0, _assert_js_1.number)(outputLen);
        // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes
        if (0 >= this.blockLen || this.blockLen >= 200) throw new Error("Sha3 supports only keccak-f1600 function");
        this.state = new Uint8Array(200);
        this.state32 = (0, utils_js_1.u32)(this.state);
    }
    keccak() {
        if (!utils_js_1.isLE) (0, utils_js_1.byteSwap32)(this.state32);
        keccakP(this.state32, this.rounds);
        if (!utils_js_1.isLE) (0, utils_js_1.byteSwap32)(this.state32);
        this.posOut = 0;
        this.pos = 0;
    }
    update(data) {
        (0, _assert_js_1.exists)(this);
        const { blockLen, state } = this;
        data = (0, utils_js_1.toBytes)(data);
        const len = data.length;
        for(let pos = 0; pos < len;){
            const take = Math.min(blockLen - this.pos, len - pos);
            for(let i = 0; i < take; i++)state[this.pos++] ^= data[pos++];
            if (this.pos === blockLen) this.keccak();
        }
        return this;
    }
    finish() {
        if (this.finished) return;
        this.finished = true;
        const { state, suffix, pos, blockLen } = this;
        // Do the padding
        state[pos] ^= suffix;
        if ((suffix & 0x80) !== 0 && pos === blockLen - 1) this.keccak();
        state[blockLen - 1] ^= 0x80;
        this.keccak();
    }
    writeInto(out) {
        (0, _assert_js_1.exists)(this, false);
        (0, _assert_js_1.bytes)(out);
        this.finish();
        const bufferOut = this.state;
        const { blockLen } = this;
        for(let pos = 0, len = out.length; pos < len;){
            if (this.posOut >= blockLen) this.keccak();
            const take = Math.min(blockLen - this.posOut, len - pos);
            out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
            this.posOut += take;
            pos += take;
        }
        return out;
    }
    xofInto(out) {
        // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF
        if (!this.enableXOF) throw new Error("XOF is not possible for this instance");
        return this.writeInto(out);
    }
    xof(bytes) {
        (0, _assert_js_1.number)(bytes);
        return this.xofInto(new Uint8Array(bytes));
    }
    digestInto(out) {
        (0, _assert_js_1.output)(out, this);
        if (this.finished) throw new Error("digest() was already called");
        this.writeInto(out);
        this.destroy();
        return out;
    }
    digest() {
        return this.digestInto(new Uint8Array(this.outputLen));
    }
    destroy() {
        this.destroyed = true;
        this.state.fill(0);
    }
    _cloneInto(to) {
        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
        to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
        to.state32.set(this.state32);
        to.pos = this.pos;
        to.posOut = this.posOut;
        to.finished = this.finished;
        to.rounds = rounds;
        // Suffix can change in cSHAKE
        to.suffix = suffix;
        to.outputLen = outputLen;
        to.enableXOF = enableXOF;
        to.destroyed = this.destroyed;
        return to;
    }
}
exports.Keccak = Keccak;
const gen = (suffix, blockLen, outputLen)=>(0, utils_js_1.wrapConstructor)(()=>new Keccak(blockLen, suffix, outputLen));
exports.sha3_224 = gen(0x06, 144, 28);
/**
 * SHA3-256 hash function
 * @param message - that would be hashed
 */ exports.sha3_256 = gen(0x06, 136, 32);
exports.sha3_384 = gen(0x06, 104, 48);
exports.sha3_512 = gen(0x06, 72, 64);
exports.keccak_224 = gen(0x01, 144, 28);
/**
 * keccak-256 hash function. Different from SHA3-256.
 * @param message - that would be hashed
 */ exports.keccak_256 = gen(0x01, 136, 32);
exports.keccak_384 = gen(0x01, 104, 48);
exports.keccak_512 = gen(0x01, 72, 64);
const genShake = (suffix, blockLen, outputLen)=>(0, utils_js_1.wrapXOFConstructorWithOpts)((opts = {})=>new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true));
exports.shake128 = genShake(0x1f, 168, 16);
exports.shake256 = genShake(0x1f, 136, 32);

},{"14db7b8ea2b5bceb":"BFdql","45e8a44e40fd6b7f":"8TbxJ","5a04751f3e786b49":"2ehgp"}],"9sjVG":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.encodeToCurve = exports.hashToCurve = exports.schnorr = exports.secp256k1 = void 0;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const sha256_1 = require("a89c1505decc763e");
const utils_1 = require("362802f5a451efcb");
const _shortw_utils_js_1 = require("8a5ef77428763709");
const hash_to_curve_js_1 = require("992867e7d1ef8b");
const modular_js_1 = require("6a274edd04635854");
const utils_js_1 = require("49209a65a14a4a44");
const weierstrass_js_1 = require("4687d8e71912c9bd");
const secp256k1P = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f");
const secp256k1N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
const _1n = BigInt(1);
const _2n = BigInt(2);
const divNearest = (a, b)=>(a + b / _2n) / b;
/**
 * n = n^((p+1)/4) for fields p = 3 mod 4. We unwrap the loop and multiply bit-by-bit.
 * (P+1n/4n).toString(2) would produce bits [223x 1, 0, 22x 1, 4x 0, 11, 00]
 */ function sqrtMod(y) {
    const P = secp256k1P;
    // prettier-ignore
    const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
    // prettier-ignore
    const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
    const b2 = y * y * y % P; // x^3, 11
    const b3 = b2 * b2 * y % P; // x^7
    const b6 = (0, modular_js_1.pow2)(b3, _3n, P) * b3 % P;
    const b9 = (0, modular_js_1.pow2)(b6, _3n, P) * b3 % P;
    const b11 = (0, modular_js_1.pow2)(b9, _2n, P) * b2 % P;
    const b22 = (0, modular_js_1.pow2)(b11, _11n, P) * b11 % P;
    const b44 = (0, modular_js_1.pow2)(b22, _22n, P) * b22 % P;
    const b88 = (0, modular_js_1.pow2)(b44, _44n, P) * b44 % P;
    const b176 = (0, modular_js_1.pow2)(b88, _88n, P) * b88 % P;
    const b220 = (0, modular_js_1.pow2)(b176, _44n, P) * b44 % P;
    const b223 = (0, modular_js_1.pow2)(b220, _3n, P) * b3 % P;
    const t1 = (0, modular_js_1.pow2)(b223, _23n, P) * b22 % P;
    const t2 = (0, modular_js_1.pow2)(t1, _6n, P) * b2 % P;
    const root = (0, modular_js_1.pow2)(t2, _2n, P);
    if (!Fp.eql(Fp.sqr(root), y)) throw new Error("Cannot find square root");
    return root;
}
const Fp = (0, modular_js_1.Field)(secp256k1P, undefined, undefined, {
    sqrt: sqrtMod
});
/**
 * secp256k1 short weierstrass curve and ECDSA signatures over it.
 */ exports.secp256k1 = (0, _shortw_utils_js_1.createCurve)({
    a: BigInt(0),
    b: BigInt(7),
    Fp,
    n: secp256k1N,
    // Base point (x, y) aka generator point
    Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
    Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
    h: BigInt(1),
    lowS: true,
    /**
     * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
     * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
     * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
     * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
     */ endo: {
        beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
        splitScalar: (k)=>{
            const n = secp256k1N;
            const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
            const b1 = -_1n * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
            const a2 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
            const b2 = a1;
            const POW_2_128 = BigInt("0x100000000000000000000000000000000"); // (2n**128n).toString(16)
            const c1 = divNearest(b2 * k, n);
            const c2 = divNearest(-b1 * k, n);
            let k1 = (0, modular_js_1.mod)(k - c1 * a1 - c2 * a2, n);
            let k2 = (0, modular_js_1.mod)(-c1 * b1 - c2 * b2, n);
            const k1neg = k1 > POW_2_128;
            const k2neg = k2 > POW_2_128;
            if (k1neg) k1 = n - k1;
            if (k2neg) k2 = n - k2;
            if (k1 > POW_2_128 || k2 > POW_2_128) throw new Error("splitScalar: Endomorphism failed, k=" + k);
            return {
                k1neg,
                k1,
                k2neg,
                k2
            };
        }
    }
}, sha256_1.sha256);
// Schnorr signatures are superior to ECDSA from above. Below is Schnorr-specific BIP0340 code.
// https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki
const _0n = BigInt(0);
/** An object mapping tags to their tagged hash prefix of [SHA256(tag) | SHA256(tag)] */ const TAGGED_HASH_PREFIXES = {};
function taggedHash(tag, ...messages) {
    let tagP = TAGGED_HASH_PREFIXES[tag];
    if (tagP === undefined) {
        const tagH = (0, sha256_1.sha256)(Uint8Array.from(tag, (c)=>c.charCodeAt(0)));
        tagP = (0, utils_js_1.concatBytes)(tagH, tagH);
        TAGGED_HASH_PREFIXES[tag] = tagP;
    }
    return (0, sha256_1.sha256)((0, utils_js_1.concatBytes)(tagP, ...messages));
}
// ECDSA compact points are 33-byte. Schnorr is 32: we strip first byte 0x02 or 0x03
const pointToBytes = (point)=>point.toRawBytes(true).slice(1);
const numTo32b = (n)=>(0, utils_js_1.numberToBytesBE)(n, 32);
const modP = (x)=>(0, modular_js_1.mod)(x, secp256k1P);
const modN = (x)=>(0, modular_js_1.mod)(x, secp256k1N);
const Point = exports.secp256k1.ProjectivePoint;
const GmulAdd = (Q, a, b)=>Point.BASE.multiplyAndAddUnsafe(Q, a, b);
// Calculate point, scalar and bytes
function schnorrGetExtPubKey(priv) {
    let d_ = exports.secp256k1.utils.normPrivateKeyToScalar(priv); // same method executed in fromPrivateKey
    let p = Point.fromPrivateKey(d_); // P = d'G; 0 < d' < n check is done inside
    const scalar = p.hasEvenY() ? d_ : modN(-d_);
    return {
        scalar: scalar,
        bytes: pointToBytes(p)
    };
}
/**
 * lift_x from BIP340. Convert 32-byte x coordinate to elliptic curve point.
 * @returns valid point checked for being on-curve
 */ function lift_x(x) {
    (0, utils_js_1.aInRange)("x", x, _1n, secp256k1P); // Fail if x  p.
    const xx = modP(x * x);
    const c = modP(xx * x + BigInt(7)); // Let c = x + 7 mod p.
    let y = sqrtMod(c); // Let y = c^(p+1)/4 mod p.
    if (y % _2n !== _0n) y = modP(-y); // Return the unique point P such that x(P) = x and
    const p = new Point(x, y, _1n); // y(P) = y if y mod 2 = 0 or y(P) = p-y otherwise.
    p.assertValidity();
    return p;
}
const num = utils_js_1.bytesToNumberBE;
/**
 * Create tagged hash, convert it to bigint, reduce modulo-n.
 */ function challenge(...args) {
    return modN(num(taggedHash("BIP0340/challenge", ...args)));
}
/**
 * Schnorr public key is just `x` coordinate of Point as per BIP340.
 */ function schnorrGetPublicKey(privateKey) {
    return schnorrGetExtPubKey(privateKey).bytes; // d'=int(sk). Fail if d'=0 or d'n. Ret bytes(d'G)
}
/**
 * Creates Schnorr signature as per BIP340. Verifies itself before returning anything.
 * auxRand is optional and is not the sole source of k generation: bad CSPRNG won't be dangerous.
 */ function schnorrSign(message, privateKey, auxRand = (0, utils_1.randomBytes)(32)) {
    const m = (0, utils_js_1.ensureBytes)("message", message);
    const { bytes: px, scalar: d } = schnorrGetExtPubKey(privateKey); // checks for isWithinCurveOrder
    const a = (0, utils_js_1.ensureBytes)("auxRand", auxRand, 32); // Auxiliary random data a: a 32-byte array
    const t = numTo32b(d ^ num(taggedHash("BIP0340/aux", a))); // Let t be the byte-wise xor of bytes(d) and hash/aux(a)
    const rand = taggedHash("BIP0340/nonce", t, px, m); // Let rand = hash/nonce(t || bytes(P) || m)
    const k_ = modN(num(rand)); // Let k' = int(rand) mod n
    if (k_ === _0n) throw new Error("sign failed: k is zero"); // Fail if k' = 0.
    const { bytes: rx, scalar: k } = schnorrGetExtPubKey(k_); // Let R = k'G.
    const e = challenge(rx, px, m); // Let e = int(hash/challenge(bytes(R) || bytes(P) || m)) mod n.
    const sig = new Uint8Array(64); // Let sig = bytes(R) || bytes((k + ed) mod n).
    sig.set(rx, 0);
    sig.set(numTo32b(modN(k + e * d)), 32);
    // If Verify(bytes(P), m, sig) (see below) returns failure, abort
    if (!schnorrVerify(sig, m, px)) throw new Error("sign: Invalid signature produced");
    return sig;
}
/**
 * Verifies Schnorr signature.
 * Will swallow errors & return false except for initial type validation of arguments.
 */ function schnorrVerify(signature, message, publicKey) {
    const sig = (0, utils_js_1.ensureBytes)("signature", signature, 64);
    const m = (0, utils_js_1.ensureBytes)("message", message);
    const pub = (0, utils_js_1.ensureBytes)("publicKey", publicKey, 32);
    try {
        const P = lift_x(num(pub)); // P = lift_x(int(pk)); fail if that fails
        const r = num(sig.subarray(0, 32)); // Let r = int(sig[0:32]); fail if r  p.
        if (!(0, utils_js_1.inRange)(r, _1n, secp256k1P)) return false;
        const s = num(sig.subarray(32, 64)); // Let s = int(sig[32:64]); fail if s  n.
        if (!(0, utils_js_1.inRange)(s, _1n, secp256k1N)) return false;
        const e = challenge(numTo32b(r), pointToBytes(P), m); // int(challenge(bytes(r)||bytes(P)||m))%n
        const R = GmulAdd(P, s, modN(-e)); // R = sG - eP
        if (!R || !R.hasEvenY() || R.toAffine().x !== r) return false; // -eP == (n-e)P
        return true; // Fail if is_infinite(R) / not has_even_y(R) / x(R)  r.
    } catch (error) {
        return false;
    }
}
/**
 * Schnorr signatures over secp256k1.
 */ exports.schnorr = (()=>({
        getPublicKey: schnorrGetPublicKey,
        sign: schnorrSign,
        verify: schnorrVerify,
        utils: {
            randomPrivateKey: exports.secp256k1.utils.randomPrivateKey,
            lift_x,
            pointToBytes,
            numberToBytesBE: utils_js_1.numberToBytesBE,
            bytesToNumberBE: utils_js_1.bytesToNumberBE,
            taggedHash,
            mod: modular_js_1.mod
        }
    }))();
const isoMap = /* @__PURE__ */ (()=>(0, hash_to_curve_js_1.isogenyMap)(Fp, [
        // xNum
        [
            "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7",
            "0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581",
            "0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262",
            "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"
        ],
        // xDen
        [
            "0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b",
            "0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14",
            "0x0000000000000000000000000000000000000000000000000000000000000001"
        ],
        // yNum
        [
            "0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c",
            "0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3",
            "0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931",
            "0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"
        ],
        // yDen
        [
            "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b",
            "0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573",
            "0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f",
            "0x0000000000000000000000000000000000000000000000000000000000000001"
        ]
    ].map((i)=>i.map((j)=>BigInt(j)))))();
const mapSWU = /* @__PURE__ */ (()=>(0, weierstrass_js_1.mapToCurveSimpleSWU)(Fp, {
        A: BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),
        B: BigInt("1771"),
        Z: Fp.create(BigInt("-11"))
    }))();
const htf = /* @__PURE__ */ (()=>(0, hash_to_curve_js_1.createHasher)(exports.secp256k1.ProjectivePoint, (scalars)=>{
        const { x, y } = mapSWU(Fp.create(scalars[0]));
        return isoMap(x, y);
    }, {
        DST: "secp256k1_XMD:SHA-256_SSWU_RO_",
        encodeDST: "secp256k1_XMD:SHA-256_SSWU_NU_",
        p: Fp.ORDER,
        m: 1,
        k: 128,
        expand: "xmd",
        hash: sha256_1.sha256
    }))();
exports.hashToCurve = (()=>htf.hashToCurve)();
exports.encodeToCurve = (()=>htf.encodeToCurve)();

},{"a89c1505decc763e":"JjjO8","362802f5a451efcb":"2ehgp","8a5ef77428763709":"jmUYM","992867e7d1ef8b":"2yuJj","6a274edd04635854":"cB5Z5","49209a65a14a4a44":"cBmkf","4687d8e71912c9bd":"5TEzS"}],"jmUYM":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getHash = getHash;
exports.createCurve = createCurve;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const hmac_1 = require("2bb3ed73a71161e3");
const utils_1 = require("808050cc11f056c7");
const weierstrass_js_1 = require("bceff96a5b87336d");
// connects noble-curves to noble-hashes
function getHash(hash) {
    return {
        hash,
        hmac: (key, ...msgs)=>(0, hmac_1.hmac)(hash, key, (0, utils_1.concatBytes)(...msgs)),
        randomBytes: utils_1.randomBytes
    };
}
function createCurve(curveDef, defHash) {
    const create = (hash)=>(0, weierstrass_js_1.weierstrass)({
            ...curveDef,
            ...getHash(hash)
        });
    return Object.freeze({
        ...create(defHash),
        create
    });
}

},{"2bb3ed73a71161e3":"3IfCc","808050cc11f056c7":"2ehgp","bceff96a5b87336d":"5TEzS"}],"3IfCc":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.hmac = exports.HMAC = void 0;
const _assert_js_1 = require("88de570f0f701cc6");
const utils_js_1 = require("337359ae358d0fc");
// HMAC (RFC 2104)
class HMAC extends utils_js_1.Hash {
    constructor(hash, _key){
        super();
        this.finished = false;
        this.destroyed = false;
        (0, _assert_js_1.hash)(hash);
        const key = (0, utils_js_1.toBytes)(_key);
        this.iHash = hash.create();
        if (typeof this.iHash.update !== "function") throw new Error("Expected instance of class which extends utils.Hash");
        this.blockLen = this.iHash.blockLen;
        this.outputLen = this.iHash.outputLen;
        const blockLen = this.blockLen;
        const pad = new Uint8Array(blockLen);
        // blockLen can be bigger than outputLen
        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);
        for(let i = 0; i < pad.length; i++)pad[i] ^= 0x36;
        this.iHash.update(pad);
        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone
        this.oHash = hash.create();
        // Undo internal XOR && apply outer XOR
        for(let i = 0; i < pad.length; i++)pad[i] ^= 106;
        this.oHash.update(pad);
        pad.fill(0);
    }
    update(buf) {
        (0, _assert_js_1.exists)(this);
        this.iHash.update(buf);
        return this;
    }
    digestInto(out) {
        (0, _assert_js_1.exists)(this);
        (0, _assert_js_1.bytes)(out, this.outputLen);
        this.finished = true;
        this.iHash.digestInto(out);
        this.oHash.update(out);
        this.oHash.digestInto(out);
        this.destroy();
    }
    digest() {
        const out = new Uint8Array(this.oHash.outputLen);
        this.digestInto(out);
        return out;
    }
    _cloneInto(to) {
        // Create new instance without calling constructor since key already in state and we don't know it.
        to || (to = Object.create(Object.getPrototypeOf(this), {}));
        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
        to;
        to.finished = finished;
        to.destroyed = destroyed;
        to.blockLen = blockLen;
        to.outputLen = outputLen;
        to.oHash = oHash._cloneInto(to.oHash);
        to.iHash = iHash._cloneInto(to.iHash);
        return to;
    }
    destroy() {
        this.destroyed = true;
        this.oHash.destroy();
        this.iHash.destroy();
    }
}
exports.HMAC = HMAC;
/**
 * HMAC: RFC2104 message authentication code.
 * @param hash - function that would be used e.g. sha256
 * @param key - message key
 * @param message - message data
 * @example
 * import { hmac } from '@noble/hashes/hmac';
 * import { sha256 } from '@noble/hashes/sha2';
 * const mac1 = hmac(sha256, 'key', 'message');
 */ const hmac = (hash, key, message)=>new HMAC(hash, key).update(message).digest();
exports.hmac = hmac;
exports.hmac.create = (hash, key)=>new HMAC(hash, key);

},{"88de570f0f701cc6":"BFdql","337359ae358d0fc":"2ehgp"}],"5TEzS":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DER = void 0;
exports.weierstrassPoints = weierstrassPoints;
exports.weierstrass = weierstrass;
exports.SWUFpSqrtRatio = SWUFpSqrtRatio;
exports.mapToCurveSimpleSWU = mapToCurveSimpleSWU;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ // Short Weierstrass curve. The formula is: y = x + ax + b
const curve_js_1 = require("11f68d725b0f6f5d");
const mod = require("d8b1615c256fe3fa");
const ut = require("aae491f09795d5ee");
const utils_js_1 = require("aae491f09795d5ee");
function validateSigVerOpts(opts) {
    if (opts.lowS !== undefined) (0, utils_js_1.abool)("lowS", opts.lowS);
    if (opts.prehash !== undefined) (0, utils_js_1.abool)("prehash", opts.prehash);
}
function validatePointOpts(curve) {
    const opts = (0, curve_js_1.validateBasic)(curve);
    ut.validateObject(opts, {
        a: "field",
        b: "field"
    }, {
        allowedPrivateKeyLengths: "array",
        wrapPrivateKey: "boolean",
        isTorsionFree: "function",
        clearCofactor: "function",
        allowInfinityPoint: "boolean",
        fromBytes: "function",
        toBytes: "function"
    });
    const { endo, Fp, a } = opts;
    if (endo) {
        if (!Fp.eql(a, Fp.ZERO)) throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
        if (typeof endo !== "object" || typeof endo.beta !== "bigint" || typeof endo.splitScalar !== "function") throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
    }
    return Object.freeze({
        ...opts
    });
}
const { bytesToNumberBE: b2n, hexToBytes: h2b } = ut;
/**
 * ASN.1 DER encoding utilities. ASN is very complex & fragile. Format:
 *
 *     [0x30 (SEQUENCE), bytelength, 0x02 (INTEGER), intLength, R, 0x02 (INTEGER), intLength, S]
 *
 * Docs: https://letsencrypt.org/docs/a-warm-welcome-to-asn1-and-der/, https://luca.ntop.org/Teaching/Appunti/asn1.html
 */ exports.DER = {
    // asn.1 DER encoding utils
    Err: class DERErr extends Error {
        constructor(m = ""){
            super(m);
        }
    },
    // Basic building block is TLV (Tag-Length-Value)
    _tlv: {
        encode: (tag, data)=>{
            const { Err: E } = exports.DER;
            if (tag < 0 || tag > 256) throw new E("tlv.encode: wrong tag");
            if (data.length & 1) throw new E("tlv.encode: unpadded data");
            const dataLen = data.length / 2;
            const len = ut.numberToHexUnpadded(dataLen);
            if (len.length / 2 & 128) throw new E("tlv.encode: long form length too big");
            // length of length with long form flag
            const lenLen = dataLen > 127 ? ut.numberToHexUnpadded(len.length / 2 | 128) : "";
            return `${ut.numberToHexUnpadded(tag)}${lenLen}${len}${data}`;
        },
        // v - value, l - left bytes (unparsed)
        decode (tag, data) {
            const { Err: E } = exports.DER;
            let pos = 0;
            if (tag < 0 || tag > 256) throw new E("tlv.encode: wrong tag");
            if (data.length < 2 || data[pos++] !== tag) throw new E("tlv.decode: wrong tlv");
            const first = data[pos++];
            const isLong = !!(first & 128); // First bit of first length byte is flag for short/long form
            let length = 0;
            if (!isLong) length = first;
            else {
                // Long form: [longFlag(1bit), lengthLength(7bit), length (BE)]
                const lenLen = first & 127;
                if (!lenLen) throw new E("tlv.decode(long): indefinite length not supported");
                if (lenLen > 4) throw new E("tlv.decode(long): byte length is too big"); // this will overflow u32 in js
                const lengthBytes = data.subarray(pos, pos + lenLen);
                if (lengthBytes.length !== lenLen) throw new E("tlv.decode: length bytes not complete");
                if (lengthBytes[0] === 0) throw new E("tlv.decode(long): zero leftmost byte");
                for (const b of lengthBytes)length = length << 8 | b;
                pos += lenLen;
                if (length < 128) throw new E("tlv.decode(long): not minimal encoding");
            }
            const v = data.subarray(pos, pos + length);
            if (v.length !== length) throw new E("tlv.decode: wrong value length");
            return {
                v,
                l: data.subarray(pos + length)
            };
        }
    },
    // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,
    // since we always use positive integers here. It must always be empty:
    // - add zero byte if exists
    // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)
    _int: {
        encode (num) {
            const { Err: E } = exports.DER;
            if (num < _0n) throw new E("integer: negative integers are not allowed");
            let hex = ut.numberToHexUnpadded(num);
            // Pad with zero byte if negative flag is present
            if (Number.parseInt(hex[0], 16) & 8) hex = "00" + hex;
            if (hex.length & 1) throw new E("unexpected assertion");
            return hex;
        },
        decode (data) {
            const { Err: E } = exports.DER;
            if (data[0] & 128) throw new E("Invalid signature integer: negative");
            if (data[0] === 0x00 && !(data[1] & 128)) throw new E("Invalid signature integer: unnecessary leading zero");
            return b2n(data);
        }
    },
    toSig (hex) {
        // parse DER signature
        const { Err: E, _int: int, _tlv: tlv } = exports.DER;
        const data = typeof hex === "string" ? h2b(hex) : hex;
        ut.abytes(data);
        const { v: seqBytes, l: seqLeftBytes } = tlv.decode(0x30, data);
        if (seqLeftBytes.length) throw new E("Invalid signature: left bytes after parsing");
        const { v: rBytes, l: rLeftBytes } = tlv.decode(0x02, seqBytes);
        const { v: sBytes, l: sLeftBytes } = tlv.decode(0x02, rLeftBytes);
        if (sLeftBytes.length) throw new E("Invalid signature: left bytes after parsing");
        return {
            r: int.decode(rBytes),
            s: int.decode(sBytes)
        };
    },
    hexFromSig (sig) {
        const { _tlv: tlv, _int: int } = exports.DER;
        const seq = `${tlv.encode(0x02, int.encode(sig.r))}${tlv.encode(0x02, int.encode(sig.s))}`;
        return tlv.encode(0x30, seq);
    }
};
// Be friendly to bad ECMAScript parsers by not using bigint literals
// prettier-ignore
const _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);
function weierstrassPoints(opts) {
    const CURVE = validatePointOpts(opts);
    const { Fp } = CURVE; // All curves has same field / group length as for now, but they can differ
    const Fn = mod.Field(CURVE.n, CURVE.nBitLength);
    const toBytes = CURVE.toBytes || ((_c, point, _isCompressed)=>{
        const a = point.toAffine();
        return ut.concatBytes(Uint8Array.from([
            0x04
        ]), Fp.toBytes(a.x), Fp.toBytes(a.y));
    });
    const fromBytes = CURVE.fromBytes || ((bytes)=>{
        // const head = bytes[0];
        const tail = bytes.subarray(1);
        // if (head !== 0x04) throw new Error('Only non-compressed encoding is supported');
        const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));
        const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));
        return {
            x,
            y
        };
    });
    /**
     * y = x + ax + b: Short weierstrass curve formula
     * @returns y
     */ function weierstrassEquation(x) {
        const { a, b } = CURVE;
        const x2 = Fp.sqr(x); // x * x
        const x3 = Fp.mul(x2, x); // x2 * x
        return Fp.add(Fp.add(x3, Fp.mul(x, a)), b); // x3 + a * x + b
    }
    // Validate whether the passed curve params are valid.
    // We check if curve equation works for generator point.
    // `assertValidity()` won't work: `isTorsionFree()` is not available at this point in bls12-381.
    // ProjectivePoint class has not been initialized yet.
    if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx))) throw new Error("bad generator point: equation left != right");
    // Valid group elements reside in range 1..n-1
    function isWithinCurveOrder(num) {
        return ut.inRange(num, _1n, CURVE.n);
    }
    // Validates if priv key is valid and converts it to bigint.
    // Supports options allowedPrivateKeyLengths and wrapPrivateKey.
    function normPrivateKeyToScalar(key) {
        const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n: N } = CURVE;
        if (lengths && typeof key !== "bigint") {
            if (ut.isBytes(key)) key = ut.bytesToHex(key);
            // Normalize to hex string, pad. E.g. P521 would norm 130-132 char hex to 132-char bytes
            if (typeof key !== "string" || !lengths.includes(key.length)) throw new Error("Invalid key");
            key = key.padStart(nByteLength * 2, "0");
        }
        let num;
        try {
            num = typeof key === "bigint" ? key : ut.bytesToNumberBE((0, utils_js_1.ensureBytes)("private key", key, nByteLength));
        } catch (error) {
            throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);
        }
        if (wrapPrivateKey) num = mod.mod(num, N); // disabled by default, enabled for BLS
        ut.aInRange("private key", num, _1n, N); // num in range [1..N-1]
        return num;
    }
    function assertPrjPoint(other) {
        if (!(other instanceof Point)) throw new Error("ProjectivePoint expected");
    }
    // Memoized toAffine / validity check. They are heavy. Points are immutable.
    // Converts Projective point to affine (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    // (x, y, z)  (x=x/z, y=y/z)
    const toAffineMemo = (0, utils_js_1.memoized)((p, iz)=>{
        const { px: x, py: y, pz: z } = p;
        // Fast-path for normalized points
        if (Fp.eql(z, Fp.ONE)) return {
            x,
            y
        };
        const is0 = p.is0();
        // If invZ was 0, we return zero point. However we still want to execute
        // all operations, so we replace invZ with a random number, 1.
        if (iz == null) iz = is0 ? Fp.ONE : Fp.inv(z);
        const ax = Fp.mul(x, iz);
        const ay = Fp.mul(y, iz);
        const zz = Fp.mul(z, iz);
        if (is0) return {
            x: Fp.ZERO,
            y: Fp.ZERO
        };
        if (!Fp.eql(zz, Fp.ONE)) throw new Error("invZ was invalid");
        return {
            x: ax,
            y: ay
        };
    });
    // NOTE: on exception this will crash 'cached' and no value will be set.
    // Otherwise true will be return
    const assertValidMemo = (0, utils_js_1.memoized)((p)=>{
        if (p.is0()) {
            // (0, 1, 0) aka ZERO is invalid in most contexts.
            // In BLS, ZERO can be serialized, so we allow it.
            // (0, 0, 0) is wrong representation of ZERO and is always invalid.
            if (CURVE.allowInfinityPoint && !Fp.is0(p.py)) return;
            throw new Error("bad point: ZERO");
        }
        // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`
        const { x, y } = p.toAffine();
        // Check if x, y are valid field elements
        if (!Fp.isValid(x) || !Fp.isValid(y)) throw new Error("bad point: x or y not FE");
        const left = Fp.sqr(y); // y
        const right = weierstrassEquation(x); // x + ax + b
        if (!Fp.eql(left, right)) throw new Error("bad point: equation left != right");
        if (!p.isTorsionFree()) throw new Error("bad point: not in prime-order subgroup");
        return true;
    });
    /**
     * Projective Point works in 3d / projective (homogeneous) coordinates: (x, y, z)  (x=x/z, y=y/z)
     * Default Point works in 2d / affine coordinates: (x, y)
     * We're doing calculations in projective, because its operations don't require costly inversion.
     */ class Point {
        constructor(px, py, pz){
            this.px = px;
            this.py = py;
            this.pz = pz;
            if (px == null || !Fp.isValid(px)) throw new Error("x required");
            if (py == null || !Fp.isValid(py)) throw new Error("y required");
            if (pz == null || !Fp.isValid(pz)) throw new Error("z required");
            Object.freeze(this);
        }
        // Does not validate if the point is on-curve.
        // Use fromHex instead, or call assertValidity() later.
        static fromAffine(p) {
            const { x, y } = p || {};
            if (!p || !Fp.isValid(x) || !Fp.isValid(y)) throw new Error("invalid affine point");
            if (p instanceof Point) throw new Error("projective point not allowed");
            const is0 = (i)=>Fp.eql(i, Fp.ZERO);
            // fromAffine(x:0, y:0) would produce (x:0, y:0, z:1), but we need (x:0, y:1, z:0)
            if (is0(x) && is0(y)) return Point.ZERO;
            return new Point(x, y, Fp.ONE);
        }
        get x() {
            return this.toAffine().x;
        }
        get y() {
            return this.toAffine().y;
        }
        /**
         * Takes a bunch of Projective Points but executes only one
         * inversion on all of them. Inversion is very slow operation,
         * so this improves performance massively.
         * Optimization: converts a list of projective points to a list of identical points with Z=1.
         */ static normalizeZ(points) {
            const toInv = Fp.invertBatch(points.map((p)=>p.pz));
            return points.map((p, i)=>p.toAffine(toInv[i])).map(Point.fromAffine);
        }
        /**
         * Converts hash string or Uint8Array to Point.
         * @param hex short/long ECDSA hex
         */ static fromHex(hex) {
            const P = Point.fromAffine(fromBytes((0, utils_js_1.ensureBytes)("pointHex", hex)));
            P.assertValidity();
            return P;
        }
        // Multiplies generator point by privateKey.
        static fromPrivateKey(privateKey) {
            return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));
        }
        // Multiscalar Multiplication
        static msm(points, scalars) {
            return (0, curve_js_1.pippenger)(Point, Fn, points, scalars);
        }
        // "Private method", don't use it directly
        _setWindowSize(windowSize) {
            wnaf.setWindowSize(this, windowSize);
        }
        // A point on curve is valid if it conforms to equation.
        assertValidity() {
            assertValidMemo(this);
        }
        hasEvenY() {
            const { y } = this.toAffine();
            if (Fp.isOdd) return !Fp.isOdd(y);
            throw new Error("Field doesn't support isOdd");
        }
        /**
         * Compare one point to another.
         */ equals(other) {
            assertPrjPoint(other);
            const { px: X1, py: Y1, pz: Z1 } = this;
            const { px: X2, py: Y2, pz: Z2 } = other;
            const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));
            const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));
            return U1 && U2;
        }
        /**
         * Flips point to one corresponding to (x, -y) in Affine coordinates.
         */ negate() {
            return new Point(this.px, Fp.neg(this.py), this.pz);
        }
        // Renes-Costello-Batina exception-free doubling formula.
        // There is 30% faster Jacobian formula, but it is not complete.
        // https://eprint.iacr.org/2015/1060, algorithm 3
        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
        double() {
            const { a, b } = CURVE;
            const b3 = Fp.mul(b, _3n);
            const { px: X1, py: Y1, pz: Z1 } = this;
            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore
            let t0 = Fp.mul(X1, X1); // step 1
            let t1 = Fp.mul(Y1, Y1);
            let t2 = Fp.mul(Z1, Z1);
            let t3 = Fp.mul(X1, Y1);
            t3 = Fp.add(t3, t3); // step 5
            Z3 = Fp.mul(X1, Z1);
            Z3 = Fp.add(Z3, Z3);
            X3 = Fp.mul(a, Z3);
            Y3 = Fp.mul(b3, t2);
            Y3 = Fp.add(X3, Y3); // step 10
            X3 = Fp.sub(t1, Y3);
            Y3 = Fp.add(t1, Y3);
            Y3 = Fp.mul(X3, Y3);
            X3 = Fp.mul(t3, X3);
            Z3 = Fp.mul(b3, Z3); // step 15
            t2 = Fp.mul(a, t2);
            t3 = Fp.sub(t0, t2);
            t3 = Fp.mul(a, t3);
            t3 = Fp.add(t3, Z3);
            Z3 = Fp.add(t0, t0); // step 20
            t0 = Fp.add(Z3, t0);
            t0 = Fp.add(t0, t2);
            t0 = Fp.mul(t0, t3);
            Y3 = Fp.add(Y3, t0);
            t2 = Fp.mul(Y1, Z1); // step 25
            t2 = Fp.add(t2, t2);
            t0 = Fp.mul(t2, t3);
            X3 = Fp.sub(X3, t0);
            Z3 = Fp.mul(t2, t1);
            Z3 = Fp.add(Z3, Z3); // step 30
            Z3 = Fp.add(Z3, Z3);
            return new Point(X3, Y3, Z3);
        }
        // Renes-Costello-Batina exception-free addition formula.
        // There is 30% faster Jacobian formula, but it is not complete.
        // https://eprint.iacr.org/2015/1060, algorithm 1
        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
        add(other) {
            assertPrjPoint(other);
            const { px: X1, py: Y1, pz: Z1 } = this;
            const { px: X2, py: Y2, pz: Z2 } = other;
            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore
            const a = CURVE.a;
            const b3 = Fp.mul(CURVE.b, _3n);
            let t0 = Fp.mul(X1, X2); // step 1
            let t1 = Fp.mul(Y1, Y2);
            let t2 = Fp.mul(Z1, Z2);
            let t3 = Fp.add(X1, Y1);
            let t4 = Fp.add(X2, Y2); // step 5
            t3 = Fp.mul(t3, t4);
            t4 = Fp.add(t0, t1);
            t3 = Fp.sub(t3, t4);
            t4 = Fp.add(X1, Z1);
            let t5 = Fp.add(X2, Z2); // step 10
            t4 = Fp.mul(t4, t5);
            t5 = Fp.add(t0, t2);
            t4 = Fp.sub(t4, t5);
            t5 = Fp.add(Y1, Z1);
            X3 = Fp.add(Y2, Z2); // step 15
            t5 = Fp.mul(t5, X3);
            X3 = Fp.add(t1, t2);
            t5 = Fp.sub(t5, X3);
            Z3 = Fp.mul(a, t4);
            X3 = Fp.mul(b3, t2); // step 20
            Z3 = Fp.add(X3, Z3);
            X3 = Fp.sub(t1, Z3);
            Z3 = Fp.add(t1, Z3);
            Y3 = Fp.mul(X3, Z3);
            t1 = Fp.add(t0, t0); // step 25
            t1 = Fp.add(t1, t0);
            t2 = Fp.mul(a, t2);
            t4 = Fp.mul(b3, t4);
            t1 = Fp.add(t1, t2);
            t2 = Fp.sub(t0, t2); // step 30
            t2 = Fp.mul(a, t2);
            t4 = Fp.add(t4, t2);
            t0 = Fp.mul(t1, t4);
            Y3 = Fp.add(Y3, t0);
            t0 = Fp.mul(t5, t4); // step 35
            X3 = Fp.mul(t3, X3);
            X3 = Fp.sub(X3, t0);
            t0 = Fp.mul(t3, t1);
            Z3 = Fp.mul(t5, Z3);
            Z3 = Fp.add(Z3, t0); // step 40
            return new Point(X3, Y3, Z3);
        }
        subtract(other) {
            return this.add(other.negate());
        }
        is0() {
            return this.equals(Point.ZERO);
        }
        wNAF(n) {
            return wnaf.wNAFCached(this, n, Point.normalizeZ);
        }
        /**
         * Non-constant-time multiplication. Uses double-and-add algorithm.
         * It's faster, but should only be used when you don't care about
         * an exposed private key e.g. sig verification, which works over *public* keys.
         */ multiplyUnsafe(sc) {
            ut.aInRange("scalar", sc, _0n, CURVE.n);
            const I = Point.ZERO;
            if (sc === _0n) return I;
            if (sc === _1n) return this;
            const { endo } = CURVE;
            if (!endo) return wnaf.unsafeLadder(this, sc);
            // Apply endomorphism
            let { k1neg, k1, k2neg, k2 } = endo.splitScalar(sc);
            let k1p = I;
            let k2p = I;
            let d = this;
            while(k1 > _0n || k2 > _0n){
                if (k1 & _1n) k1p = k1p.add(d);
                if (k2 & _1n) k2p = k2p.add(d);
                d = d.double();
                k1 >>= _1n;
                k2 >>= _1n;
            }
            if (k1neg) k1p = k1p.negate();
            if (k2neg) k2p = k2p.negate();
            k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
            return k1p.add(k2p);
        }
        /**
         * Constant time multiplication.
         * Uses wNAF method. Windowed method may be 10% faster,
         * but takes 2x longer to generate and consumes 2x memory.
         * Uses precomputes when available.
         * Uses endomorphism for Koblitz curves.
         * @param scalar by which the point would be multiplied
         * @returns New point
         */ multiply(scalar) {
            const { endo, n: N } = CURVE;
            ut.aInRange("scalar", scalar, _1n, N);
            let point, fake; // Fake point is used to const-time mult
            if (endo) {
                const { k1neg, k1, k2neg, k2 } = endo.splitScalar(scalar);
                let { p: k1p, f: f1p } = this.wNAF(k1);
                let { p: k2p, f: f2p } = this.wNAF(k2);
                k1p = wnaf.constTimeNegate(k1neg, k1p);
                k2p = wnaf.constTimeNegate(k2neg, k2p);
                k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
                point = k1p.add(k2p);
                fake = f1p.add(f2p);
            } else {
                const { p, f } = this.wNAF(scalar);
                point = p;
                fake = f;
            }
            // Normalize `z` for both points, but return only real one
            return Point.normalizeZ([
                point,
                fake
            ])[0];
        }
        /**
         * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
         * Not using Strauss-Shamir trick: precomputation tables are faster.
         * The trick could be useful if both P and Q are not G (not in our case).
         * @returns non-zero affine point
         */ multiplyAndAddUnsafe(Q, a, b) {
            const G = Point.BASE; // No Strauss-Shamir trick: we have 10% faster G precomputes
            const mul = (P, a // Select faster multiply() method
            )=>a === _0n || a === _1n || !P.equals(G) ? P.multiplyUnsafe(a) : P.multiply(a);
            const sum = mul(this, a).add(mul(Q, b));
            return sum.is0() ? undefined : sum;
        }
        // Converts Projective point to affine (x, y) coordinates.
        // Can accept precomputed Z^-1 - for example, from invertBatch.
        // (x, y, z)  (x=x/z, y=y/z)
        toAffine(iz) {
            return toAffineMemo(this, iz);
        }
        isTorsionFree() {
            const { h: cofactor, isTorsionFree } = CURVE;
            if (cofactor === _1n) return true; // No subgroups, always torsion-free
            if (isTorsionFree) return isTorsionFree(Point, this);
            throw new Error("isTorsionFree() has not been declared for the elliptic curve");
        }
        clearCofactor() {
            const { h: cofactor, clearCofactor } = CURVE;
            if (cofactor === _1n) return this; // Fast-path
            if (clearCofactor) return clearCofactor(Point, this);
            return this.multiplyUnsafe(CURVE.h);
        }
        toRawBytes(isCompressed = true) {
            (0, utils_js_1.abool)("isCompressed", isCompressed);
            this.assertValidity();
            return toBytes(Point, this, isCompressed);
        }
        toHex(isCompressed = true) {
            (0, utils_js_1.abool)("isCompressed", isCompressed);
            return ut.bytesToHex(this.toRawBytes(isCompressed));
        }
    }
    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);
    Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);
    const _bits = CURVE.nBitLength;
    const wnaf = (0, curve_js_1.wNAF)(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);
    // Validate if generator point is on curve
    return {
        CURVE,
        ProjectivePoint: Point,
        normPrivateKeyToScalar,
        weierstrassEquation,
        isWithinCurveOrder
    };
}
function validateOpts(curve) {
    const opts = (0, curve_js_1.validateBasic)(curve);
    ut.validateObject(opts, {
        hash: "hash",
        hmac: "function",
        randomBytes: "function"
    }, {
        bits2int: "function",
        bits2int_modN: "function",
        lowS: "boolean"
    });
    return Object.freeze({
        lowS: true,
        ...opts
    });
}
/**
 * Creates short weierstrass curve and ECDSA signature methods for it.
 * @example
 * import { Field } from '@noble/curves/abstract/modular';
 * // Before that, define BigInt-s: a, b, p, n, Gx, Gy
 * const curve = weierstrass({ a, b, Fp: Field(p), n, Gx, Gy, h: 1n })
 */ function weierstrass(curveDef) {
    const CURVE = validateOpts(curveDef);
    const { Fp, n: CURVE_ORDER } = CURVE;
    const compressedLen = Fp.BYTES + 1; // e.g. 33 for 32
    const uncompressedLen = 2 * Fp.BYTES + 1; // e.g. 65 for 32
    function modN(a) {
        return mod.mod(a, CURVE_ORDER);
    }
    function invN(a) {
        return mod.invert(a, CURVE_ORDER);
    }
    const { ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder } = weierstrassPoints({
        ...CURVE,
        toBytes (_c, point, isCompressed) {
            const a = point.toAffine();
            const x = Fp.toBytes(a.x);
            const cat = ut.concatBytes;
            (0, utils_js_1.abool)("isCompressed", isCompressed);
            if (isCompressed) return cat(Uint8Array.from([
                point.hasEvenY() ? 0x02 : 0x03
            ]), x);
            else return cat(Uint8Array.from([
                0x04
            ]), x, Fp.toBytes(a.y));
        },
        fromBytes (bytes) {
            const len = bytes.length;
            const head = bytes[0];
            const tail = bytes.subarray(1);
            // this.assertValidity() is done inside of fromHex
            if (len === compressedLen && (head === 0x02 || head === 0x03)) {
                const x = ut.bytesToNumberBE(tail);
                if (!ut.inRange(x, _1n, Fp.ORDER)) throw new Error("Point is not on curve");
                const y2 = weierstrassEquation(x); // y = x + ax + b
                let y;
                try {
                    y = Fp.sqrt(y2); // y = y ^ (p+1)/4
                } catch (sqrtError) {
                    const suffix = sqrtError instanceof Error ? ": " + sqrtError.message : "";
                    throw new Error("Point is not on curve" + suffix);
                }
                const isYOdd = (y & _1n) === _1n;
                // ECDSA
                const isHeadOdd = (head & 1) === 1;
                if (isHeadOdd !== isYOdd) y = Fp.neg(y);
                return {
                    x,
                    y
                };
            } else if (len === uncompressedLen && head === 0x04) {
                const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));
                const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));
                return {
                    x,
                    y
                };
            } else throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);
        }
    });
    const numToNByteStr = (num)=>ut.bytesToHex(ut.numberToBytesBE(num, CURVE.nByteLength));
    function isBiggerThanHalfOrder(number) {
        const HALF = CURVE_ORDER >> _1n;
        return number > HALF;
    }
    function normalizeS(s) {
        return isBiggerThanHalfOrder(s) ? modN(-s) : s;
    }
    // slice bytes num
    const slcNum = (b, from, to)=>ut.bytesToNumberBE(b.slice(from, to));
    /**
     * ECDSA signature with its (r, s) properties. Supports DER & compact representations.
     */ class Signature {
        constructor(r, s, recovery){
            this.r = r;
            this.s = s;
            this.recovery = recovery;
            this.assertValidity();
        }
        // pair (bytes of r, bytes of s)
        static fromCompact(hex) {
            const l = CURVE.nByteLength;
            hex = (0, utils_js_1.ensureBytes)("compactSignature", hex, l * 2);
            return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));
        }
        // DER encoded ECDSA signature
        // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
        static fromDER(hex) {
            const { r, s } = exports.DER.toSig((0, utils_js_1.ensureBytes)("DER", hex));
            return new Signature(r, s);
        }
        assertValidity() {
            ut.aInRange("r", this.r, _1n, CURVE_ORDER); // r in [1..N]
            ut.aInRange("s", this.s, _1n, CURVE_ORDER); // s in [1..N]
        }
        addRecoveryBit(recovery) {
            return new Signature(this.r, this.s, recovery);
        }
        recoverPublicKey(msgHash) {
            const { r, s, recovery: rec } = this;
            const h = bits2int_modN((0, utils_js_1.ensureBytes)("msgHash", msgHash)); // Truncate hash
            if (rec == null || ![
                0,
                1,
                2,
                3
            ].includes(rec)) throw new Error("recovery id invalid");
            const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;
            if (radj >= Fp.ORDER) throw new Error("recovery id 2 or 3 invalid");
            const prefix = (rec & 1) === 0 ? "02" : "03";
            const R = Point.fromHex(prefix + numToNByteStr(radj));
            const ir = invN(radj); // r^-1
            const u1 = modN(-h * ir); // -hr^-1
            const u2 = modN(s * ir); // sr^-1
            const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2); // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1)
            if (!Q) throw new Error("point at infinify"); // unsafe is fine: no priv data leaked
            Q.assertValidity();
            return Q;
        }
        // Signatures should be low-s, to prevent malleability.
        hasHighS() {
            return isBiggerThanHalfOrder(this.s);
        }
        normalizeS() {
            return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;
        }
        // DER-encoded
        toDERRawBytes() {
            return ut.hexToBytes(this.toDERHex());
        }
        toDERHex() {
            return exports.DER.hexFromSig({
                r: this.r,
                s: this.s
            });
        }
        // padded bytes of r, then padded bytes of s
        toCompactRawBytes() {
            return ut.hexToBytes(this.toCompactHex());
        }
        toCompactHex() {
            return numToNByteStr(this.r) + numToNByteStr(this.s);
        }
    }
    const utils = {
        isValidPrivateKey (privateKey) {
            try {
                normPrivateKeyToScalar(privateKey);
                return true;
            } catch (error) {
                return false;
            }
        },
        normPrivateKeyToScalar: normPrivateKeyToScalar,
        /**
         * Produces cryptographically secure private key from random of size
         * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
         */ randomPrivateKey: ()=>{
            const length = mod.getMinHashLength(CURVE.n);
            return mod.mapHashToField(CURVE.randomBytes(length), CURVE.n);
        },
        /**
         * Creates precompute table for an arbitrary EC point. Makes point "cached".
         * Allows to massively speed-up `point.multiply(scalar)`.
         * @returns cached point
         * @example
         * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
         * fast.multiply(privKey); // much faster ECDH now
         */ precompute (windowSize = 8, point = Point.BASE) {
            point._setWindowSize(windowSize);
            point.multiply(BigInt(3)); // 3 is arbitrary, just need any number here
            return point;
        }
    };
    /**
     * Computes public key for a private key. Checks for validity of the private key.
     * @param privateKey private key
     * @param isCompressed whether to return compact (default), or full key
     * @returns Public key, full when isCompressed=false; short when isCompressed=true
     */ function getPublicKey(privateKey, isCompressed = true) {
        return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);
    }
    /**
     * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.
     */ function isProbPub(item) {
        const arr = ut.isBytes(item);
        const str = typeof item === "string";
        const len = (arr || str) && item.length;
        if (arr) return len === compressedLen || len === uncompressedLen;
        if (str) return len === 2 * compressedLen || len === 2 * uncompressedLen;
        if (item instanceof Point) return true;
        return false;
    }
    /**
     * ECDH (Elliptic Curve Diffie Hellman).
     * Computes shared public key from private key and public key.
     * Checks: 1) private key validity 2) shared key is on-curve.
     * Does NOT hash the result.
     * @param privateA private key
     * @param publicB different public key
     * @param isCompressed whether to return compact (default), or full key
     * @returns shared public key
     */ function getSharedSecret(privateA, publicB, isCompressed = true) {
        if (isProbPub(privateA)) throw new Error("first arg must be private key");
        if (!isProbPub(publicB)) throw new Error("second arg must be public key");
        const b = Point.fromHex(publicB); // check for being on-curve
        return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);
    }
    // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.
    // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.
    // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.
    // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors
    const bits2int = CURVE.bits2int || function(bytes) {
        // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)
        // for some cases, since bytes.length * 8 is not actual bitLength.
        const num = ut.bytesToNumberBE(bytes); // check for == u8 done here
        const delta = bytes.length * 8 - CURVE.nBitLength; // truncate to nBitLength leftmost bits
        return delta > 0 ? num >> BigInt(delta) : num;
    };
    const bits2int_modN = CURVE.bits2int_modN || function(bytes) {
        return modN(bits2int(bytes)); // can't use bytesToNumberBE here
    };
    // NOTE: pads output with zero as per spec
    const ORDER_MASK = ut.bitMask(CURVE.nBitLength);
    /**
     * Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`.
     */ function int2octets(num) {
        ut.aInRange(`num < 2^${CURVE.nBitLength}`, num, _0n, ORDER_MASK);
        // works with order, can have different size than numToField!
        return ut.numberToBytesBE(num, CURVE.nByteLength);
    }
    // Steps A, D of RFC6979 3.2
    // Creates RFC6979 seed; converts msg/privKey to numbers.
    // Used only in sign, not in verify.
    // NOTE: we cannot assume here that msgHash has same amount of bytes as curve order, this will be wrong at least for P521.
    // Also it can be bigger for P224 + SHA256
    function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
        if ([
            "recovered",
            "canonical"
        ].some((k)=>k in opts)) throw new Error("sign() legacy options not supported");
        const { hash, randomBytes } = CURVE;
        let { lowS, prehash, extraEntropy: ent } = opts; // generates low-s sigs by default
        if (lowS == null) lowS = true; // RFC6979 3.2: we skip step A, because we already provide hash
        msgHash = (0, utils_js_1.ensureBytes)("msgHash", msgHash);
        validateSigVerOpts(opts);
        if (prehash) msgHash = (0, utils_js_1.ensureBytes)("prehashed msgHash", hash(msgHash));
        // We can't later call bits2octets, since nested bits2int is broken for curves
        // with nBitLength % 8 !== 0. Because of that, we unwrap it here as int2octets call.
        // const bits2octets = (bits) => int2octets(bits2int_modN(bits))
        const h1int = bits2int_modN(msgHash);
        const d = normPrivateKeyToScalar(privateKey); // validate private key, convert to bigint
        const seedArgs = [
            int2octets(d),
            int2octets(h1int)
        ];
        // extraEntropy. RFC6979 3.6: additional k' (optional).
        if (ent != null && ent !== false) {
            // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')
            const e = ent === true ? randomBytes(Fp.BYTES) : ent; // generate random bytes OR pass as-is
            seedArgs.push((0, utils_js_1.ensureBytes)("extraEntropy", e)); // check for being bytes
        }
        const seed = ut.concatBytes(...seedArgs); // Step D of RFC6979 3.2
        const m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!
        // Converts signature params into point w r/s, checks result for validity.
        function k2sig(kBytes) {
            // RFC 6979 Section 3.2, step 3: k = bits2int(T)
            const k = bits2int(kBytes); // Cannot use fields methods, since it is group element
            if (!isWithinCurveOrder(k)) return; // Important: all mod() calls here must be done over N
            const ik = invN(k); // k^-1 mod n
            const q = Point.BASE.multiply(k).toAffine(); // q = Gk
            const r = modN(q.x); // r = q.x mod n
            if (r === _0n) return;
            // Can use scalar blinding b^-1(bm + bdr) where b  [1,q1] according to
            // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:
            // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT
            const s = modN(ik * modN(m + r * d)); // Not using blinding here
            if (s === _0n) return;
            let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n); // recovery bit (2 or 3, when q.x > n)
            let normS = s;
            if (lowS && isBiggerThanHalfOrder(s)) {
                normS = normalizeS(s); // if lowS was passed, ensure s is always
                recovery ^= 1; // // in the bottom half of N
            }
            return new Signature(r, normS, recovery); // use normS, not s
        }
        return {
            seed,
            k2sig
        };
    }
    const defaultSigOpts = {
        lowS: CURVE.lowS,
        prehash: false
    };
    const defaultVerOpts = {
        lowS: CURVE.lowS,
        prehash: false
    };
    /**
     * Signs message hash with a private key.
     * ```
     * sign(m, d, k) where
     *   (x, y) = G  k
     *   r = x mod n
     *   s = (m + dr)/k mod n
     * ```
     * @param msgHash NOT message. msg needs to be hashed to `msgHash`, or use `prehash`.
     * @param privKey private key
     * @param opts lowS for non-malleable sigs. extraEntropy for mixing randomness into k. prehash will hash first arg.
     * @returns signature with recovery param
     */ function sign(msgHash, privKey, opts = defaultSigOpts) {
        const { seed, k2sig } = prepSig(msgHash, privKey, opts); // Steps A, D of RFC6979 3.2.
        const C = CURVE;
        const drbg = ut.createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);
        return drbg(seed, k2sig); // Steps B, C, D, E, F, G
    }
    // Enable precomputes. Slows down first publicKey computation by 20ms.
    Point.BASE._setWindowSize(8);
    // utils.precompute(8, ProjectivePoint.BASE)
    /**
     * Verifies a signature against message hash and public key.
     * Rejects lowS signatures by default: to override,
     * specify option `{lowS: false}`. Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:
     *
     * ```
     * verify(r, s, h, P) where
     *   U1 = hs^-1 mod n
     *   U2 = rs^-1 mod n
     *   R = U1G - U2P
     *   mod(R.x, n) == r
     * ```
     */ function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {
        const sg = signature;
        msgHash = (0, utils_js_1.ensureBytes)("msgHash", msgHash);
        publicKey = (0, utils_js_1.ensureBytes)("publicKey", publicKey);
        if ("strict" in opts) throw new Error("options.strict was renamed to lowS");
        validateSigVerOpts(opts);
        const { lowS, prehash } = opts;
        let _sig = undefined;
        let P;
        try {
            if (typeof sg === "string" || ut.isBytes(sg)) // Signature can be represented in 2 ways: compact (2*nByteLength) & DER (variable-length).
            // Since DER can also be 2*nByteLength bytes, we check for it first.
            try {
                _sig = Signature.fromDER(sg);
            } catch (derError) {
                if (!(derError instanceof exports.DER.Err)) throw derError;
                _sig = Signature.fromCompact(sg);
            }
            else if (typeof sg === "object" && typeof sg.r === "bigint" && typeof sg.s === "bigint") {
                const { r, s } = sg;
                _sig = new Signature(r, s);
            } else throw new Error("PARSE");
            P = Point.fromHex(publicKey);
        } catch (error) {
            if (error.message === "PARSE") throw new Error(`signature must be Signature instance, Uint8Array or hex string`);
            return false;
        }
        if (lowS && _sig.hasHighS()) return false;
        if (prehash) msgHash = CURVE.hash(msgHash);
        const { r, s } = _sig;
        const h = bits2int_modN(msgHash); // Cannot use fields methods, since it is group element
        const is = invN(s); // s^-1
        const u1 = modN(h * is); // u1 = hs^-1 mod n
        const u2 = modN(r * is); // u2 = rs^-1 mod n
        const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine(); // R = u1G + u2P
        if (!R) return false;
        const v = modN(R.x);
        return v === r;
    }
    return {
        CURVE,
        getPublicKey,
        getSharedSecret,
        sign,
        verify,
        ProjectivePoint: Point,
        Signature,
        utils
    };
}
/**
 * Implementation of the Shallue and van de Woestijne method for any weierstrass curve.
 * TODO: check if there is a way to merge this with uvRatio in Edwards; move to modular.
 * b = True and y = sqrt(u / v) if (u / v) is square in F, and
 * b = False and y = sqrt(Z * (u / v)) otherwise.
 * @param Fp
 * @param Z
 * @returns
 */ function SWUFpSqrtRatio(Fp, Z) {
    // Generic implementation
    const q = Fp.ORDER;
    let l = _0n;
    for(let o = q - _1n; o % _2n === _0n; o /= _2n)l += _1n;
    const c1 = l; // 1. c1, the largest integer such that 2^c1 divides q - 1.
    // We need 2n ** c1 and 2n ** (c1-1). We can't use **; but we can use <<.
    // 2n ** c1 == 2n << (c1-1)
    const _2n_pow_c1_1 = _2n << c1 - _1n - _1n;
    const _2n_pow_c1 = _2n_pow_c1_1 * _2n;
    const c2 = (q - _1n) / _2n_pow_c1; // 2. c2 = (q - 1) / (2^c1)  # Integer arithmetic
    const c3 = (c2 - _1n) / _2n; // 3. c3 = (c2 - 1) / 2            # Integer arithmetic
    const c4 = _2n_pow_c1 - _1n; // 4. c4 = 2^c1 - 1                # Integer arithmetic
    const c5 = _2n_pow_c1_1; // 5. c5 = 2^(c1 - 1)                  # Integer arithmetic
    const c6 = Fp.pow(Z, c2); // 6. c6 = Z^c2
    const c7 = Fp.pow(Z, (c2 + _1n) / _2n); // 7. c7 = Z^((c2 + 1) / 2)
    let sqrtRatio = (u, v)=>{
        let tv1 = c6; // 1. tv1 = c6
        let tv2 = Fp.pow(v, c4); // 2. tv2 = v^c4
        let tv3 = Fp.sqr(tv2); // 3. tv3 = tv2^2
        tv3 = Fp.mul(tv3, v); // 4. tv3 = tv3 * v
        let tv5 = Fp.mul(u, tv3); // 5. tv5 = u * tv3
        tv5 = Fp.pow(tv5, c3); // 6. tv5 = tv5^c3
        tv5 = Fp.mul(tv5, tv2); // 7. tv5 = tv5 * tv2
        tv2 = Fp.mul(tv5, v); // 8. tv2 = tv5 * v
        tv3 = Fp.mul(tv5, u); // 9. tv3 = tv5 * u
        let tv4 = Fp.mul(tv3, tv2); // 10. tv4 = tv3 * tv2
        tv5 = Fp.pow(tv4, c5); // 11. tv5 = tv4^c5
        let isQR = Fp.eql(tv5, Fp.ONE); // 12. isQR = tv5 == 1
        tv2 = Fp.mul(tv3, c7); // 13. tv2 = tv3 * c7
        tv5 = Fp.mul(tv4, tv1); // 14. tv5 = tv4 * tv1
        tv3 = Fp.cmov(tv2, tv3, isQR); // 15. tv3 = CMOV(tv2, tv3, isQR)
        tv4 = Fp.cmov(tv5, tv4, isQR); // 16. tv4 = CMOV(tv5, tv4, isQR)
        // 17. for i in (c1, c1 - 1, ..., 2):
        for(let i = c1; i > _1n; i--){
            let tv5 = i - _2n; // 18.    tv5 = i - 2
            tv5 = _2n << tv5 - _1n; // 19.    tv5 = 2^tv5
            let tvv5 = Fp.pow(tv4, tv5); // 20.    tv5 = tv4^tv5
            const e1 = Fp.eql(tvv5, Fp.ONE); // 21.    e1 = tv5 == 1
            tv2 = Fp.mul(tv3, tv1); // 22.    tv2 = tv3 * tv1
            tv1 = Fp.mul(tv1, tv1); // 23.    tv1 = tv1 * tv1
            tvv5 = Fp.mul(tv4, tv1); // 24.    tv5 = tv4 * tv1
            tv3 = Fp.cmov(tv2, tv3, e1); // 25.    tv3 = CMOV(tv2, tv3, e1)
            tv4 = Fp.cmov(tvv5, tv4, e1); // 26.    tv4 = CMOV(tv5, tv4, e1)
        }
        return {
            isValid: isQR,
            value: tv3
        };
    };
    if (Fp.ORDER % _4n === _3n) {
        // sqrt_ratio_3mod4(u, v)
        const c1 = (Fp.ORDER - _3n) / _4n; // 1. c1 = (q - 3) / 4     # Integer arithmetic
        const c2 = Fp.sqrt(Fp.neg(Z)); // 2. c2 = sqrt(-Z)
        sqrtRatio = (u, v)=>{
            let tv1 = Fp.sqr(v); // 1. tv1 = v^2
            const tv2 = Fp.mul(u, v); // 2. tv2 = u * v
            tv1 = Fp.mul(tv1, tv2); // 3. tv1 = tv1 * tv2
            let y1 = Fp.pow(tv1, c1); // 4. y1 = tv1^c1
            y1 = Fp.mul(y1, tv2); // 5. y1 = y1 * tv2
            const y2 = Fp.mul(y1, c2); // 6. y2 = y1 * c2
            const tv3 = Fp.mul(Fp.sqr(y1), v); // 7. tv3 = y1^2; 8. tv3 = tv3 * v
            const isQR = Fp.eql(tv3, u); // 9. isQR = tv3 == u
            let y = Fp.cmov(y2, y1, isQR); // 10. y = CMOV(y2, y1, isQR)
            return {
                isValid: isQR,
                value: y
            }; // 11. return (isQR, y) isQR ? y : y*c2
        };
    }
    // No curves uses that
    // if (Fp.ORDER % _8n === _5n) // sqrt_ratio_5mod8
    return sqrtRatio;
}
/**
 * Simplified Shallue-van de Woestijne-Ulas Method
 * https://www.rfc-editor.org/rfc/rfc9380#section-6.6.2
 */ function mapToCurveSimpleSWU(Fp, opts) {
    mod.validateField(Fp);
    if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z)) throw new Error("mapToCurveSimpleSWU: invalid opts");
    const sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);
    if (!Fp.isOdd) throw new Error("Fp.isOdd is not implemented!");
    // Input: u, an element of F.
    // Output: (x, y), a point on E.
    return (u)=>{
        // prettier-ignore
        let tv1, tv2, tv3, tv4, tv5, tv6, x, y;
        tv1 = Fp.sqr(u); // 1.  tv1 = u^2
        tv1 = Fp.mul(tv1, opts.Z); // 2.  tv1 = Z * tv1
        tv2 = Fp.sqr(tv1); // 3.  tv2 = tv1^2
        tv2 = Fp.add(tv2, tv1); // 4.  tv2 = tv2 + tv1
        tv3 = Fp.add(tv2, Fp.ONE); // 5.  tv3 = tv2 + 1
        tv3 = Fp.mul(tv3, opts.B); // 6.  tv3 = B * tv3
        tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)); // 7.  tv4 = CMOV(Z, -tv2, tv2 != 0)
        tv4 = Fp.mul(tv4, opts.A); // 8.  tv4 = A * tv4
        tv2 = Fp.sqr(tv3); // 9.  tv2 = tv3^2
        tv6 = Fp.sqr(tv4); // 10. tv6 = tv4^2
        tv5 = Fp.mul(tv6, opts.A); // 11. tv5 = A * tv6
        tv2 = Fp.add(tv2, tv5); // 12. tv2 = tv2 + tv5
        tv2 = Fp.mul(tv2, tv3); // 13. tv2 = tv2 * tv3
        tv6 = Fp.mul(tv6, tv4); // 14. tv6 = tv6 * tv4
        tv5 = Fp.mul(tv6, opts.B); // 15. tv5 = B * tv6
        tv2 = Fp.add(tv2, tv5); // 16. tv2 = tv2 + tv5
        x = Fp.mul(tv1, tv3); // 17.   x = tv1 * tv3
        const { isValid, value } = sqrtRatio(tv2, tv6); // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)
        y = Fp.mul(tv1, u); // 19.   y = tv1 * u  -> Z * u^3 * y1
        y = Fp.mul(y, value); // 20.   y = y * y1
        x = Fp.cmov(x, tv3, isValid); // 21.   x = CMOV(x, tv3, is_gx1_square)
        y = Fp.cmov(y, value, isValid); // 22.   y = CMOV(y, y1, is_gx1_square)
        const e1 = Fp.isOdd(u) === Fp.isOdd(y); // 23.  e1 = sgn0(u) == sgn0(y)
        y = Fp.cmov(Fp.neg(y), y, e1); // 24.   y = CMOV(-y, y, e1)
        x = Fp.div(x, tv4); // 25.   x = x / tv4
        return {
            x,
            y
        };
    };
}

},{"11f68d725b0f6f5d":"etkeY","d8b1615c256fe3fa":"cB5Z5","aae491f09795d5ee":"cBmkf"}],"57qkX":[function(require,module,exports) {
(function(globalObject) {
    "use strict";
    /*
 *      bignumber.js v9.1.2
 *      A JavaScript library for arbitrary-precision arithmetic.
 *      https://github.com/MikeMcl/bignumber.js
 *      Copyright (c) 2022 Michael Mclaughlin <M8ch88l@gmail.com>
 *      MIT Licensed.
 *
 *      BigNumber.prototype methods     |  BigNumber methods
 *                                      |
 *      absoluteValue            abs    |  clone
 *      comparedTo                      |  config               set
 *      decimalPlaces            dp     |      DECIMAL_PLACES
 *      dividedBy                div    |      ROUNDING_MODE
 *      dividedToIntegerBy       idiv   |      EXPONENTIAL_AT
 *      exponentiatedBy          pow    |      RANGE
 *      integerValue                    |      CRYPTO
 *      isEqualTo                eq     |      MODULO_MODE
 *      isFinite                        |      POW_PRECISION
 *      isGreaterThan            gt     |      FORMAT
 *      isGreaterThanOrEqualTo   gte    |      ALPHABET
 *      isInteger                       |  isBigNumber
 *      isLessThan               lt     |  maximum              max
 *      isLessThanOrEqualTo      lte    |  minimum              min
 *      isNaN                           |  random
 *      isNegative                      |  sum
 *      isPositive                      |
 *      isZero                          |
 *      minus                           |
 *      modulo                   mod    |
 *      multipliedBy             times  |
 *      negated                         |
 *      plus                            |
 *      precision                sd     |
 *      shiftedBy                       |
 *      squareRoot               sqrt   |
 *      toExponential                   |
 *      toFixed                         |
 *      toFormat                        |
 *      toFraction                      |
 *      toJSON                          |
 *      toNumber                        |
 *      toPrecision                     |
 *      toString                        |
 *      valueOf                         |
 *
 */ var BigNumber, isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, mathceil = Math.ceil, mathfloor = Math.floor, bignumberError = "[BigNumber Error] ", tooManyDigits = bignumberError + "Number primitive has more than 15 significant digits: ", BASE = 1e14, LOG_BASE = 14, MAX_SAFE_INTEGER = 0x1fffffffffffff, // MAX_INT32 = 0x7fffffff,                   // 2^31 - 1
    POWS_TEN = [
        1,
        10,
        100,
        1e3,
        1e4,
        1e5,
        1e6,
        1e7,
        1e8,
        1e9,
        1e10,
        1e11,
        1e12,
        1e13
    ], SQRT_BASE = 1e7, // EDITABLE
    // The limit on the value of DECIMAL_PLACES, TO_EXP_NEG, TO_EXP_POS, MIN_EXP, MAX_EXP, and
    // the arguments to toExponential, toFixed, toFormat, and toPrecision.
    MAX = 1E9; // 0 to MAX_INT32
    /*
   * Create and return a BigNumber constructor.
   */ function clone(configObject) {
        var div, convertBase, parseNumeric, P = BigNumber.prototype = {
            constructor: BigNumber,
            toString: null,
            valueOf: null
        }, ONE = new BigNumber(1), //----------------------------- EDITABLE CONFIG DEFAULTS -------------------------------
        // The default values below must be integers within the inclusive ranges stated.
        // The values can also be changed at run-time using BigNumber.set.
        // The maximum number of decimal places for operations involving division.
        DECIMAL_PLACES = 20, // The rounding mode used when rounding to the above decimal places, and when using
        // toExponential, toFixed, toFormat and toPrecision, and round (default value).
        // UP         0 Away from zero.
        // DOWN       1 Towards zero.
        // CEIL       2 Towards +Infinity.
        // FLOOR      3 Towards -Infinity.
        // HALF_UP    4 Towards nearest neighbour. If equidistant, up.
        // HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
        // HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
        // HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
        // HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
        ROUNDING_MODE = 4, // EXPONENTIAL_AT : [TO_EXP_NEG , TO_EXP_POS]
        // The exponent value at and beneath which toString returns exponential notation.
        // Number type: -7
        TO_EXP_NEG = -7, // The exponent value at and above which toString returns exponential notation.
        // Number type: 21
        TO_EXP_POS = 21, // RANGE : [MIN_EXP, MAX_EXP]
        // The minimum exponent value, beneath which underflow to zero occurs.
        // Number type: -324  (5e-324)
        MIN_EXP = -10000000, // The maximum exponent value, above which overflow to Infinity occurs.
        // Number type:  308  (1.7976931348623157e+308)
        // For MAX_EXP > 1e7, e.g. new BigNumber('1e100000000').plus(1) may be slow.
        MAX_EXP = 1e7, // Whether to use cryptographically-secure random number generation, if available.
        CRYPTO = false, // The modulo mode used when calculating the modulus: a mod n.
        // The quotient (q = a / n) is calculated according to the corresponding rounding mode.
        // The remainder (r) is calculated as: r = a - n * q.
        //
        // UP        0 The remainder is positive if the dividend is negative, else is negative.
        // DOWN      1 The remainder has the same sign as the dividend.
        //             This modulo mode is commonly known as 'truncated division' and is
        //             equivalent to (a % n) in JavaScript.
        // FLOOR     3 The remainder has the same sign as the divisor (Python %).
        // HALF_EVEN 6 This modulo mode implements the IEEE 754 remainder function.
        // EUCLID    9 Euclidian division. q = sign(n) * floor(a / abs(n)).
        //             The remainder is always positive.
        //
        // The truncated division, floored division, Euclidian division and IEEE 754 remainder
        // modes are commonly used for the modulus operation.
        // Although the other rounding modes can also be used, they may not give useful results.
        MODULO_MODE = 1, // The maximum number of significant digits of the result of the exponentiatedBy operation.
        // If POW_PRECISION is 0, there will be unlimited significant digits.
        POW_PRECISION = 0, // The format specification used by the BigNumber.prototype.toFormat method.
        FORMAT = {
            prefix: "",
            groupSize: 3,
            secondaryGroupSize: 0,
            groupSeparator: ",",
            decimalSeparator: ".",
            fractionGroupSize: 0,
            fractionGroupSeparator: "\xa0",
            suffix: ""
        }, // The alphabet used for base conversion. It must be at least 2 characters long, with no '+',
        // '-', '.', whitespace, or repeated character.
        // '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_'
        ALPHABET = "0123456789abcdefghijklmnopqrstuvwxyz", alphabetHasNormalDecimalDigits = true;
        //------------------------------------------------------------------------------------------
        // CONSTRUCTOR
        /*
     * The BigNumber constructor and exported function.
     * Create and return a new instance of a BigNumber object.
     *
     * v {number|string|BigNumber} A numeric value.
     * [b] {number} The base of v. Integer, 2 to ALPHABET.length inclusive.
     */ function BigNumber(v, b) {
            var alphabet, c, caseChanged, e, i, isNum, len, str, x = this;
            // Enable constructor call without `new`.
            if (!(x instanceof BigNumber)) return new BigNumber(v, b);
            if (b == null) {
                if (v && v._isBigNumber === true) {
                    x.s = v.s;
                    if (!v.c || v.e > MAX_EXP) x.c = x.e = null;
                    else if (v.e < MIN_EXP) x.c = [
                        x.e = 0
                    ];
                    else {
                        x.e = v.e;
                        x.c = v.c.slice();
                    }
                    return;
                }
                if ((isNum = typeof v == "number") && v * 0 == 0) {
                    // Use `1 / n` to handle minus zero also.
                    x.s = 1 / v < 0 ? (v = -v, -1) : 1;
                    // Fast path for integers, where n < 2147483648 (2**31).
                    if (v === ~~v) {
                        for(e = 0, i = v; i >= 10; i /= 10, e++);
                        if (e > MAX_EXP) x.c = x.e = null;
                        else {
                            x.e = e;
                            x.c = [
                                v
                            ];
                        }
                        return;
                    }
                    str = String(v);
                } else {
                    if (!isNumeric.test(str = String(v))) return parseNumeric(x, str, isNum);
                    x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
                }
                // Decimal point?
                if ((e = str.indexOf(".")) > -1) str = str.replace(".", "");
                // Exponential form?
                if ((i = str.search(/e/i)) > 0) {
                    // Determine exponent.
                    if (e < 0) e = i;
                    e += +str.slice(i + 1);
                    str = str.substring(0, i);
                } else if (e < 0) // Integer.
                e = str.length;
            } else {
                // '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'
                intCheck(b, 2, ALPHABET.length, "Base");
                // Allow exponential notation to be used with base 10 argument, while
                // also rounding to DECIMAL_PLACES as with other bases.
                if (b == 10 && alphabetHasNormalDecimalDigits) {
                    x = new BigNumber(v);
                    return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);
                }
                str = String(v);
                if (isNum = typeof v == "number") {
                    // Avoid potential interpretation of Infinity and NaN as base 44+ values.
                    if (v * 0 != 0) return parseNumeric(x, str, isNum, b);
                    x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;
                    // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'
                    if (BigNumber.DEBUG && str.replace(/^0\.0*|\./, "").length > 15) throw Error(tooManyDigits + v);
                } else x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
                alphabet = ALPHABET.slice(0, b);
                e = i = 0;
                // Check that str is a valid base b number.
                // Don't use RegExp, so alphabet can contain special characters.
                for(len = str.length; i < len; i++)if (alphabet.indexOf(c = str.charAt(i)) < 0) {
                    if (c == ".") // If '.' is not the first character and it has not be found before.
                    {
                        if (i > e) {
                            e = len;
                            continue;
                        }
                    } else if (!caseChanged) // Allow e.g. hexadecimal 'FF' as well as 'ff'.
                    {
                        if (str == str.toUpperCase() && (str = str.toLowerCase()) || str == str.toLowerCase() && (str = str.toUpperCase())) {
                            caseChanged = true;
                            i = -1;
                            e = 0;
                            continue;
                        }
                    }
                    return parseNumeric(x, String(v), isNum, b);
                }
                // Prevent later check for length on converted number.
                isNum = false;
                str = convertBase(str, b, 10, x.s);
                // Decimal point?
                if ((e = str.indexOf(".")) > -1) str = str.replace(".", "");
                else e = str.length;
            }
            // Determine leading zeros.
            for(i = 0; str.charCodeAt(i) === 48; i++);
            // Determine trailing zeros.
            for(len = str.length; str.charCodeAt(--len) === 48;);
            if (str = str.slice(i, ++len)) {
                len -= i;
                // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'
                if (isNum && BigNumber.DEBUG && len > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) throw Error(tooManyDigits + x.s * v);
                // Overflow?
                if ((e = e - i - 1) > MAX_EXP) // Infinity.
                x.c = x.e = null;
                else if (e < MIN_EXP) // Zero.
                x.c = [
                    x.e = 0
                ];
                else {
                    x.e = e;
                    x.c = [];
                    // Transform base
                    // e is the base 10 exponent.
                    // i is where to slice str to get the first element of the coefficient array.
                    i = (e + 1) % LOG_BASE;
                    if (e < 0) i += LOG_BASE; // i < 1
                    if (i < len) {
                        if (i) x.c.push(+str.slice(0, i));
                        for(len -= LOG_BASE; i < len;)x.c.push(+str.slice(i, i += LOG_BASE));
                        i = LOG_BASE - (str = str.slice(i)).length;
                    } else i -= len;
                    for(; i--; str += "0");
                    x.c.push(+str);
                }
            } else // Zero.
            x.c = [
                x.e = 0
            ];
        }
        // CONSTRUCTOR PROPERTIES
        BigNumber.clone = clone;
        BigNumber.ROUND_UP = 0;
        BigNumber.ROUND_DOWN = 1;
        BigNumber.ROUND_CEIL = 2;
        BigNumber.ROUND_FLOOR = 3;
        BigNumber.ROUND_HALF_UP = 4;
        BigNumber.ROUND_HALF_DOWN = 5;
        BigNumber.ROUND_HALF_EVEN = 6;
        BigNumber.ROUND_HALF_CEIL = 7;
        BigNumber.ROUND_HALF_FLOOR = 8;
        BigNumber.EUCLID = 9;
        /*
     * Configure infrequently-changing library-wide settings.
     *
     * Accept an object with the following optional properties (if the value of a property is
     * a number, it must be an integer within the inclusive range stated):
     *
     *   DECIMAL_PLACES   {number}           0 to MAX
     *   ROUNDING_MODE    {number}           0 to 8
     *   EXPONENTIAL_AT   {number|number[]}  -MAX to MAX  or  [-MAX to 0, 0 to MAX]
     *   RANGE            {number|number[]}  -MAX to MAX (not zero)  or  [-MAX to -1, 1 to MAX]
     *   CRYPTO           {boolean}          true or false
     *   MODULO_MODE      {number}           0 to 9
     *   POW_PRECISION       {number}           0 to MAX
     *   ALPHABET         {string}           A string of two or more unique characters which does
     *                                       not contain '.'.
     *   FORMAT           {object}           An object with some of the following properties:
     *     prefix                 {string}
     *     groupSize              {number}
     *     secondaryGroupSize     {number}
     *     groupSeparator         {string}
     *     decimalSeparator       {string}
     *     fractionGroupSize      {number}
     *     fractionGroupSeparator {string}
     *     suffix                 {string}
     *
     * (The values assigned to the above FORMAT object properties are not checked for validity.)
     *
     * E.g.
     * BigNumber.config({ DECIMAL_PLACES : 20, ROUNDING_MODE : 4 })
     *
     * Ignore properties/parameters set to null or undefined, except for ALPHABET.
     *
     * Return an object with the properties current values.
     */ BigNumber.config = BigNumber.set = function(obj) {
            var p, v;
            if (obj != null) {
                if (typeof obj == "object") {
                    // DECIMAL_PLACES {number} Integer, 0 to MAX inclusive.
                    // '[BigNumber Error] DECIMAL_PLACES {not a primitive number|not an integer|out of range}: {v}'
                    if (obj.hasOwnProperty(p = "DECIMAL_PLACES")) {
                        v = obj[p];
                        intCheck(v, 0, MAX, p);
                        DECIMAL_PLACES = v;
                    }
                    // ROUNDING_MODE {number} Integer, 0 to 8 inclusive.
                    // '[BigNumber Error] ROUNDING_MODE {not a primitive number|not an integer|out of range}: {v}'
                    if (obj.hasOwnProperty(p = "ROUNDING_MODE")) {
                        v = obj[p];
                        intCheck(v, 0, 8, p);
                        ROUNDING_MODE = v;
                    }
                    // EXPONENTIAL_AT {number|number[]}
                    // Integer, -MAX to MAX inclusive or
                    // [integer -MAX to 0 inclusive, 0 to MAX inclusive].
                    // '[BigNumber Error] EXPONENTIAL_AT {not a primitive number|not an integer|out of range}: {v}'
                    if (obj.hasOwnProperty(p = "EXPONENTIAL_AT")) {
                        v = obj[p];
                        if (v && v.pop) {
                            intCheck(v[0], -MAX, 0, p);
                            intCheck(v[1], 0, MAX, p);
                            TO_EXP_NEG = v[0];
                            TO_EXP_POS = v[1];
                        } else {
                            intCheck(v, -MAX, MAX, p);
                            TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);
                        }
                    }
                    // RANGE {number|number[]} Non-zero integer, -MAX to MAX inclusive or
                    // [integer -MAX to -1 inclusive, integer 1 to MAX inclusive].
                    // '[BigNumber Error] RANGE {not a primitive number|not an integer|out of range|cannot be zero}: {v}'
                    if (obj.hasOwnProperty(p = "RANGE")) {
                        v = obj[p];
                        if (v && v.pop) {
                            intCheck(v[0], -MAX, -1, p);
                            intCheck(v[1], 1, MAX, p);
                            MIN_EXP = v[0];
                            MAX_EXP = v[1];
                        } else {
                            intCheck(v, -MAX, MAX, p);
                            if (v) MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);
                            else throw Error(bignumberError + p + " cannot be zero: " + v);
                        }
                    }
                    // CRYPTO {boolean} true or false.
                    // '[BigNumber Error] CRYPTO not true or false: {v}'
                    // '[BigNumber Error] crypto unavailable'
                    if (obj.hasOwnProperty(p = "CRYPTO")) {
                        v = obj[p];
                        if (v === !!v) {
                            if (v) {
                                if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) CRYPTO = v;
                                else {
                                    CRYPTO = !v;
                                    throw Error(bignumberError + "crypto unavailable");
                                }
                            } else CRYPTO = v;
                        } else throw Error(bignumberError + p + " not true or false: " + v);
                    }
                    // MODULO_MODE {number} Integer, 0 to 9 inclusive.
                    // '[BigNumber Error] MODULO_MODE {not a primitive number|not an integer|out of range}: {v}'
                    if (obj.hasOwnProperty(p = "MODULO_MODE")) {
                        v = obj[p];
                        intCheck(v, 0, 9, p);
                        MODULO_MODE = v;
                    }
                    // POW_PRECISION {number} Integer, 0 to MAX inclusive.
                    // '[BigNumber Error] POW_PRECISION {not a primitive number|not an integer|out of range}: {v}'
                    if (obj.hasOwnProperty(p = "POW_PRECISION")) {
                        v = obj[p];
                        intCheck(v, 0, MAX, p);
                        POW_PRECISION = v;
                    }
                    // FORMAT {object}
                    // '[BigNumber Error] FORMAT not an object: {v}'
                    if (obj.hasOwnProperty(p = "FORMAT")) {
                        v = obj[p];
                        if (typeof v == "object") FORMAT = v;
                        else throw Error(bignumberError + p + " not an object: " + v);
                    }
                    // ALPHABET {string}
                    // '[BigNumber Error] ALPHABET invalid: {v}'
                    if (obj.hasOwnProperty(p = "ALPHABET")) {
                        v = obj[p];
                        // Disallow if less than two characters,
                        // or if it contains '+', '-', '.', whitespace, or a repeated character.
                        if (typeof v == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(v)) {
                            alphabetHasNormalDecimalDigits = v.slice(0, 10) == "0123456789";
                            ALPHABET = v;
                        } else throw Error(bignumberError + p + " invalid: " + v);
                    }
                } else // '[BigNumber Error] Object expected: {v}'
                throw Error(bignumberError + "Object expected: " + obj);
            }
            return {
                DECIMAL_PLACES: DECIMAL_PLACES,
                ROUNDING_MODE: ROUNDING_MODE,
                EXPONENTIAL_AT: [
                    TO_EXP_NEG,
                    TO_EXP_POS
                ],
                RANGE: [
                    MIN_EXP,
                    MAX_EXP
                ],
                CRYPTO: CRYPTO,
                MODULO_MODE: MODULO_MODE,
                POW_PRECISION: POW_PRECISION,
                FORMAT: FORMAT,
                ALPHABET: ALPHABET
            };
        };
        /*
     * Return true if v is a BigNumber instance, otherwise return false.
     *
     * If BigNumber.DEBUG is true, throw if a BigNumber instance is not well-formed.
     *
     * v {any}
     *
     * '[BigNumber Error] Invalid BigNumber: {v}'
     */ BigNumber.isBigNumber = function(v) {
            if (!v || v._isBigNumber !== true) return false;
            if (!BigNumber.DEBUG) return true;
            var i, n, c = v.c, e = v.e, s = v.s;
            out: if (({}).toString.call(c) == "[object Array]") {
                if ((s === 1 || s === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {
                    // If the first element is zero, the BigNumber value must be zero.
                    if (c[0] === 0) {
                        if (e === 0 && c.length === 1) return true;
                        break out;
                    }
                    // Calculate number of digits that c[0] should have, based on the exponent.
                    i = (e + 1) % LOG_BASE;
                    if (i < 1) i += LOG_BASE;
                    // Calculate number of digits of c[0].
                    //if (Math.ceil(Math.log(c[0] + 1) / Math.LN10) == i) {
                    if (String(c[0]).length == i) {
                        for(i = 0; i < c.length; i++){
                            n = c[i];
                            if (n < 0 || n >= BASE || n !== mathfloor(n)) break out;
                        }
                        // Last element cannot be zero, unless it is the only element.
                        if (n !== 0) return true;
                    }
                }
            } else if (c === null && e === null && (s === null || s === 1 || s === -1)) return true;
            throw Error(bignumberError + "Invalid BigNumber: " + v);
        };
        /*
     * Return a new BigNumber whose value is the maximum of the arguments.
     *
     * arguments {number|string|BigNumber}
     */ BigNumber.maximum = BigNumber.max = function() {
            return maxOrMin(arguments, -1);
        };
        /*
     * Return a new BigNumber whose value is the minimum of the arguments.
     *
     * arguments {number|string|BigNumber}
     */ BigNumber.minimum = BigNumber.min = function() {
            return maxOrMin(arguments, 1);
        };
        /*
     * Return a new BigNumber with a random value equal to or greater than 0 and less than 1,
     * and with dp, or DECIMAL_PLACES if dp is omitted, decimal places (or less if trailing
     * zeros are produced).
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp}'
     * '[BigNumber Error] crypto unavailable'
     */ BigNumber.random = function() {
            var pow2_53 = 0x20000000000000;
            // Return a 53 bit integer n, where 0 <= n < 9007199254740992.
            // Check if Math.random() produces more than 32 bits of randomness.
            // If it does, assume at least 53 bits are produced, otherwise assume at least 30 bits.
            // 0x40000000 is 2^30, 0x800000 is 2^23, 0x1fffff is 2^21 - 1.
            var random53bitInt = Math.random() * pow2_53 & 0x1fffff ? function() {
                return mathfloor(Math.random() * pow2_53);
            } : function() {
                return (Math.random() * 0x40000000 | 0) * 0x800000 + (Math.random() * 0x800000 | 0);
            };
            return function(dp) {
                var a, b, e, k, v, i = 0, c = [], rand = new BigNumber(ONE);
                if (dp == null) dp = DECIMAL_PLACES;
                else intCheck(dp, 0, MAX);
                k = mathceil(dp / LOG_BASE);
                if (CRYPTO) {
                    // Browsers supporting crypto.getRandomValues.
                    if (crypto.getRandomValues) {
                        a = crypto.getRandomValues(new Uint32Array(k *= 2));
                        for(; i < k;){
                            // 53 bits:
                            // ((Math.pow(2, 32) - 1) * Math.pow(2, 21)).toString(2)
                            // 11111 11111111 11111111 11111111 11100000 00000000 00000000
                            // ((Math.pow(2, 32) - 1) >>> 11).toString(2)
                            //                                     11111 11111111 11111111
                            // 0x20000 is 2^21.
                            v = a[i] * 0x20000 + (a[i + 1] >>> 11);
                            // Rejection sampling:
                            // 0 <= v < 9007199254740992
                            // Probability that v >= 9e15, is
                            // 7199254740992 / 9007199254740992 ~= 0.0008, i.e. 1 in 1251
                            if (v >= 9e15) {
                                b = crypto.getRandomValues(new Uint32Array(2));
                                a[i] = b[0];
                                a[i + 1] = b[1];
                            } else {
                                // 0 <= v <= 8999999999999999
                                // 0 <= (v % 1e14) <= 99999999999999
                                c.push(v % 1e14);
                                i += 2;
                            }
                        }
                        i = k / 2;
                    // Node.js supporting crypto.randomBytes.
                    } else if (crypto.randomBytes) {
                        // buffer
                        a = crypto.randomBytes(k *= 7);
                        for(; i < k;){
                            // 0x1000000000000 is 2^48, 0x10000000000 is 2^40
                            // 0x100000000 is 2^32, 0x1000000 is 2^24
                            // 11111 11111111 11111111 11111111 11111111 11111111 11111111
                            // 0 <= v < 9007199254740992
                            v = (a[i] & 31) * 0x1000000000000 + a[i + 1] * 0x10000000000 + a[i + 2] * 0x100000000 + a[i + 3] * 0x1000000 + (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];
                            if (v >= 9e15) crypto.randomBytes(7).copy(a, i);
                            else {
                                // 0 <= (v % 1e14) <= 99999999999999
                                c.push(v % 1e14);
                                i += 7;
                            }
                        }
                        i = k / 7;
                    } else {
                        CRYPTO = false;
                        throw Error(bignumberError + "crypto unavailable");
                    }
                }
                // Use Math.random.
                if (!CRYPTO) for(; i < k;){
                    v = random53bitInt();
                    if (v < 9e15) c[i++] = v % 1e14;
                }
                k = c[--i];
                dp %= LOG_BASE;
                // Convert trailing digits to zeros according to dp.
                if (k && dp) {
                    v = POWS_TEN[LOG_BASE - dp];
                    c[i] = mathfloor(k / v) * v;
                }
                // Remove trailing elements which are zero.
                for(; c[i] === 0; c.pop(), i--);
                // Zero?
                if (i < 0) c = [
                    e = 0
                ];
                else {
                    // Remove leading elements which are zero and adjust exponent accordingly.
                    for(e = -1; c[0] === 0; c.splice(0, 1), e -= LOG_BASE);
                    // Count the digits of the first element of c to determine leading zeros, and...
                    for(i = 1, v = c[0]; v >= 10; v /= 10, i++);
                    // adjust the exponent accordingly.
                    if (i < LOG_BASE) e -= LOG_BASE - i;
                }
                rand.e = e;
                rand.c = c;
                return rand;
            };
        }();
        /*
     * Return a BigNumber whose value is the sum of the arguments.
     *
     * arguments {number|string|BigNumber}
     */ BigNumber.sum = function() {
            var i = 1, args = arguments, sum = new BigNumber(args[0]);
            for(; i < args.length;)sum = sum.plus(args[i++]);
            return sum;
        };
        // PRIVATE FUNCTIONS
        // Called by BigNumber and BigNumber.prototype.toString.
        convertBase = function() {
            var decimal = "0123456789";
            /*
       * Convert string of baseIn to an array of numbers of baseOut.
       * Eg. toBaseOut('255', 10, 16) returns [15, 15].
       * Eg. toBaseOut('ff', 16, 10) returns [2, 5, 5].
       */ function toBaseOut(str, baseIn, baseOut, alphabet) {
                var j, arr = [
                    0
                ], arrL, i = 0, len = str.length;
                for(; i < len;){
                    for(arrL = arr.length; arrL--; arr[arrL] *= baseIn);
                    arr[0] += alphabet.indexOf(str.charAt(i++));
                    for(j = 0; j < arr.length; j++)if (arr[j] > baseOut - 1) {
                        if (arr[j + 1] == null) arr[j + 1] = 0;
                        arr[j + 1] += arr[j] / baseOut | 0;
                        arr[j] %= baseOut;
                    }
                }
                return arr.reverse();
            }
            // Convert a numeric string of baseIn to a numeric string of baseOut.
            // If the caller is toString, we are converting from base 10 to baseOut.
            // If the caller is BigNumber, we are converting from baseIn to base 10.
            return function(str, baseIn, baseOut, sign, callerIsToString) {
                var alphabet, d, e, k, r, x, xc, y, i = str.indexOf("."), dp = DECIMAL_PLACES, rm = ROUNDING_MODE;
                // Non-integer.
                if (i >= 0) {
                    k = POW_PRECISION;
                    // Unlimited precision.
                    POW_PRECISION = 0;
                    str = str.replace(".", "");
                    y = new BigNumber(baseIn);
                    x = y.pow(str.length - i);
                    POW_PRECISION = k;
                    // Convert str as if an integer, then restore the fraction part by dividing the
                    // result by its base raised to a power.
                    y.c = toBaseOut(toFixedPoint(coeffToString(x.c), x.e, "0"), 10, baseOut, decimal);
                    y.e = y.c.length;
                }
                // Convert the number as integer.
                xc = toBaseOut(str, baseIn, baseOut, callerIsToString ? (alphabet = ALPHABET, decimal) : (alphabet = decimal, ALPHABET));
                // xc now represents str as an integer and converted to baseOut. e is the exponent.
                e = k = xc.length;
                // Remove trailing zeros.
                for(; xc[--k] == 0; xc.pop());
                // Zero?
                if (!xc[0]) return alphabet.charAt(0);
                // Does str represent an integer? If so, no need for the division.
                if (i < 0) --e;
                else {
                    x.c = xc;
                    x.e = e;
                    // The sign is needed for correct rounding.
                    x.s = sign;
                    x = div(x, y, dp, rm, baseOut);
                    xc = x.c;
                    r = x.r;
                    e = x.e;
                }
                // xc now represents str converted to baseOut.
                // THe index of the rounding digit.
                d = e + dp + 1;
                // The rounding digit: the digit to the right of the digit that may be rounded up.
                i = xc[d];
                // Look at the rounding digits and mode to determine whether to round up.
                k = baseOut / 2;
                r = r || d < 0 || xc[d + 1] != null;
                r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : i > k || i == k && (rm == 4 || r || rm == 6 && xc[d - 1] & 1 || rm == (x.s < 0 ? 8 : 7));
                // If the index of the rounding digit is not greater than zero, or xc represents
                // zero, then the result of the base conversion is zero or, if rounding up, a value
                // such as 0.00001.
                if (d < 1 || !xc[0]) // 1^-dp or 0
                str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);
                else {
                    // Truncate xc to the required number of decimal places.
                    xc.length = d;
                    // Round up?
                    if (r) // Rounding up may mean the previous digit has to be rounded up and so on.
                    for(--baseOut; ++xc[--d] > baseOut;){
                        xc[d] = 0;
                        if (!d) {
                            ++e;
                            xc = [
                                1
                            ].concat(xc);
                        }
                    }
                    // Determine trailing zeros.
                    for(k = xc.length; !xc[--k];);
                    // E.g. [4, 11, 15] becomes 4bf.
                    for(i = 0, str = ""; i <= k; str += alphabet.charAt(xc[i++]));
                    // Add leading zeros, decimal point and trailing zeros as required.
                    str = toFixedPoint(str, e, alphabet.charAt(0));
                }
                // The caller will add the sign.
                return str;
            };
        }();
        // Perform division in the specified base. Called by div and convertBase.
        div = function() {
            // Assume non-zero x and k.
            function multiply(x, k, base) {
                var m, temp, xlo, xhi, carry = 0, i = x.length, klo = k % SQRT_BASE, khi = k / SQRT_BASE | 0;
                for(x = x.slice(); i--;){
                    xlo = x[i] % SQRT_BASE;
                    xhi = x[i] / SQRT_BASE | 0;
                    m = khi * xlo + xhi * klo;
                    temp = klo * xlo + m % SQRT_BASE * SQRT_BASE + carry;
                    carry = (temp / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;
                    x[i] = temp % base;
                }
                if (carry) x = [
                    carry
                ].concat(x);
                return x;
            }
            function compare(a, b, aL, bL) {
                var i, cmp;
                if (aL != bL) cmp = aL > bL ? 1 : -1;
                else {
                    for(i = cmp = 0; i < aL; i++)if (a[i] != b[i]) {
                        cmp = a[i] > b[i] ? 1 : -1;
                        break;
                    }
                }
                return cmp;
            }
            function subtract(a, b, aL, base) {
                var i = 0;
                // Subtract b from a.
                for(; aL--;){
                    a[aL] -= i;
                    i = a[aL] < b[aL] ? 1 : 0;
                    a[aL] = i * base + a[aL] - b[aL];
                }
                // Remove leading zeros.
                for(; !a[0] && a.length > 1; a.splice(0, 1));
            }
            // x: dividend, y: divisor.
            return function(x, y, dp, rm, base) {
                var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0, yL, yz, s = x.s == y.s ? 1 : -1, xc = x.c, yc = y.c;
                // Either NaN, Infinity or 0?
                if (!xc || !xc[0] || !yc || !yc[0]) return new BigNumber(// Return NaN if either NaN, or both Infinity or 0.
                !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN : // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.
                xc && xc[0] == 0 || !yc ? s * 0 : s / 0);
                q = new BigNumber(s);
                qc = q.c = [];
                e = x.e - y.e;
                s = dp + e + 1;
                if (!base) {
                    base = BASE;
                    e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);
                    s = s / LOG_BASE | 0;
                }
                // Result exponent may be one less then the current value of e.
                // The coefficients of the BigNumbers from convertBase may have trailing zeros.
                for(i = 0; yc[i] == (xc[i] || 0); i++);
                if (yc[i] > (xc[i] || 0)) e--;
                if (s < 0) {
                    qc.push(1);
                    more = true;
                } else {
                    xL = xc.length;
                    yL = yc.length;
                    i = 0;
                    s += 2;
                    // Normalise xc and yc so highest order digit of yc is >= base / 2.
                    n = mathfloor(base / (yc[0] + 1));
                    // Not necessary, but to handle odd bases where yc[0] == (base / 2) - 1.
                    // if (n > 1 || n++ == 1 && yc[0] < base / 2) {
                    if (n > 1) {
                        yc = multiply(yc, n, base);
                        xc = multiply(xc, n, base);
                        yL = yc.length;
                        xL = xc.length;
                    }
                    xi = yL;
                    rem = xc.slice(0, yL);
                    remL = rem.length;
                    // Add zeros to make remainder as long as divisor.
                    for(; remL < yL; rem[remL++] = 0);
                    yz = yc.slice();
                    yz = [
                        0
                    ].concat(yz);
                    yc0 = yc[0];
                    if (yc[1] >= base / 2) yc0++;
                    // Not necessary, but to prevent trial digit n > base, when using base 3.
                    // else if (base == 3 && yc0 == 1) yc0 = 1 + 1e-15;
                    do {
                        n = 0;
                        // Compare divisor and remainder.
                        cmp = compare(yc, rem, yL, remL);
                        // If divisor < remainder.
                        if (cmp < 0) {
                            // Calculate trial digit, n.
                            rem0 = rem[0];
                            if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);
                            // n is how many times the divisor goes into the current remainder.
                            n = mathfloor(rem0 / yc0);
                            //  Algorithm:
                            //  product = divisor multiplied by trial digit (n).
                            //  Compare product and remainder.
                            //  If product is greater than remainder:
                            //    Subtract divisor from product, decrement trial digit.
                            //  Subtract product from remainder.
                            //  If product was less than remainder at the last compare:
                            //    Compare new remainder and divisor.
                            //    If remainder is greater than divisor:
                            //      Subtract divisor from remainder, increment trial digit.
                            if (n > 1) {
                                // n may be > base only when base is 3.
                                if (n >= base) n = base - 1;
                                // product = divisor * trial digit.
                                prod = multiply(yc, n, base);
                                prodL = prod.length;
                                remL = rem.length;
                                // Compare product and remainder.
                                // If product > remainder then trial digit n too high.
                                // n is 1 too high about 5% of the time, and is not known to have
                                // ever been more than 1 too high.
                                while(compare(prod, rem, prodL, remL) == 1){
                                    n--;
                                    // Subtract divisor from product.
                                    subtract(prod, yL < prodL ? yz : yc, prodL, base);
                                    prodL = prod.length;
                                    cmp = 1;
                                }
                            } else {
                                // n is 0 or 1, cmp is -1.
                                // If n is 0, there is no need to compare yc and rem again below,
                                // so change cmp to 1 to avoid it.
                                // If n is 1, leave cmp as -1, so yc and rem are compared again.
                                if (n == 0) // divisor < remainder, so n must be at least 1.
                                cmp = n = 1;
                                // product = divisor
                                prod = yc.slice();
                                prodL = prod.length;
                            }
                            if (prodL < remL) prod = [
                                0
                            ].concat(prod);
                            // Subtract product from remainder.
                            subtract(rem, prod, remL, base);
                            remL = rem.length;
                            // If product was < remainder.
                            if (cmp == -1) // Compare divisor and new remainder.
                            // If divisor < new remainder, subtract divisor from remainder.
                            // Trial digit n too low.
                            // n is 1 too low about 5% of the time, and very rarely 2 too low.
                            while(compare(yc, rem, yL, remL) < 1){
                                n++;
                                // Subtract divisor from remainder.
                                subtract(rem, yL < remL ? yz : yc, remL, base);
                                remL = rem.length;
                            }
                        } else if (cmp === 0) {
                            n++;
                            rem = [
                                0
                            ];
                        } // else cmp === 1 and n will be 0
                        // Add the next digit, n, to the result array.
                        qc[i++] = n;
                        // Update the remainder.
                        if (rem[0]) rem[remL++] = xc[xi] || 0;
                        else {
                            rem = [
                                xc[xi]
                            ];
                            remL = 1;
                        }
                    }while ((xi++ < xL || rem[0] != null) && s--);
                    more = rem[0] != null;
                    // Leading zero?
                    if (!qc[0]) qc.splice(0, 1);
                }
                if (base == BASE) {
                    // To calculate q.e, first get the number of digits of qc[0].
                    for(i = 1, s = qc[0]; s >= 10; s /= 10, i++);
                    round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);
                // Caller is convertBase.
                } else {
                    q.e = e;
                    q.r = +more;
                }
                return q;
            };
        }();
        /*
     * Return a string representing the value of BigNumber n in fixed-point or exponential
     * notation rounded to the specified decimal places or significant digits.
     *
     * n: a BigNumber.
     * i: the index of the last digit required (i.e. the digit that may be rounded up).
     * rm: the rounding mode.
     * id: 1 (toExponential) or 2 (toPrecision).
     */ function format(n, i, rm, id) {
            var c0, e, ne, len, str;
            if (rm == null) rm = ROUNDING_MODE;
            else intCheck(rm, 0, 8);
            if (!n.c) return n.toString();
            c0 = n.c[0];
            ne = n.e;
            if (i == null) {
                str = coeffToString(n.c);
                str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS) ? toExponential(str, ne) : toFixedPoint(str, ne, "0");
            } else {
                n = round(new BigNumber(n), i, rm);
                // n.e may have changed if the value was rounded up.
                e = n.e;
                str = coeffToString(n.c);
                len = str.length;
                // toPrecision returns exponential notation if the number of significant digits
                // specified is less than the number of digits necessary to represent the integer
                // part of the value in fixed-point notation.
                // Exponential notation.
                if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {
                    // Append zeros?
                    for(; len < i; str += "0", len++);
                    str = toExponential(str, e);
                // Fixed-point notation.
                } else {
                    i -= ne;
                    str = toFixedPoint(str, e, "0");
                    // Append zeros?
                    if (e + 1 > len) {
                        if (--i > 0) for(str += "."; i--; str += "0");
                    } else {
                        i += e - len;
                        if (i > 0) {
                            if (e + 1 == len) str += ".";
                            for(; i--; str += "0");
                        }
                    }
                }
            }
            return n.s < 0 && c0 ? "-" + str : str;
        }
        // Handle BigNumber.max and BigNumber.min.
        // If any number is NaN, return NaN.
        function maxOrMin(args, n) {
            var k, y, i = 1, x = new BigNumber(args[0]);
            for(; i < args.length; i++){
                y = new BigNumber(args[i]);
                if (!y.s || (k = compare(x, y)) === n || k === 0 && x.s === n) x = y;
            }
            return x;
        }
        /*
     * Strip trailing zeros, calculate base 10 exponent and check against MIN_EXP and MAX_EXP.
     * Called by minus, plus and times.
     */ function normalise(n, c, e) {
            var i = 1, j = c.length;
            // Remove trailing zeros.
            for(; !c[--j]; c.pop());
            // Calculate the base 10 exponent. First get the number of digits of c[0].
            for(j = c[0]; j >= 10; j /= 10, i++);
            // Overflow?
            if ((e = i + e * LOG_BASE - 1) > MAX_EXP) // Infinity.
            n.c = n.e = null;
            else if (e < MIN_EXP) // Zero.
            n.c = [
                n.e = 0
            ];
            else {
                n.e = e;
                n.c = c;
            }
            return n;
        }
        // Handle values that fail the validity test in BigNumber.
        parseNumeric = function() {
            var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i, dotAfter = /^([^.]+)\.$/, dotBefore = /^\.([^.]+)$/, isInfinityOrNaN = /^-?(Infinity|NaN)$/, whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
            return function(x, str, isNum, b) {
                var base, s = isNum ? str : str.replace(whitespaceOrPlus, "");
                // No exception on Infinity or NaN.
                if (isInfinityOrNaN.test(s)) x.s = isNaN(s) ? null : s < 0 ? -1 : 1;
                else {
                    if (!isNum) {
                        // basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i
                        s = s.replace(basePrefix, function(m, p1, p2) {
                            base = (p2 = p2.toLowerCase()) == "x" ? 16 : p2 == "b" ? 2 : 8;
                            return !b || b == base ? p1 : m;
                        });
                        if (b) {
                            base = b;
                            // E.g. '1.' to '1', '.1' to '0.1'
                            s = s.replace(dotAfter, "$1").replace(dotBefore, "0.$1");
                        }
                        if (str != s) return new BigNumber(s, base);
                    }
                    // '[BigNumber Error] Not a number: {n}'
                    // '[BigNumber Error] Not a base {b} number: {n}'
                    if (BigNumber.DEBUG) throw Error(bignumberError + "Not a" + (b ? " base " + b : "") + " number: " + str);
                    // NaN
                    x.s = null;
                }
                x.c = x.e = null;
            };
        }();
        /*
     * Round x to sd significant digits using rounding mode rm. Check for over/under-flow.
     * If r is truthy, it is known that there are more digits after the rounding digit.
     */ function round(x, sd, rm, r) {
            var d, i, j, k, n, ni, rd, xc = x.c, pows10 = POWS_TEN;
            // if x is not Infinity or NaN...
            if (xc) {
                // rd is the rounding digit, i.e. the digit after the digit that may be rounded up.
                // n is a base 1e14 number, the value of the element of array x.c containing rd.
                // ni is the index of n within x.c.
                // d is the number of digits of n.
                // i is the index of rd within n including leading zeros.
                // j is the actual index of rd within n (if < 0, rd is a leading zero).
                out: {
                    // Get the number of digits of the first element of xc.
                    for(d = 1, k = xc[0]; k >= 10; k /= 10, d++);
                    i = sd - d;
                    // If the rounding digit is in the first element of xc...
                    if (i < 0) {
                        i += LOG_BASE;
                        j = sd;
                        n = xc[ni = 0];
                        // Get the rounding digit at index j of n.
                        rd = mathfloor(n / pows10[d - j - 1] % 10);
                    } else {
                        ni = mathceil((i + 1) / LOG_BASE);
                        if (ni >= xc.length) {
                            if (r) {
                                // Needed by sqrt.
                                for(; xc.length <= ni; xc.push(0));
                                n = rd = 0;
                                d = 1;
                                i %= LOG_BASE;
                                j = i - LOG_BASE + 1;
                            } else break out;
                        } else {
                            n = k = xc[ni];
                            // Get the number of digits of n.
                            for(d = 1; k >= 10; k /= 10, d++);
                            // Get the index of rd within n.
                            i %= LOG_BASE;
                            // Get the index of rd within n, adjusted for leading zeros.
                            // The number of leading zeros of n is given by LOG_BASE - d.
                            j = i - LOG_BASE + d;
                            // Get the rounding digit at index j of n.
                            rd = j < 0 ? 0 : mathfloor(n / pows10[d - j - 1] % 10);
                        }
                    }
                    r = r || sd < 0 || // Are there any non-zero digits after the rounding digit?
                    // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
                    // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
                    xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);
                    r = rm < 4 ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 && (i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));
                    if (sd < 1 || !xc[0]) {
                        xc.length = 0;
                        if (r) {
                            // Convert sd to decimal places.
                            sd -= x.e + 1;
                            // 1, 0.1, 0.01, 0.001, 0.0001 etc.
                            xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
                            x.e = -sd || 0;
                        } else // Zero.
                        xc[0] = x.e = 0;
                        return x;
                    }
                    // Remove excess digits.
                    if (i == 0) {
                        xc.length = ni;
                        k = 1;
                        ni--;
                    } else {
                        xc.length = ni + 1;
                        k = pows10[LOG_BASE - i];
                        // E.g. 56700 becomes 56000 if 7 is the rounding digit.
                        // j > 0 means i > number of leading zeros of n.
                        xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;
                    }
                    // Round up?
                    if (r) {
                        for(;;)// If the digit to be rounded up is in the first element of xc...
                        if (ni == 0) {
                            // i will be the length of xc[0] before k is added.
                            for(i = 1, j = xc[0]; j >= 10; j /= 10, i++);
                            j = xc[0] += k;
                            for(k = 1; j >= 10; j /= 10, k++);
                            // if i != k the length has increased.
                            if (i != k) {
                                x.e++;
                                if (xc[0] == BASE) xc[0] = 1;
                            }
                            break;
                        } else {
                            xc[ni] += k;
                            if (xc[ni] != BASE) break;
                            xc[ni--] = 0;
                            k = 1;
                        }
                    }
                    // Remove trailing zeros.
                    for(i = xc.length; xc[--i] === 0; xc.pop());
                }
                // Overflow? Infinity.
                if (x.e > MAX_EXP) x.c = x.e = null;
                else if (x.e < MIN_EXP) x.c = [
                    x.e = 0
                ];
            }
            return x;
        }
        function valueOf(n) {
            var str, e = n.e;
            if (e === null) return n.toString();
            str = coeffToString(n.c);
            str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(str, e) : toFixedPoint(str, e, "0");
            return n.s < 0 ? "-" + str : str;
        }
        // PROTOTYPE/INSTANCE METHODS
        /*
     * Return a new BigNumber whose value is the absolute value of this BigNumber.
     */ P.absoluteValue = P.abs = function() {
            var x = new BigNumber(this);
            if (x.s < 0) x.s = 1;
            return x;
        };
        /*
     * Return
     *   1 if the value of this BigNumber is greater than the value of BigNumber(y, b),
     *   -1 if the value of this BigNumber is less than the value of BigNumber(y, b),
     *   0 if they have the same value,
     *   or null if the value of either is NaN.
     */ P.comparedTo = function(y, b) {
            return compare(this, new BigNumber(y, b));
        };
        /*
     * If dp is undefined or null or true or false, return the number of decimal places of the
     * value of this BigNumber, or null if the value of this BigNumber is Infinity or NaN.
     *
     * Otherwise, if dp is a number, return a new BigNumber whose value is the value of this
     * BigNumber rounded to a maximum of dp decimal places using rounding mode rm, or
     * ROUNDING_MODE if rm is omitted.
     *
     * [dp] {number} Decimal places: integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     */ P.decimalPlaces = P.dp = function(dp, rm) {
            var c, n, v, x = this;
            if (dp != null) {
                intCheck(dp, 0, MAX);
                if (rm == null) rm = ROUNDING_MODE;
                else intCheck(rm, 0, 8);
                return round(new BigNumber(x), dp + x.e + 1, rm);
            }
            if (!(c = x.c)) return null;
            n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;
            // Subtract the number of trailing zeros of the last number.
            if (v = c[v]) for(; v % 10 == 0; v /= 10, n--);
            if (n < 0) n = 0;
            return n;
        };
        /*
     *  n / 0 = I
     *  n / N = N
     *  n / I = 0
     *  0 / n = 0
     *  0 / 0 = N
     *  0 / N = N
     *  0 / I = 0
     *  N / n = N
     *  N / 0 = N
     *  N / N = N
     *  N / I = N
     *  I / n = I
     *  I / 0 = I
     *  I / N = N
     *  I / I = N
     *
     * Return a new BigNumber whose value is the value of this BigNumber divided by the value of
     * BigNumber(y, b), rounded according to DECIMAL_PLACES and ROUNDING_MODE.
     */ P.dividedBy = P.div = function(y, b) {
            return div(this, new BigNumber(y, b), DECIMAL_PLACES, ROUNDING_MODE);
        };
        /*
     * Return a new BigNumber whose value is the integer part of dividing the value of this
     * BigNumber by the value of BigNumber(y, b).
     */ P.dividedToIntegerBy = P.idiv = function(y, b) {
            return div(this, new BigNumber(y, b), 0, 1);
        };
        /*
     * Return a BigNumber whose value is the value of this BigNumber exponentiated by n.
     *
     * If m is present, return the result modulo m.
     * If n is negative round according to DECIMAL_PLACES and ROUNDING_MODE.
     * If POW_PRECISION is non-zero and m is not present, round to POW_PRECISION using ROUNDING_MODE.
     *
     * The modular power operation works efficiently when x, n, and m are integers, otherwise it
     * is equivalent to calculating x.exponentiatedBy(n).modulo(m) with a POW_PRECISION of 0.
     *
     * n {number|string|BigNumber} The exponent. An integer.
     * [m] {number|string|BigNumber} The modulus.
     *
     * '[BigNumber Error] Exponent not an integer: {n}'
     */ P.exponentiatedBy = P.pow = function(n, m) {
            var half, isModExp, i, k, more, nIsBig, nIsNeg, nIsOdd, y, x = this;
            n = new BigNumber(n);
            // Allow NaN and Infinity, but not other non-integers.
            if (n.c && !n.isInteger()) throw Error(bignumberError + "Exponent not an integer: " + valueOf(n));
            if (m != null) m = new BigNumber(m);
            // Exponent of MAX_SAFE_INTEGER is 15.
            nIsBig = n.e > 14;
            // If x is NaN, Infinity, 0 or 1, or n is Infinity, NaN or 0.
            if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {
                // The sign of the result of pow when x is negative depends on the evenness of n.
                // If +n overflows to Infinity, the evenness of n would be not be known.
                y = new BigNumber(Math.pow(+valueOf(x), nIsBig ? n.s * (2 - isOdd(n)) : +valueOf(n)));
                return m ? y.mod(m) : y;
            }
            nIsNeg = n.s < 0;
            if (m) {
                // x % m returns NaN if abs(m) is zero, or m is NaN.
                if (m.c ? !m.c[0] : !m.s) return new BigNumber(NaN);
                isModExp = !nIsNeg && x.isInteger() && m.isInteger();
                if (isModExp) x = x.mod(m);
            // Overflow to Infinity: >=2**1e10 or >=1.0000024**1e15.
            // Underflow to 0: <=0.79**1e10 or <=0.9999975**1e15.
            } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0 ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7 : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {
                // If x is negative and n is odd, k = -0, else k = 0.
                k = x.s < 0 && isOdd(n) ? -0 : 0;
                // If x >= 1, k = Infinity.
                if (x.e > -1) k = 1 / k;
                // If n is negative return 0, else return Infinity.
                return new BigNumber(nIsNeg ? 1 / k : k);
            } else if (POW_PRECISION) // Truncating each coefficient array to a length of k after each multiplication
            // equates to truncating significant digits to POW_PRECISION + [28, 41],
            // i.e. there will be a minimum of 28 guard digits retained.
            k = mathceil(POW_PRECISION / LOG_BASE + 2);
            if (nIsBig) {
                half = new BigNumber(0.5);
                if (nIsNeg) n.s = 1;
                nIsOdd = isOdd(n);
            } else {
                i = Math.abs(+valueOf(n));
                nIsOdd = i % 2;
            }
            y = new BigNumber(ONE);
            // Performs 54 loop iterations for n of 9007199254740991.
            for(;;){
                if (nIsOdd) {
                    y = y.times(x);
                    if (!y.c) break;
                    if (k) {
                        if (y.c.length > k) y.c.length = k;
                    } else if (isModExp) y = y.mod(m); //y = y.minus(div(y, m, 0, MODULO_MODE).times(m));
                }
                if (i) {
                    i = mathfloor(i / 2);
                    if (i === 0) break;
                    nIsOdd = i % 2;
                } else {
                    n = n.times(half);
                    round(n, n.e + 1, 1);
                    if (n.e > 14) nIsOdd = isOdd(n);
                    else {
                        i = +valueOf(n);
                        if (i === 0) break;
                        nIsOdd = i % 2;
                    }
                }
                x = x.times(x);
                if (k) {
                    if (x.c && x.c.length > k) x.c.length = k;
                } else if (isModExp) x = x.mod(m); //x = x.minus(div(x, m, 0, MODULO_MODE).times(m));
            }
            if (isModExp) return y;
            if (nIsNeg) y = ONE.div(y);
            return m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;
        };
        /*
     * Return a new BigNumber whose value is the value of this BigNumber rounded to an integer
     * using rounding mode rm, or ROUNDING_MODE if rm is omitted.
     *
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {rm}'
     */ P.integerValue = function(rm) {
            var n = new BigNumber(this);
            if (rm == null) rm = ROUNDING_MODE;
            else intCheck(rm, 0, 8);
            return round(n, n.e + 1, rm);
        };
        /*
     * Return true if the value of this BigNumber is equal to the value of BigNumber(y, b),
     * otherwise return false.
     */ P.isEqualTo = P.eq = function(y, b) {
            return compare(this, new BigNumber(y, b)) === 0;
        };
        /*
     * Return true if the value of this BigNumber is a finite number, otherwise return false.
     */ P.isFinite = function() {
            return !!this.c;
        };
        /*
     * Return true if the value of this BigNumber is greater than the value of BigNumber(y, b),
     * otherwise return false.
     */ P.isGreaterThan = P.gt = function(y, b) {
            return compare(this, new BigNumber(y, b)) > 0;
        };
        /*
     * Return true if the value of this BigNumber is greater than or equal to the value of
     * BigNumber(y, b), otherwise return false.
     */ P.isGreaterThanOrEqualTo = P.gte = function(y, b) {
            return (b = compare(this, new BigNumber(y, b))) === 1 || b === 0;
        };
        /*
     * Return true if the value of this BigNumber is an integer, otherwise return false.
     */ P.isInteger = function() {
            return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
        };
        /*
     * Return true if the value of this BigNumber is less than the value of BigNumber(y, b),
     * otherwise return false.
     */ P.isLessThan = P.lt = function(y, b) {
            return compare(this, new BigNumber(y, b)) < 0;
        };
        /*
     * Return true if the value of this BigNumber is less than or equal to the value of
     * BigNumber(y, b), otherwise return false.
     */ P.isLessThanOrEqualTo = P.lte = function(y, b) {
            return (b = compare(this, new BigNumber(y, b))) === -1 || b === 0;
        };
        /*
     * Return true if the value of this BigNumber is NaN, otherwise return false.
     */ P.isNaN = function() {
            return !this.s;
        };
        /*
     * Return true if the value of this BigNumber is negative, otherwise return false.
     */ P.isNegative = function() {
            return this.s < 0;
        };
        /*
     * Return true if the value of this BigNumber is positive, otherwise return false.
     */ P.isPositive = function() {
            return this.s > 0;
        };
        /*
     * Return true if the value of this BigNumber is 0 or -0, otherwise return false.
     */ P.isZero = function() {
            return !!this.c && this.c[0] == 0;
        };
        /*
     *  n - 0 = n
     *  n - N = N
     *  n - I = -I
     *  0 - n = -n
     *  0 - 0 = 0
     *  0 - N = N
     *  0 - I = -I
     *  N - n = N
     *  N - 0 = N
     *  N - N = N
     *  N - I = N
     *  I - n = I
     *  I - 0 = I
     *  I - N = N
     *  I - I = N
     *
     * Return a new BigNumber whose value is the value of this BigNumber minus the value of
     * BigNumber(y, b).
     */ P.minus = function(y, b) {
            var i, j, t, xLTy, x = this, a = x.s;
            y = new BigNumber(y, b);
            b = y.s;
            // Either NaN?
            if (!a || !b) return new BigNumber(NaN);
            // Signs differ?
            if (a != b) {
                y.s = -b;
                return x.plus(y);
            }
            var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
            if (!xe || !ye) {
                // Either Infinity?
                if (!xc || !yc) return xc ? (y.s = -b, y) : new BigNumber(yc ? x : NaN);
                // Either zero?
                if (!xc[0] || !yc[0]) // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.
                return yc[0] ? (y.s = -b, y) : new BigNumber(xc[0] ? x : // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
                ROUNDING_MODE == 3 ? -0 : 0);
            }
            xe = bitFloor(xe);
            ye = bitFloor(ye);
            xc = xc.slice();
            // Determine which is the bigger number.
            if (a = xe - ye) {
                if (xLTy = a < 0) {
                    a = -a;
                    t = xc;
                } else {
                    ye = xe;
                    t = yc;
                }
                t.reverse();
                // Prepend zeros to equalise exponents.
                for(b = a; b--; t.push(0));
                t.reverse();
            } else {
                // Exponents equal. Check digit by digit.
                j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;
                for(a = b = 0; b < j; b++)if (xc[b] != yc[b]) {
                    xLTy = xc[b] < yc[b];
                    break;
                }
            }
            // x < y? Point xc to the array of the bigger number.
            if (xLTy) {
                t = xc;
                xc = yc;
                yc = t;
                y.s = -y.s;
            }
            b = (j = yc.length) - (i = xc.length);
            // Append zeros to xc if shorter.
            // No need to add zeros to yc if shorter as subtract only needs to start at yc.length.
            if (b > 0) for(; b--; xc[i++] = 0);
            b = BASE - 1;
            // Subtract yc from xc.
            for(; j > a;){
                if (xc[--j] < yc[j]) {
                    for(i = j; i && !xc[--i]; xc[i] = b);
                    --xc[i];
                    xc[j] += BASE;
                }
                xc[j] -= yc[j];
            }
            // Remove leading zeros and adjust exponent accordingly.
            for(; xc[0] == 0; xc.splice(0, 1), --ye);
            // Zero?
            if (!xc[0]) {
                // Following IEEE 754 (2008) 6.3,
                // n - n = +0  but  n - n = -0  when rounding towards -Infinity.
                y.s = ROUNDING_MODE == 3 ? -1 : 1;
                y.c = [
                    y.e = 0
                ];
                return y;
            }
            // No need to check for Infinity as +x - +y != Infinity && -x - -y != Infinity
            // for finite x and y.
            return normalise(y, xc, ye);
        };
        /*
     *   n % 0 =  N
     *   n % N =  N
     *   n % I =  n
     *   0 % n =  0
     *  -0 % n = -0
     *   0 % 0 =  N
     *   0 % N =  N
     *   0 % I =  0
     *   N % n =  N
     *   N % 0 =  N
     *   N % N =  N
     *   N % I =  N
     *   I % n =  N
     *   I % 0 =  N
     *   I % N =  N
     *   I % I =  N
     *
     * Return a new BigNumber whose value is the value of this BigNumber modulo the value of
     * BigNumber(y, b). The result depends on the value of MODULO_MODE.
     */ P.modulo = P.mod = function(y, b) {
            var q, s, x = this;
            y = new BigNumber(y, b);
            // Return NaN if x is Infinity or NaN, or y is NaN or zero.
            if (!x.c || !y.s || y.c && !y.c[0]) return new BigNumber(NaN);
            else if (!y.c || x.c && !x.c[0]) return new BigNumber(x);
            if (MODULO_MODE == 9) {
                // Euclidian division: q = sign(y) * floor(x / abs(y))
                // r = x - qy    where  0 <= r < abs(y)
                s = y.s;
                y.s = 1;
                q = div(x, y, 0, 3);
                y.s = s;
                q.s *= s;
            } else q = div(x, y, 0, MODULO_MODE);
            y = x.minus(q.times(y));
            // To match JavaScript %, ensure sign of zero is sign of dividend.
            if (!y.c[0] && MODULO_MODE == 1) y.s = x.s;
            return y;
        };
        /*
     *  n * 0 = 0
     *  n * N = N
     *  n * I = I
     *  0 * n = 0
     *  0 * 0 = 0
     *  0 * N = N
     *  0 * I = N
     *  N * n = N
     *  N * 0 = N
     *  N * N = N
     *  N * I = N
     *  I * n = I
     *  I * 0 = N
     *  I * N = N
     *  I * I = I
     *
     * Return a new BigNumber whose value is the value of this BigNumber multiplied by the value
     * of BigNumber(y, b).
     */ P.multipliedBy = P.times = function(y, b) {
            var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc, base, sqrtBase, x = this, xc = x.c, yc = (y = new BigNumber(y, b)).c;
            // Either NaN, Infinity or 0?
            if (!xc || !yc || !xc[0] || !yc[0]) {
                // Return NaN if either is NaN, or one is 0 and the other is Infinity.
                if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) y.c = y.e = y.s = null;
                else {
                    y.s *= x.s;
                    // Return Infinity if either is Infinity.
                    if (!xc || !yc) y.c = y.e = null;
                    else {
                        y.c = [
                            0
                        ];
                        y.e = 0;
                    }
                }
                return y;
            }
            e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);
            y.s *= x.s;
            xcL = xc.length;
            ycL = yc.length;
            // Ensure xc points to longer array and xcL to its length.
            if (xcL < ycL) {
                zc = xc;
                xc = yc;
                yc = zc;
                i = xcL;
                xcL = ycL;
                ycL = i;
            }
            // Initialise the result array with zeros.
            for(i = xcL + ycL, zc = []; i--; zc.push(0));
            base = BASE;
            sqrtBase = SQRT_BASE;
            for(i = ycL; --i >= 0;){
                c = 0;
                ylo = yc[i] % sqrtBase;
                yhi = yc[i] / sqrtBase | 0;
                for(k = xcL, j = i + k; j > i;){
                    xlo = xc[--k] % sqrtBase;
                    xhi = xc[k] / sqrtBase | 0;
                    m = yhi * xlo + xhi * ylo;
                    xlo = ylo * xlo + m % sqrtBase * sqrtBase + zc[j] + c;
                    c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;
                    zc[j--] = xlo % base;
                }
                zc[j] = c;
            }
            if (c) ++e;
            else zc.splice(0, 1);
            return normalise(y, zc, e);
        };
        /*
     * Return a new BigNumber whose value is the value of this BigNumber negated,
     * i.e. multiplied by -1.
     */ P.negated = function() {
            var x = new BigNumber(this);
            x.s = -x.s || null;
            return x;
        };
        /*
     *  n + 0 = n
     *  n + N = N
     *  n + I = I
     *  0 + n = n
     *  0 + 0 = 0
     *  0 + N = N
     *  0 + I = I
     *  N + n = N
     *  N + 0 = N
     *  N + N = N
     *  N + I = N
     *  I + n = I
     *  I + 0 = I
     *  I + N = N
     *  I + I = I
     *
     * Return a new BigNumber whose value is the value of this BigNumber plus the value of
     * BigNumber(y, b).
     */ P.plus = function(y, b) {
            var t, x = this, a = x.s;
            y = new BigNumber(y, b);
            b = y.s;
            // Either NaN?
            if (!a || !b) return new BigNumber(NaN);
            // Signs differ?
            if (a != b) {
                y.s = -b;
                return x.minus(y);
            }
            var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
            if (!xe || !ye) {
                // Return Infinity if either Infinity.
                if (!xc || !yc) return new BigNumber(a / 0);
                // Either zero?
                // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.
                if (!xc[0] || !yc[0]) return yc[0] ? y : new BigNumber(xc[0] ? x : a * 0);
            }
            xe = bitFloor(xe);
            ye = bitFloor(ye);
            xc = xc.slice();
            // Prepend zeros to equalise exponents. Faster to use reverse then do unshifts.
            if (a = xe - ye) {
                if (a > 0) {
                    ye = xe;
                    t = yc;
                } else {
                    a = -a;
                    t = xc;
                }
                t.reverse();
                for(; a--; t.push(0));
                t.reverse();
            }
            a = xc.length;
            b = yc.length;
            // Point xc to the longer array, and b to the shorter length.
            if (a - b < 0) {
                t = yc;
                yc = xc;
                xc = t;
                b = a;
            }
            // Only start adding at yc.length - 1 as the further digits of xc can be ignored.
            for(a = 0; b;){
                a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;
                xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;
            }
            if (a) {
                xc = [
                    a
                ].concat(xc);
                ++ye;
            }
            // No need to check for zero, as +x + +y != 0 && -x + -y != 0
            // ye = MAX_EXP + 1 possible
            return normalise(y, xc, ye);
        };
        /*
     * If sd is undefined or null or true or false, return the number of significant digits of
     * the value of this BigNumber, or null if the value of this BigNumber is Infinity or NaN.
     * If sd is true include integer-part trailing zeros in the count.
     *
     * Otherwise, if sd is a number, return a new BigNumber whose value is the value of this
     * BigNumber rounded to a maximum of sd significant digits using rounding mode rm, or
     * ROUNDING_MODE if rm is omitted.
     *
     * sd {number|boolean} number: significant digits: integer, 1 to MAX inclusive.
     *                     boolean: whether to count integer-part trailing zeros: true or false.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'
     */ P.precision = P.sd = function(sd, rm) {
            var c, n, v, x = this;
            if (sd != null && sd !== !!sd) {
                intCheck(sd, 1, MAX);
                if (rm == null) rm = ROUNDING_MODE;
                else intCheck(rm, 0, 8);
                return round(new BigNumber(x), sd, rm);
            }
            if (!(c = x.c)) return null;
            v = c.length - 1;
            n = v * LOG_BASE + 1;
            if (v = c[v]) {
                // Subtract the number of trailing zeros of the last element.
                for(; v % 10 == 0; v /= 10, n--);
                // Add the number of digits of the first element.
                for(v = c[0]; v >= 10; v /= 10, n++);
            }
            if (sd && x.e + 1 > n) n = x.e + 1;
            return n;
        };
        /*
     * Return a new BigNumber whose value is the value of this BigNumber shifted by k places
     * (powers of 10). Shift to the right if n > 0, and to the left if n < 0.
     *
     * k {number} Integer, -MAX_SAFE_INTEGER to MAX_SAFE_INTEGER inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {k}'
     */ P.shiftedBy = function(k) {
            intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
            return this.times("1e" + k);
        };
        /*
     *  sqrt(-n) =  N
     *  sqrt(N) =  N
     *  sqrt(-I) =  N
     *  sqrt(I) =  I
     *  sqrt(0) =  0
     *  sqrt(-0) = -0
     *
     * Return a new BigNumber whose value is the square root of the value of this BigNumber,
     * rounded according to DECIMAL_PLACES and ROUNDING_MODE.
     */ P.squareRoot = P.sqrt = function() {
            var m, n, r, rep, t, x = this, c = x.c, s = x.s, e = x.e, dp = DECIMAL_PLACES + 4, half = new BigNumber("0.5");
            // Negative/NaN/Infinity/zero?
            if (s !== 1 || !c || !c[0]) return new BigNumber(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);
            // Initial estimate.
            s = Math.sqrt(+valueOf(x));
            // Math.sqrt underflow/overflow?
            // Pass x to Math.sqrt as integer, then adjust the exponent of the result.
            if (s == 0 || s == 1 / 0) {
                n = coeffToString(c);
                if ((n.length + e) % 2 == 0) n += "0";
                s = Math.sqrt(+n);
                e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);
                if (s == 1 / 0) n = "5e" + e;
                else {
                    n = s.toExponential();
                    n = n.slice(0, n.indexOf("e") + 1) + e;
                }
                r = new BigNumber(n);
            } else r = new BigNumber(s + "");
            // Check for zero.
            // r could be zero if MIN_EXP is changed after the this value was created.
            // This would cause a division by zero (x/t) and hence Infinity below, which would cause
            // coeffToString to throw.
            if (r.c[0]) {
                e = r.e;
                s = e + dp;
                if (s < 3) s = 0;
                // Newton-Raphson iteration.
                for(;;){
                    t = r;
                    r = half.times(t.plus(div(x, t, dp, 1)));
                    if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {
                        // The exponent of r may here be one less than the final result exponent,
                        // e.g 0.0009999 (e-4) --> 0.001 (e-3), so adjust s so the rounding digits
                        // are indexed correctly.
                        if (r.e < e) --s;
                        n = n.slice(s - 3, s + 1);
                        // The 4th rounding digit may be in error by -1 so if the 4 rounding digits
                        // are 9999 or 4999 (i.e. approaching a rounding boundary) continue the
                        // iteration.
                        if (n == "9999" || !rep && n == "4999") {
                            // On the first iteration only, check to see if rounding up gives the
                            // exact result as the nines may infinitely repeat.
                            if (!rep) {
                                round(t, t.e + DECIMAL_PLACES + 2, 0);
                                if (t.times(t).eq(x)) {
                                    r = t;
                                    break;
                                }
                            }
                            dp += 4;
                            s += 4;
                            rep = 1;
                        } else {
                            // If rounding digits are null, 0{0,4} or 50{0,3}, check for exact
                            // result. If not, then there are further digits and m will be truthy.
                            if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
                                // Truncate to the first rounding digit.
                                round(r, r.e + DECIMAL_PLACES + 2, 1);
                                m = !r.times(r).eq(x);
                            }
                            break;
                        }
                    }
                }
            }
            return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);
        };
        /*
     * Return a string representing the value of this BigNumber in exponential notation and
     * rounded using ROUNDING_MODE to dp fixed decimal places.
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     */ P.toExponential = function(dp, rm) {
            if (dp != null) {
                intCheck(dp, 0, MAX);
                dp++;
            }
            return format(this, dp, rm, 1);
        };
        /*
     * Return a string representing the value of this BigNumber in fixed-point notation rounding
     * to dp fixed decimal places using rounding mode rm, or ROUNDING_MODE if rm is omitted.
     *
     * Note: as with JavaScript's number type, (-0).toFixed(0) is '0',
     * but e.g. (-0.00001).toFixed(0) is '-0'.
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     */ P.toFixed = function(dp, rm) {
            if (dp != null) {
                intCheck(dp, 0, MAX);
                dp = dp + this.e + 1;
            }
            return format(this, dp, rm);
        };
        /*
     * Return a string representing the value of this BigNumber in fixed-point notation rounded
     * using rm or ROUNDING_MODE to dp decimal places, and formatted according to the properties
     * of the format or FORMAT object (see BigNumber.set).
     *
     * The formatting object may contain some or all of the properties shown below.
     *
     * FORMAT = {
     *   prefix: '',
     *   groupSize: 3,
     *   secondaryGroupSize: 0,
     *   groupSeparator: ',',
     *   decimalSeparator: '.',
     *   fractionGroupSize: 0,
     *   fractionGroupSeparator: '\xA0',      // non-breaking space
     *   suffix: ''
     * };
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     * [format] {object} Formatting options. See FORMAT pbject above.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     * '[BigNumber Error] Argument not an object: {format}'
     */ P.toFormat = function(dp, rm, format) {
            var str, x = this;
            if (format == null) {
                if (dp != null && rm && typeof rm == "object") {
                    format = rm;
                    rm = null;
                } else if (dp && typeof dp == "object") {
                    format = dp;
                    dp = rm = null;
                } else format = FORMAT;
            } else if (typeof format != "object") throw Error(bignumberError + "Argument not an object: " + format);
            str = x.toFixed(dp, rm);
            if (x.c) {
                var i, arr = str.split("."), g1 = +format.groupSize, g2 = +format.secondaryGroupSize, groupSeparator = format.groupSeparator || "", intPart = arr[0], fractionPart = arr[1], isNeg = x.s < 0, intDigits = isNeg ? intPart.slice(1) : intPart, len = intDigits.length;
                if (g2) {
                    i = g1;
                    g1 = g2;
                    g2 = i;
                    len -= i;
                }
                if (g1 > 0 && len > 0) {
                    i = len % g1 || g1;
                    intPart = intDigits.substr(0, i);
                    for(; i < len; i += g1)intPart += groupSeparator + intDigits.substr(i, g1);
                    if (g2 > 0) intPart += groupSeparator + intDigits.slice(i);
                    if (isNeg) intPart = "-" + intPart;
                }
                str = fractionPart ? intPart + (format.decimalSeparator || "") + ((g2 = +format.fractionGroupSize) ? fractionPart.replace(new RegExp("\\d{" + g2 + "}\\B", "g"), "$&" + (format.fractionGroupSeparator || "")) : fractionPart) : intPart;
            }
            return (format.prefix || "") + str + (format.suffix || "");
        };
        /*
     * Return an array of two BigNumbers representing the value of this BigNumber as a simple
     * fraction with an integer numerator and an integer denominator.
     * The denominator will be a positive non-zero value less than or equal to the specified
     * maximum denominator. If a maximum denominator is not specified, the denominator will be
     * the lowest value necessary to represent the number exactly.
     *
     * [md] {number|string|BigNumber} Integer >= 1, or Infinity. The maximum denominator.
     *
     * '[BigNumber Error] Argument {not an integer|out of range} : {md}'
     */ P.toFraction = function(md) {
            var d, d0, d1, d2, e, exp, n, n0, n1, q, r, s, x = this, xc = x.c;
            if (md != null) {
                n = new BigNumber(md);
                // Throw if md is less than one or is not an integer, unless it is Infinity.
                if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) throw Error(bignumberError + "Argument " + (n.isInteger() ? "out of range: " : "not an integer: ") + valueOf(n));
            }
            if (!xc) return new BigNumber(x);
            d = new BigNumber(ONE);
            n1 = d0 = new BigNumber(ONE);
            d1 = n0 = new BigNumber(ONE);
            s = coeffToString(xc);
            // Determine initial denominator.
            // d is a power of 10 and the minimum max denominator that specifies the value exactly.
            e = d.e = s.length - x.e - 1;
            d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
            md = !md || n.comparedTo(d) > 0 ? e > 0 ? d : n1 : n;
            exp = MAX_EXP;
            MAX_EXP = 1 / 0;
            n = new BigNumber(s);
            // n0 = d1 = 0
            n0.c[0] = 0;
            for(;;){
                q = div(n, d, 0, 1);
                d2 = d0.plus(q.times(d1));
                if (d2.comparedTo(md) == 1) break;
                d0 = d1;
                d1 = d2;
                n1 = n0.plus(q.times(d2 = n1));
                n0 = d2;
                d = n.minus(q.times(d2 = d));
                n = d2;
            }
            d2 = div(md.minus(d0), d1, 0, 1);
            n0 = n0.plus(d2.times(n1));
            d0 = d0.plus(d2.times(d1));
            n0.s = n1.s = x.s;
            e = e * 2;
            // Determine which fraction is closer to x, n0/d0 or n1/d1
            r = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(div(n0, d0, e, ROUNDING_MODE).minus(x).abs()) < 1 ? [
                n1,
                d1
            ] : [
                n0,
                d0
            ];
            MAX_EXP = exp;
            return r;
        };
        /*
     * Return the value of this BigNumber converted to a number primitive.
     */ P.toNumber = function() {
            return +valueOf(this);
        };
        /*
     * Return a string representing the value of this BigNumber rounded to sd significant digits
     * using rounding mode rm or ROUNDING_MODE. If sd is less than the number of digits
     * necessary to represent the integer part of the value in fixed-point notation, then use
     * exponential notation.
     *
     * [sd] {number} Significant digits. Integer, 1 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'
     */ P.toPrecision = function(sd, rm) {
            if (sd != null) intCheck(sd, 1, MAX);
            return format(this, sd, rm, 2);
        };
        /*
     * Return a string representing the value of this BigNumber in base b, or base 10 if b is
     * omitted. If a base is specified, including base 10, round according to DECIMAL_PLACES and
     * ROUNDING_MODE. If a base is not specified, and this BigNumber has a positive exponent
     * that is equal to or greater than TO_EXP_POS, or a negative exponent equal to or less than
     * TO_EXP_NEG, return exponential notation.
     *
     * [b] {number} Integer, 2 to ALPHABET.length inclusive.
     *
     * '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'
     */ P.toString = function(b) {
            var str, n = this, s = n.s, e = n.e;
            // Infinity or NaN?
            if (e === null) {
                if (s) {
                    str = "Infinity";
                    if (s < 0) str = "-" + str;
                } else str = "NaN";
            } else {
                if (b == null) str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(coeffToString(n.c), e) : toFixedPoint(coeffToString(n.c), e, "0");
                else if (b === 10 && alphabetHasNormalDecimalDigits) {
                    n = round(new BigNumber(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);
                    str = toFixedPoint(coeffToString(n.c), n.e, "0");
                } else {
                    intCheck(b, 2, ALPHABET.length, "Base");
                    str = convertBase(toFixedPoint(coeffToString(n.c), e, "0"), 10, b, s, true);
                }
                if (s < 0 && n.c[0]) str = "-" + str;
            }
            return str;
        };
        /*
     * Return as toString, but do not accept a base argument, and include the minus sign for
     * negative zero.
     */ P.valueOf = P.toJSON = function() {
            return valueOf(this);
        };
        P._isBigNumber = true;
        if (configObject != null) BigNumber.set(configObject);
        return BigNumber;
    }
    // PRIVATE HELPER FUNCTIONS
    // These functions don't need access to variables,
    // e.g. DECIMAL_PLACES, in the scope of the `clone` function above.
    function bitFloor(n) {
        var i = n | 0;
        return n > 0 || n === i ? i : i - 1;
    }
    // Return a coefficient array as a string of base 10 digits.
    function coeffToString(a) {
        var s, z, i = 1, j = a.length, r = a[0] + "";
        for(; i < j;){
            s = a[i++] + "";
            z = LOG_BASE - s.length;
            for(; z--; s = "0" + s);
            r += s;
        }
        // Determine trailing zeros.
        for(j = r.length; r.charCodeAt(--j) === 48;);
        return r.slice(0, j + 1 || 1);
    }
    // Compare the value of BigNumbers x and y.
    function compare(x, y) {
        var a, b, xc = x.c, yc = y.c, i = x.s, j = y.s, k = x.e, l = y.e;
        // Either NaN?
        if (!i || !j) return null;
        a = xc && !xc[0];
        b = yc && !yc[0];
        // Either zero?
        if (a || b) return a ? b ? 0 : -j : i;
        // Signs differ?
        if (i != j) return i;
        a = i < 0;
        b = k == l;
        // Either Infinity?
        if (!xc || !yc) return b ? 0 : !xc ^ a ? 1 : -1;
        // Compare exponents.
        if (!b) return k > l ^ a ? 1 : -1;
        j = (k = xc.length) < (l = yc.length) ? k : l;
        // Compare digit by digit.
        for(i = 0; i < j; i++)if (xc[i] != yc[i]) return xc[i] > yc[i] ^ a ? 1 : -1;
        // Compare lengths.
        return k == l ? 0 : k > l ^ a ? 1 : -1;
    }
    /*
   * Check that n is a primitive number, an integer, and in range, otherwise throw.
   */ function intCheck(n, min, max, name) {
        if (n < min || n > max || n !== mathfloor(n)) throw Error(bignumberError + (name || "Argument") + (typeof n == "number" ? n < min || n > max ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(n));
    }
    // Assumes finite n.
    function isOdd(n) {
        var k = n.c.length - 1;
        return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;
    }
    function toExponential(str, e) {
        return (str.length > 1 ? str.charAt(0) + "." + str.slice(1) : str) + (e < 0 ? "e" : "e+") + e;
    }
    function toFixedPoint(str, e, z) {
        var len, zs;
        // Negative exponent?
        if (e < 0) {
            // Prepend zeros.
            for(zs = z + "."; ++e; zs += z);
            str = zs + str;
        // Positive exponent
        } else {
            len = str.length;
            // Append zeros.
            if (++e > len) {
                for(zs = z, e -= len; --e; zs += z);
                str += zs;
            } else if (e < len) str = str.slice(0, e) + "." + str.slice(e);
        }
        return str;
    }
    // EXPORT
    BigNumber = clone();
    BigNumber["default"] = BigNumber.BigNumber = BigNumber;
    // AMD.
    if (typeof define == "function" && define.amd) define(function() {
        return BigNumber;
    });
    else if (0, module.exports) module.exports = BigNumber;
    else {
        if (!globalObject) globalObject = typeof self != "undefined" && self ? self : window;
        globalObject.BigNumber = BigNumber;
    }
})(this);

},{}],"fc4Em":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Create a QR code from a Solana Pay URL.
 *
 * @param url - The URL to encode in the QR code.
 * @param size - Size of canvas in `px`.
 * @param background - Background color for QR code.
 * @param color - Color for QR code pattern.
 */ parcelHelpers.export(exports, "createQR", ()=>createQR);
/** @ignore */ parcelHelpers.export(exports, "createQROptions", ()=>createQROptions);
var _qrCodeStyling = require("@solana/qr-code-styling");
var _qrCodeStylingDefault = parcelHelpers.interopDefault(_qrCodeStyling);
function createQR(url, size = 512, background = "white", color = "black") {
    return new (0, _qrCodeStylingDefault.default)(createQROptions(url, size, background, color));
}
function createQROptions(url, size = 512, background = "white", color = "black") {
    return {
        type: "svg",
        width: size,
        height: size,
        data: url,
        margin: 16,
        qrOptions: {
            typeNumber: 0,
            mode: "Byte",
            errorCorrectionLevel: "Q"
        },
        backgroundOptions: {
            color: background
        },
        dotsOptions: {
            type: "extra-rounded",
            color
        },
        cornersSquareOptions: {
            type: "extra-rounded",
            color
        },
        cornersDotOptions: {
            type: "square",
            color
        },
        imageOptions: {
            hideBackgroundDots: true,
            imageSize: 0.15,
            margin: 8
        },
        image: `data:image/svg+xml;utf8,<svg fill="${encodeURIComponent(color)}" height="16" viewBox="0 0 16 14" width="16" xmlns="http://www.w3.org/2000/svg"><path d="m15.9176 11.038-2.6413 2.7713c-.0574.0602-.1269.1082-.2041.141s-.1604.0497-.2446.0497h-12.520966c-.059744 0-.118187-.0171-.168147-.0491-.0499596-.0321-.0892609-.0777-.1130745-.1313-.02381372-.0536-.03110249-.1129-.02097081-.1705.01013171-.0576.03724251-.111.07800141-.1538l2.6432769-2.7713c.05726-.06.12651-.1079.20346-.1407s.15996-.0498.2439-.05h12.52032c.0597 0 .1182.0171.1681.0492.05.032.0893.0776.1131.1313.0238.0536.0311.1128.021.1704-.0102.0576-.0373.1111-.078.1538zm-2.6413-5.58067c-.0574-.0602-.1269-.1082-.2041-.141s-.1604-.04971-.2446-.04966h-12.520966c-.059744 0-.118187.01708-.168147.04913-.0499596.03205-.0892609.07768-.1130745.13129-.02381372.0536-.03110249.11285-.02097081.17045.01013171.05761.03724251.11106.07800141.15379l2.6432769 2.77134c.05726.06004.12651.10794.20346.14073.07695.0328.15996.04979.2439.04993h12.52032c.0597 0 .1182-.01707.1681-.04913.05-.03205.0893-.07768.1131-.13129.0238-.0536.0311-.11285.021-.17045-.0102-.05761-.0373-.11106-.078-.15379zm-12.969666-1.99066h12.520966c.0842.00004.1674-.01687.2446-.04967s.1467-.0808.2041-.141l2.6413-2.771333c.0407-.042736.0678-.096189.078-.153792.0101-.057603.0028-.116847-.021-.170453s-.0631-.0992385-.1131-.1312911c-.0499-.0320526-.1084-.04912893-.1681-.0491309h-12.52032c-.08394.00013975-.16695.0171339-.2439.0499304s-.1462.0806976-.20346.1407366l-2.6425955 2.771333c-.0407196.04269-.0678184.09609-.07797306.15363-.01015467.05754-.00292373.11673.02080606.17031.0237297.05358.0629266.09922.1127835.13132.049857.03211.108207.04928.167893.04941z"/></svg>`
    };
}

},{"@solana/qr-code-styling":"joYfc","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"joYfc":[function(require,module,exports) {
!function(t, e) {
    module.exports = e();
}(this, function() {
    return (()=>{
        var t = {
            192: (t, e)=>{
                var r, n, i = function() {
                    var t = function(t, e) {
                        var r = t, n = a[e], i = null, o = 0, u = null, v = [], w = {}, m = function(t, e) {
                            i = function(t) {
                                for(var e = new Array(t), r = 0; r < t; r += 1){
                                    e[r] = new Array(t);
                                    for(var n = 0; n < t; n += 1)e[r][n] = null;
                                }
                                return e;
                            }(o = 4 * r + 17), _(0, 0), _(o - 7, 0), _(0, o - 7), x(), b(), C(t, e), r >= 7 && S(t), null == u && (u = M(r, n, v)), A(u, e);
                        }, _ = function(t, e) {
                            for(var r = -1; r <= 7; r += 1)if (!(t + r <= -1 || o <= t + r)) for(var n = -1; n <= 7; n += 1)e + n <= -1 || o <= e + n || (i[t + r][e + n] = 0 <= r && r <= 6 && (0 == n || 6 == n) || 0 <= n && n <= 6 && (0 == r || 6 == r) || 2 <= r && r <= 4 && 2 <= n && n <= 4);
                        }, b = function() {
                            for(var t = 8; t < o - 8; t += 1)null == i[t][6] && (i[t][6] = t % 2 == 0);
                            for(var e = 8; e < o - 8; e += 1)null == i[6][e] && (i[6][e] = e % 2 == 0);
                        }, x = function() {
                            for(var t = s.getPatternPosition(r), e = 0; e < t.length; e += 1)for(var n = 0; n < t.length; n += 1){
                                var o = t[e], a = t[n];
                                if (null == i[o][a]) for(var u = -2; u <= 2; u += 1)for(var h = -2; h <= 2; h += 1)i[o + u][a + h] = -2 == u || 2 == u || -2 == h || 2 == h || 0 == u && 0 == h;
                            }
                        }, S = function(t) {
                            for(var e = s.getBCHTypeNumber(r), n = 0; n < 18; n += 1){
                                var a = !t && 1 == (e >> n & 1);
                                i[Math.floor(n / 3)][n % 3 + o - 8 - 3] = a;
                            }
                            for(n = 0; n < 18; n += 1)a = !t && 1 == (e >> n & 1), i[n % 3 + o - 8 - 3][Math.floor(n / 3)] = a;
                        }, C = function(t, e) {
                            for(var r = n << 3 | e, a = s.getBCHTypeInfo(r), u = 0; u < 15; u += 1){
                                var h = !t && 1 == (a >> u & 1);
                                u < 6 ? i[u][8] = h : u < 8 ? i[u + 1][8] = h : i[o - 15 + u][8] = h;
                            }
                            for(u = 0; u < 15; u += 1)h = !t && 1 == (a >> u & 1), u < 8 ? i[8][o - u - 1] = h : u < 9 ? i[8][15 - u - 1 + 1] = h : i[8][15 - u - 1] = h;
                            i[o - 8][8] = !t;
                        }, A = function(t, e) {
                            for(var r = -1, n = o - 1, a = 7, u = 0, h = s.getMaskFunction(e), c = o - 1; c > 0; c -= 2)for(6 == c && (c -= 1);;){
                                for(var l = 0; l < 2; l += 1)if (null == i[n][c - l]) {
                                    var d = !1;
                                    u < t.length && (d = 1 == (t[u] >>> a & 1)), h(n, c - l) && (d = !d), i[n][c - l] = d, -1 == (a -= 1) && (u += 1, a = 7);
                                }
                                if ((n += r) < 0 || o <= n) {
                                    n -= r, r = -r;
                                    break;
                                }
                            }
                        }, M = function(t, e, r) {
                            for(var n = c.getRSBlocks(t, e), i = l(), o = 0; o < r.length; o += 1){
                                var a = r[o];
                                i.put(a.getMode(), 4), i.put(a.getLength(), s.getLengthInBits(a.getMode(), t)), a.write(i);
                            }
                            var u = 0;
                            for(o = 0; o < n.length; o += 1)u += n[o].dataCount;
                            if (i.getLengthInBits() > 8 * u) throw "code length overflow. (" + i.getLengthInBits() + ">" + 8 * u + ")";
                            for(i.getLengthInBits() + 4 <= 8 * u && i.put(0, 4); i.getLengthInBits() % 8 != 0;)i.putBit(!1);
                            for(; !(i.getLengthInBits() >= 8 * u || (i.put(236, 8), i.getLengthInBits() >= 8 * u));)i.put(17, 8);
                            return function(t, e) {
                                for(var r = 0, n = 0, i = 0, o = new Array(e.length), a = new Array(e.length), u = 0; u < e.length; u += 1){
                                    var c = e[u].dataCount, l = e[u].totalCount - c;
                                    n = Math.max(n, c), i = Math.max(i, l), o[u] = new Array(c);
                                    for(var d = 0; d < o[u].length; d += 1)o[u][d] = 255 & t.getBuffer()[d + r];
                                    r += c;
                                    var f = s.getErrorCorrectPolynomial(l), g = h(o[u], f.getLength() - 1).mod(f);
                                    for(a[u] = new Array(f.getLength() - 1), d = 0; d < a[u].length; d += 1){
                                        var p = d + g.getLength() - a[u].length;
                                        a[u][d] = p >= 0 ? g.getAt(p) : 0;
                                    }
                                }
                                var v = 0;
                                for(d = 0; d < e.length; d += 1)v += e[d].totalCount;
                                var w = new Array(v), y = 0;
                                for(d = 0; d < n; d += 1)for(u = 0; u < e.length; u += 1)d < o[u].length && (w[y] = o[u][d], y += 1);
                                for(d = 0; d < i; d += 1)for(u = 0; u < e.length; u += 1)d < a[u].length && (w[y] = a[u][d], y += 1);
                                return w;
                            }(i, n);
                        };
                        w.addData = function(t, e) {
                            var r = null;
                            switch(e = e || "Byte"){
                                case "Numeric":
                                    r = d(t);
                                    break;
                                case "Alphanumeric":
                                    r = f(t);
                                    break;
                                case "Byte":
                                    r = g(t);
                                    break;
                                case "Kanji":
                                    r = p(t);
                                    break;
                                default:
                                    throw "mode:" + e;
                            }
                            v.push(r), u = null;
                        }, w.isDark = function(t, e) {
                            if (t < 0 || o <= t || e < 0 || o <= e) throw t + "," + e;
                            return i[t][e];
                        }, w.getModuleCount = function() {
                            return o;
                        }, w.make = function() {
                            if (r < 1) {
                                for(var t = 1; t < 40; t++){
                                    for(var e = c.getRSBlocks(t, n), i = l(), o = 0; o < v.length; o++){
                                        var a = v[o];
                                        i.put(a.getMode(), 4), i.put(a.getLength(), s.getLengthInBits(a.getMode(), t)), a.write(i);
                                    }
                                    var u = 0;
                                    for(o = 0; o < e.length; o++)u += e[o].dataCount;
                                    if (i.getLengthInBits() <= 8 * u) break;
                                }
                                r = t;
                            }
                            m(!1, function() {
                                for(var t = 0, e = 0, r = 0; r < 8; r += 1){
                                    m(!0, r);
                                    var n = s.getLostPoint(w);
                                    (0 == r || t > n) && (t = n, e = r);
                                }
                                return e;
                            }());
                        }, w.createTableTag = function(t, e) {
                            t = t || 2;
                            var r = "";
                            r += '<table style="', r += " border-width: 0px; border-style: none;", r += " border-collapse: collapse;", r += " padding: 0px; margin: " + (e = void 0 === e ? 4 * t : e) + "px;", r += '">', r += "<tbody>";
                            for(var n = 0; n < w.getModuleCount(); n += 1){
                                r += "<tr>";
                                for(var i = 0; i < w.getModuleCount(); i += 1)r += '<td style="', r += " border-width: 0px; border-style: none;", r += " border-collapse: collapse;", r += " padding: 0px; margin: 0px;", r += " width: " + t + "px;", r += " height: " + t + "px;", r += " background-color: ", r += w.isDark(n, i) ? "#000000" : "#ffffff", r += ";", r += '"/>';
                                r += "</tr>";
                            }
                            return (r += "</tbody>") + "</table>";
                        }, w.createSvgTag = function(t, e, r, n) {
                            var i = {};
                            "object" == typeof arguments[0] && (t = (i = arguments[0]).cellSize, e = i.margin, r = i.alt, n = i.title), t = t || 2, e = void 0 === e ? 4 * t : e, (r = "string" == typeof r ? {
                                text: r
                            } : r || {}).text = r.text || null, r.id = r.text ? r.id || "qrcode-description" : null, (n = "string" == typeof n ? {
                                text: n
                            } : n || {}).text = n.text || null, n.id = n.text ? n.id || "qrcode-title" : null;
                            var o, a, s, u, h = w.getModuleCount() * t + 2 * e, c = "";
                            for(u = "l" + t + ",0 0," + t + " -" + t + ",0 0,-" + t + "z ", c += '<svg version="1.1" xmlns="http://www.w3.org/2000/svg"', c += i.scalable ? "" : ' width="' + h + 'px" height="' + h + 'px"', c += ' viewBox="0 0 ' + h + " " + h + '" ', c += ' preserveAspectRatio="xMinYMin meet"', c += n.text || r.text ? ' role="img" aria-labelledby="' + k([
                                n.id,
                                r.id
                            ].join(" ").trim()) + '"' : "", c += ">", c += n.text ? '<title id="' + k(n.id) + '">' + k(n.text) + "</title>" : "", c += r.text ? '<description id="' + k(r.id) + '">' + k(r.text) + "</description>" : "", c += '<rect width="100%" height="100%" fill="white" cx="0" cy="0"/>', c += '<path d="', a = 0; a < w.getModuleCount(); a += 1)for(s = a * t + e, o = 0; o < w.getModuleCount(); o += 1)w.isDark(a, o) && (c += "M" + (o * t + e) + "," + s + u);
                            return (c += '" stroke="transparent" fill="black"/>') + "</svg>";
                        }, w.createDataURL = function(t, e) {
                            t = t || 2, e = void 0 === e ? 4 * t : e;
                            var r = w.getModuleCount() * t + 2 * e, n = e, i = r - e;
                            return y(r, r, function(e, r) {
                                if (n <= e && e < i && n <= r && r < i) {
                                    var o = Math.floor((e - n) / t), a = Math.floor((r - n) / t);
                                    return w.isDark(a, o) ? 0 : 1;
                                }
                                return 1;
                            });
                        }, w.createImgTag = function(t, e, r) {
                            t = t || 2, e = void 0 === e ? 4 * t : e;
                            var n = w.getModuleCount() * t + 2 * e, i = "";
                            return i += "<img", i += ' src="', i += w.createDataURL(t, e), i += '"', i += ' width="', i += n, i += '"', i += ' height="', i += n, i += '"', r && (i += ' alt="', i += k(r), i += '"'), i + "/>";
                        };
                        var k = function(t) {
                            for(var e = "", r = 0; r < t.length; r += 1){
                                var n = t.charAt(r);
                                switch(n){
                                    case "<":
                                        e += "&lt;";
                                        break;
                                    case ">":
                                        e += "&gt;";
                                        break;
                                    case "&":
                                        e += "&amp;";
                                        break;
                                    case '"':
                                        e += "&quot;";
                                        break;
                                    default:
                                        e += n;
                                }
                            }
                            return e;
                        };
                        return w.createASCII = function(t, e) {
                            if ((t = t || 1) < 2) return function(t) {
                                t = void 0 === t ? 2 : t;
                                var e, r, n, i, o, a = 1 * w.getModuleCount() + 2 * t, s = t, u = a - t, h = {
                                    "\u2588\u2588": "\u2588",
                                    "\u2588 ": "\u2580",
                                    " \u2588": "\u2584",
                                    "  ": " "
                                }, c = {
                                    "\u2588\u2588": "\u2580",
                                    "\u2588 ": "\u2580",
                                    " \u2588": " ",
                                    "  ": " "
                                }, l = "";
                                for(e = 0; e < a; e += 2){
                                    for(n = Math.floor((e - s) / 1), i = Math.floor((e + 1 - s) / 1), r = 0; r < a; r += 1)o = "\u2588", s <= r && r < u && s <= e && e < u && w.isDark(n, Math.floor((r - s) / 1)) && (o = " "), s <= r && r < u && s <= e + 1 && e + 1 < u && w.isDark(i, Math.floor((r - s) / 1)) ? o += " " : o += "\u2588", l += t < 1 && e + 1 >= u ? c[o] : h[o];
                                    l += "\n";
                                }
                                return a % 2 && t > 0 ? l.substring(0, l.length - a - 1) + Array(a + 1).join("\u2580") : l.substring(0, l.length - 1);
                            }(e);
                            t -= 1, e = void 0 === e ? 2 * t : e;
                            var r, n, i, o, a = w.getModuleCount() * t + 2 * e, s = e, u = a - e, h = Array(t + 1).join("\u2588\u2588"), c = Array(t + 1).join("  "), l = "", d = "";
                            for(r = 0; r < a; r += 1){
                                for(i = Math.floor((r - s) / t), d = "", n = 0; n < a; n += 1)o = 1, s <= n && n < u && s <= r && r < u && w.isDark(i, Math.floor((n - s) / t)) && (o = 0), d += o ? h : c;
                                for(i = 0; i < t; i += 1)l += d + "\n";
                            }
                            return l.substring(0, l.length - 1);
                        }, w.renderTo2dContext = function(t, e) {
                            e = e || 2;
                            for(var r = w.getModuleCount(), n = 0; n < r; n++)for(var i = 0; i < r; i++)t.fillStyle = w.isDark(n, i) ? "black" : "white", t.fillRect(n * e, i * e, e, e);
                        }, w;
                    };
                    t.stringToBytes = (t.stringToBytesFuncs = {
                        default: function(t) {
                            for(var e = [], r = 0; r < t.length; r += 1){
                                var n = t.charCodeAt(r);
                                e.push(255 & n);
                            }
                            return e;
                        }
                    }).default, t.createStringToBytes = function(t, e) {
                        var r = function() {
                            for(var r = w(t), n = function() {
                                var t = r.read();
                                if (-1 == t) throw "eof";
                                return t;
                            }, i = 0, o = {};;){
                                var a = r.read();
                                if (-1 == a) break;
                                var s = n(), u = n() << 8 | n();
                                o[String.fromCharCode(a << 8 | s)] = u, i += 1;
                            }
                            if (i != e) throw i + " != " + e;
                            return o;
                        }(), n = "?".charCodeAt(0);
                        return function(t) {
                            for(var e = [], i = 0; i < t.length; i += 1){
                                var o = t.charCodeAt(i);
                                if (o < 128) e.push(o);
                                else {
                                    var a = r[t.charAt(i)];
                                    "number" == typeof a ? (255 & a) == a ? e.push(a) : (e.push(a >>> 8), e.push(255 & a)) : e.push(n);
                                }
                            }
                            return e;
                        };
                    };
                    var e, r, n, i, o, a = {
                        L: 1,
                        M: 0,
                        Q: 3,
                        H: 2
                    }, s = (e = [
                        [],
                        [
                            6,
                            18
                        ],
                        [
                            6,
                            22
                        ],
                        [
                            6,
                            26
                        ],
                        [
                            6,
                            30
                        ],
                        [
                            6,
                            34
                        ],
                        [
                            6,
                            22,
                            38
                        ],
                        [
                            6,
                            24,
                            42
                        ],
                        [
                            6,
                            26,
                            46
                        ],
                        [
                            6,
                            28,
                            50
                        ],
                        [
                            6,
                            30,
                            54
                        ],
                        [
                            6,
                            32,
                            58
                        ],
                        [
                            6,
                            34,
                            62
                        ],
                        [
                            6,
                            26,
                            46,
                            66
                        ],
                        [
                            6,
                            26,
                            48,
                            70
                        ],
                        [
                            6,
                            26,
                            50,
                            74
                        ],
                        [
                            6,
                            30,
                            54,
                            78
                        ],
                        [
                            6,
                            30,
                            56,
                            82
                        ],
                        [
                            6,
                            30,
                            58,
                            86
                        ],
                        [
                            6,
                            34,
                            62,
                            90
                        ],
                        [
                            6,
                            28,
                            50,
                            72,
                            94
                        ],
                        [
                            6,
                            26,
                            50,
                            74,
                            98
                        ],
                        [
                            6,
                            30,
                            54,
                            78,
                            102
                        ],
                        [
                            6,
                            28,
                            54,
                            80,
                            106
                        ],
                        [
                            6,
                            32,
                            58,
                            84,
                            110
                        ],
                        [
                            6,
                            30,
                            58,
                            86,
                            114
                        ],
                        [
                            6,
                            34,
                            62,
                            90,
                            118
                        ],
                        [
                            6,
                            26,
                            50,
                            74,
                            98,
                            122
                        ],
                        [
                            6,
                            30,
                            54,
                            78,
                            102,
                            126
                        ],
                        [
                            6,
                            26,
                            52,
                            78,
                            104,
                            130
                        ],
                        [
                            6,
                            30,
                            56,
                            82,
                            108,
                            134
                        ],
                        [
                            6,
                            34,
                            60,
                            86,
                            112,
                            138
                        ],
                        [
                            6,
                            30,
                            58,
                            86,
                            114,
                            142
                        ],
                        [
                            6,
                            34,
                            62,
                            90,
                            118,
                            146
                        ],
                        [
                            6,
                            30,
                            54,
                            78,
                            102,
                            126,
                            150
                        ],
                        [
                            6,
                            24,
                            50,
                            76,
                            102,
                            128,
                            154
                        ],
                        [
                            6,
                            28,
                            54,
                            80,
                            106,
                            132,
                            158
                        ],
                        [
                            6,
                            32,
                            58,
                            84,
                            110,
                            136,
                            162
                        ],
                        [
                            6,
                            26,
                            54,
                            82,
                            110,
                            138,
                            166
                        ],
                        [
                            6,
                            30,
                            58,
                            86,
                            114,
                            142,
                            170
                        ]
                    ], r = 1335, n = 7973, o = function(t) {
                        for(var e = 0; 0 != t;)e += 1, t >>>= 1;
                        return e;
                    }, (i = {}).getBCHTypeInfo = function(t) {
                        for(var e = t << 10; o(e) - o(r) >= 0;)e ^= r << o(e) - o(r);
                        return 21522 ^ (t << 10 | e);
                    }, i.getBCHTypeNumber = function(t) {
                        for(var e = t << 12; o(e) - o(n) >= 0;)e ^= n << o(e) - o(n);
                        return t << 12 | e;
                    }, i.getPatternPosition = function(t) {
                        return e[t - 1];
                    }, i.getMaskFunction = function(t) {
                        switch(t){
                            case 0:
                                return function(t, e) {
                                    return (t + e) % 2 == 0;
                                };
                            case 1:
                                return function(t, e) {
                                    return t % 2 == 0;
                                };
                            case 2:
                                return function(t, e) {
                                    return e % 3 == 0;
                                };
                            case 3:
                                return function(t, e) {
                                    return (t + e) % 3 == 0;
                                };
                            case 4:
                                return function(t, e) {
                                    return (Math.floor(t / 2) + Math.floor(e / 3)) % 2 == 0;
                                };
                            case 5:
                                return function(t, e) {
                                    return t * e % 2 + t * e % 3 == 0;
                                };
                            case 6:
                                return function(t, e) {
                                    return (t * e % 2 + t * e % 3) % 2 == 0;
                                };
                            case 7:
                                return function(t, e) {
                                    return (t * e % 3 + (t + e) % 2) % 2 == 0;
                                };
                            default:
                                throw "bad maskPattern:" + t;
                        }
                    }, i.getErrorCorrectPolynomial = function(t) {
                        for(var e = h([
                            1
                        ], 0), r = 0; r < t; r += 1)e = e.multiply(h([
                            1,
                            u.gexp(r)
                        ], 0));
                        return e;
                    }, i.getLengthInBits = function(t, e) {
                        if (1 <= e && e < 10) switch(t){
                            case 1:
                                return 10;
                            case 2:
                                return 9;
                            case 4:
                            case 8:
                                return 8;
                            default:
                                throw "mode:" + t;
                        }
                        else if (e < 27) switch(t){
                            case 1:
                                return 12;
                            case 2:
                                return 11;
                            case 4:
                                return 16;
                            case 8:
                                return 10;
                            default:
                                throw "mode:" + t;
                        }
                        else {
                            if (!(e < 41)) throw "type:" + e;
                            switch(t){
                                case 1:
                                    return 14;
                                case 2:
                                    return 13;
                                case 4:
                                    return 16;
                                case 8:
                                    return 12;
                                default:
                                    throw "mode:" + t;
                            }
                        }
                    }, i.getLostPoint = function(t) {
                        for(var e = t.getModuleCount(), r = 0, n = 0; n < e; n += 1)for(var i = 0; i < e; i += 1){
                            for(var o = 0, a = t.isDark(n, i), s = -1; s <= 1; s += 1)if (!(n + s < 0 || e <= n + s)) for(var u = -1; u <= 1; u += 1)i + u < 0 || e <= i + u || 0 == s && 0 == u || a == t.isDark(n + s, i + u) && (o += 1);
                            o > 5 && (r += 3 + o - 5);
                        }
                        for(n = 0; n < e - 1; n += 1)for(i = 0; i < e - 1; i += 1){
                            var h = 0;
                            t.isDark(n, i) && (h += 1), t.isDark(n + 1, i) && (h += 1), t.isDark(n, i + 1) && (h += 1), t.isDark(n + 1, i + 1) && (h += 1), 0 != h && 4 != h || (r += 3);
                        }
                        for(n = 0; n < e; n += 1)for(i = 0; i < e - 6; i += 1)t.isDark(n, i) && !t.isDark(n, i + 1) && t.isDark(n, i + 2) && t.isDark(n, i + 3) && t.isDark(n, i + 4) && !t.isDark(n, i + 5) && t.isDark(n, i + 6) && (r += 40);
                        for(i = 0; i < e; i += 1)for(n = 0; n < e - 6; n += 1)t.isDark(n, i) && !t.isDark(n + 1, i) && t.isDark(n + 2, i) && t.isDark(n + 3, i) && t.isDark(n + 4, i) && !t.isDark(n + 5, i) && t.isDark(n + 6, i) && (r += 40);
                        var c = 0;
                        for(i = 0; i < e; i += 1)for(n = 0; n < e; n += 1)t.isDark(n, i) && (c += 1);
                        return r + Math.abs(100 * c / e / e - 50) / 5 * 10;
                    }, i), u = function() {
                        for(var t = new Array(256), e = new Array(256), r = 0; r < 8; r += 1)t[r] = 1 << r;
                        for(r = 8; r < 256; r += 1)t[r] = t[r - 4] ^ t[r - 5] ^ t[r - 6] ^ t[r - 8];
                        for(r = 0; r < 255; r += 1)e[t[r]] = r;
                        return {
                            glog: function(t) {
                                if (t < 1) throw "glog(" + t + ")";
                                return e[t];
                            },
                            gexp: function(e) {
                                for(; e < 0;)e += 255;
                                for(; e >= 256;)e -= 255;
                                return t[e];
                            }
                        };
                    }();
                    function h(t, e) {
                        if (void 0 === t.length) throw t.length + "/" + e;
                        var r = function() {
                            for(var r = 0; r < t.length && 0 == t[r];)r += 1;
                            for(var n = new Array(t.length - r + e), i = 0; i < t.length - r; i += 1)n[i] = t[i + r];
                            return n;
                        }(), n = {
                            getAt: function(t) {
                                return r[t];
                            },
                            getLength: function() {
                                return r.length;
                            },
                            multiply: function(t) {
                                for(var e = new Array(n.getLength() + t.getLength() - 1), r = 0; r < n.getLength(); r += 1)for(var i = 0; i < t.getLength(); i += 1)e[r + i] ^= u.gexp(u.glog(n.getAt(r)) + u.glog(t.getAt(i)));
                                return h(e, 0);
                            },
                            mod: function(t) {
                                if (n.getLength() - t.getLength() < 0) return n;
                                for(var e = u.glog(n.getAt(0)) - u.glog(t.getAt(0)), r = new Array(n.getLength()), i = 0; i < n.getLength(); i += 1)r[i] = n.getAt(i);
                                for(i = 0; i < t.getLength(); i += 1)r[i] ^= u.gexp(u.glog(t.getAt(i)) + e);
                                return h(r, 0).mod(t);
                            }
                        };
                        return n;
                    }
                    var c = function() {
                        var t = [
                            [
                                1,
                                26,
                                19
                            ],
                            [
                                1,
                                26,
                                16
                            ],
                            [
                                1,
                                26,
                                13
                            ],
                            [
                                1,
                                26,
                                9
                            ],
                            [
                                1,
                                44,
                                34
                            ],
                            [
                                1,
                                44,
                                28
                            ],
                            [
                                1,
                                44,
                                22
                            ],
                            [
                                1,
                                44,
                                16
                            ],
                            [
                                1,
                                70,
                                55
                            ],
                            [
                                1,
                                70,
                                44
                            ],
                            [
                                2,
                                35,
                                17
                            ],
                            [
                                2,
                                35,
                                13
                            ],
                            [
                                1,
                                100,
                                80
                            ],
                            [
                                2,
                                50,
                                32
                            ],
                            [
                                2,
                                50,
                                24
                            ],
                            [
                                4,
                                25,
                                9
                            ],
                            [
                                1,
                                134,
                                108
                            ],
                            [
                                2,
                                67,
                                43
                            ],
                            [
                                2,
                                33,
                                15,
                                2,
                                34,
                                16
                            ],
                            [
                                2,
                                33,
                                11,
                                2,
                                34,
                                12
                            ],
                            [
                                2,
                                86,
                                68
                            ],
                            [
                                4,
                                43,
                                27
                            ],
                            [
                                4,
                                43,
                                19
                            ],
                            [
                                4,
                                43,
                                15
                            ],
                            [
                                2,
                                98,
                                78
                            ],
                            [
                                4,
                                49,
                                31
                            ],
                            [
                                2,
                                32,
                                14,
                                4,
                                33,
                                15
                            ],
                            [
                                4,
                                39,
                                13,
                                1,
                                40,
                                14
                            ],
                            [
                                2,
                                121,
                                97
                            ],
                            [
                                2,
                                60,
                                38,
                                2,
                                61,
                                39
                            ],
                            [
                                4,
                                40,
                                18,
                                2,
                                41,
                                19
                            ],
                            [
                                4,
                                40,
                                14,
                                2,
                                41,
                                15
                            ],
                            [
                                2,
                                146,
                                116
                            ],
                            [
                                3,
                                58,
                                36,
                                2,
                                59,
                                37
                            ],
                            [
                                4,
                                36,
                                16,
                                4,
                                37,
                                17
                            ],
                            [
                                4,
                                36,
                                12,
                                4,
                                37,
                                13
                            ],
                            [
                                2,
                                86,
                                68,
                                2,
                                87,
                                69
                            ],
                            [
                                4,
                                69,
                                43,
                                1,
                                70,
                                44
                            ],
                            [
                                6,
                                43,
                                19,
                                2,
                                44,
                                20
                            ],
                            [
                                6,
                                43,
                                15,
                                2,
                                44,
                                16
                            ],
                            [
                                4,
                                101,
                                81
                            ],
                            [
                                1,
                                80,
                                50,
                                4,
                                81,
                                51
                            ],
                            [
                                4,
                                50,
                                22,
                                4,
                                51,
                                23
                            ],
                            [
                                3,
                                36,
                                12,
                                8,
                                37,
                                13
                            ],
                            [
                                2,
                                116,
                                92,
                                2,
                                117,
                                93
                            ],
                            [
                                6,
                                58,
                                36,
                                2,
                                59,
                                37
                            ],
                            [
                                4,
                                46,
                                20,
                                6,
                                47,
                                21
                            ],
                            [
                                7,
                                42,
                                14,
                                4,
                                43,
                                15
                            ],
                            [
                                4,
                                133,
                                107
                            ],
                            [
                                8,
                                59,
                                37,
                                1,
                                60,
                                38
                            ],
                            [
                                8,
                                44,
                                20,
                                4,
                                45,
                                21
                            ],
                            [
                                12,
                                33,
                                11,
                                4,
                                34,
                                12
                            ],
                            [
                                3,
                                145,
                                115,
                                1,
                                146,
                                116
                            ],
                            [
                                4,
                                64,
                                40,
                                5,
                                65,
                                41
                            ],
                            [
                                11,
                                36,
                                16,
                                5,
                                37,
                                17
                            ],
                            [
                                11,
                                36,
                                12,
                                5,
                                37,
                                13
                            ],
                            [
                                5,
                                109,
                                87,
                                1,
                                110,
                                88
                            ],
                            [
                                5,
                                65,
                                41,
                                5,
                                66,
                                42
                            ],
                            [
                                5,
                                54,
                                24,
                                7,
                                55,
                                25
                            ],
                            [
                                11,
                                36,
                                12,
                                7,
                                37,
                                13
                            ],
                            [
                                5,
                                122,
                                98,
                                1,
                                123,
                                99
                            ],
                            [
                                7,
                                73,
                                45,
                                3,
                                74,
                                46
                            ],
                            [
                                15,
                                43,
                                19,
                                2,
                                44,
                                20
                            ],
                            [
                                3,
                                45,
                                15,
                                13,
                                46,
                                16
                            ],
                            [
                                1,
                                135,
                                107,
                                5,
                                136,
                                108
                            ],
                            [
                                10,
                                74,
                                46,
                                1,
                                75,
                                47
                            ],
                            [
                                1,
                                50,
                                22,
                                15,
                                51,
                                23
                            ],
                            [
                                2,
                                42,
                                14,
                                17,
                                43,
                                15
                            ],
                            [
                                5,
                                150,
                                120,
                                1,
                                151,
                                121
                            ],
                            [
                                9,
                                69,
                                43,
                                4,
                                70,
                                44
                            ],
                            [
                                17,
                                50,
                                22,
                                1,
                                51,
                                23
                            ],
                            [
                                2,
                                42,
                                14,
                                19,
                                43,
                                15
                            ],
                            [
                                3,
                                141,
                                113,
                                4,
                                142,
                                114
                            ],
                            [
                                3,
                                70,
                                44,
                                11,
                                71,
                                45
                            ],
                            [
                                17,
                                47,
                                21,
                                4,
                                48,
                                22
                            ],
                            [
                                9,
                                39,
                                13,
                                16,
                                40,
                                14
                            ],
                            [
                                3,
                                135,
                                107,
                                5,
                                136,
                                108
                            ],
                            [
                                3,
                                67,
                                41,
                                13,
                                68,
                                42
                            ],
                            [
                                15,
                                54,
                                24,
                                5,
                                55,
                                25
                            ],
                            [
                                15,
                                43,
                                15,
                                10,
                                44,
                                16
                            ],
                            [
                                4,
                                144,
                                116,
                                4,
                                145,
                                117
                            ],
                            [
                                17,
                                68,
                                42
                            ],
                            [
                                17,
                                50,
                                22,
                                6,
                                51,
                                23
                            ],
                            [
                                19,
                                46,
                                16,
                                6,
                                47,
                                17
                            ],
                            [
                                2,
                                139,
                                111,
                                7,
                                140,
                                112
                            ],
                            [
                                17,
                                74,
                                46
                            ],
                            [
                                7,
                                54,
                                24,
                                16,
                                55,
                                25
                            ],
                            [
                                34,
                                37,
                                13
                            ],
                            [
                                4,
                                151,
                                121,
                                5,
                                152,
                                122
                            ],
                            [
                                4,
                                75,
                                47,
                                14,
                                76,
                                48
                            ],
                            [
                                11,
                                54,
                                24,
                                14,
                                55,
                                25
                            ],
                            [
                                16,
                                45,
                                15,
                                14,
                                46,
                                16
                            ],
                            [
                                6,
                                147,
                                117,
                                4,
                                148,
                                118
                            ],
                            [
                                6,
                                73,
                                45,
                                14,
                                74,
                                46
                            ],
                            [
                                11,
                                54,
                                24,
                                16,
                                55,
                                25
                            ],
                            [
                                30,
                                46,
                                16,
                                2,
                                47,
                                17
                            ],
                            [
                                8,
                                132,
                                106,
                                4,
                                133,
                                107
                            ],
                            [
                                8,
                                75,
                                47,
                                13,
                                76,
                                48
                            ],
                            [
                                7,
                                54,
                                24,
                                22,
                                55,
                                25
                            ],
                            [
                                22,
                                45,
                                15,
                                13,
                                46,
                                16
                            ],
                            [
                                10,
                                142,
                                114,
                                2,
                                143,
                                115
                            ],
                            [
                                19,
                                74,
                                46,
                                4,
                                75,
                                47
                            ],
                            [
                                28,
                                50,
                                22,
                                6,
                                51,
                                23
                            ],
                            [
                                33,
                                46,
                                16,
                                4,
                                47,
                                17
                            ],
                            [
                                8,
                                152,
                                122,
                                4,
                                153,
                                123
                            ],
                            [
                                22,
                                73,
                                45,
                                3,
                                74,
                                46
                            ],
                            [
                                8,
                                53,
                                23,
                                26,
                                54,
                                24
                            ],
                            [
                                12,
                                45,
                                15,
                                28,
                                46,
                                16
                            ],
                            [
                                3,
                                147,
                                117,
                                10,
                                148,
                                118
                            ],
                            [
                                3,
                                73,
                                45,
                                23,
                                74,
                                46
                            ],
                            [
                                4,
                                54,
                                24,
                                31,
                                55,
                                25
                            ],
                            [
                                11,
                                45,
                                15,
                                31,
                                46,
                                16
                            ],
                            [
                                7,
                                146,
                                116,
                                7,
                                147,
                                117
                            ],
                            [
                                21,
                                73,
                                45,
                                7,
                                74,
                                46
                            ],
                            [
                                1,
                                53,
                                23,
                                37,
                                54,
                                24
                            ],
                            [
                                19,
                                45,
                                15,
                                26,
                                46,
                                16
                            ],
                            [
                                5,
                                145,
                                115,
                                10,
                                146,
                                116
                            ],
                            [
                                19,
                                75,
                                47,
                                10,
                                76,
                                48
                            ],
                            [
                                15,
                                54,
                                24,
                                25,
                                55,
                                25
                            ],
                            [
                                23,
                                45,
                                15,
                                25,
                                46,
                                16
                            ],
                            [
                                13,
                                145,
                                115,
                                3,
                                146,
                                116
                            ],
                            [
                                2,
                                74,
                                46,
                                29,
                                75,
                                47
                            ],
                            [
                                42,
                                54,
                                24,
                                1,
                                55,
                                25
                            ],
                            [
                                23,
                                45,
                                15,
                                28,
                                46,
                                16
                            ],
                            [
                                17,
                                145,
                                115
                            ],
                            [
                                10,
                                74,
                                46,
                                23,
                                75,
                                47
                            ],
                            [
                                10,
                                54,
                                24,
                                35,
                                55,
                                25
                            ],
                            [
                                19,
                                45,
                                15,
                                35,
                                46,
                                16
                            ],
                            [
                                17,
                                145,
                                115,
                                1,
                                146,
                                116
                            ],
                            [
                                14,
                                74,
                                46,
                                21,
                                75,
                                47
                            ],
                            [
                                29,
                                54,
                                24,
                                19,
                                55,
                                25
                            ],
                            [
                                11,
                                45,
                                15,
                                46,
                                46,
                                16
                            ],
                            [
                                13,
                                145,
                                115,
                                6,
                                146,
                                116
                            ],
                            [
                                14,
                                74,
                                46,
                                23,
                                75,
                                47
                            ],
                            [
                                44,
                                54,
                                24,
                                7,
                                55,
                                25
                            ],
                            [
                                59,
                                46,
                                16,
                                1,
                                47,
                                17
                            ],
                            [
                                12,
                                151,
                                121,
                                7,
                                152,
                                122
                            ],
                            [
                                12,
                                75,
                                47,
                                26,
                                76,
                                48
                            ],
                            [
                                39,
                                54,
                                24,
                                14,
                                55,
                                25
                            ],
                            [
                                22,
                                45,
                                15,
                                41,
                                46,
                                16
                            ],
                            [
                                6,
                                151,
                                121,
                                14,
                                152,
                                122
                            ],
                            [
                                6,
                                75,
                                47,
                                34,
                                76,
                                48
                            ],
                            [
                                46,
                                54,
                                24,
                                10,
                                55,
                                25
                            ],
                            [
                                2,
                                45,
                                15,
                                64,
                                46,
                                16
                            ],
                            [
                                17,
                                152,
                                122,
                                4,
                                153,
                                123
                            ],
                            [
                                29,
                                74,
                                46,
                                14,
                                75,
                                47
                            ],
                            [
                                49,
                                54,
                                24,
                                10,
                                55,
                                25
                            ],
                            [
                                24,
                                45,
                                15,
                                46,
                                46,
                                16
                            ],
                            [
                                4,
                                152,
                                122,
                                18,
                                153,
                                123
                            ],
                            [
                                13,
                                74,
                                46,
                                32,
                                75,
                                47
                            ],
                            [
                                48,
                                54,
                                24,
                                14,
                                55,
                                25
                            ],
                            [
                                42,
                                45,
                                15,
                                32,
                                46,
                                16
                            ],
                            [
                                20,
                                147,
                                117,
                                4,
                                148,
                                118
                            ],
                            [
                                40,
                                75,
                                47,
                                7,
                                76,
                                48
                            ],
                            [
                                43,
                                54,
                                24,
                                22,
                                55,
                                25
                            ],
                            [
                                10,
                                45,
                                15,
                                67,
                                46,
                                16
                            ],
                            [
                                19,
                                148,
                                118,
                                6,
                                149,
                                119
                            ],
                            [
                                18,
                                75,
                                47,
                                31,
                                76,
                                48
                            ],
                            [
                                34,
                                54,
                                24,
                                34,
                                55,
                                25
                            ],
                            [
                                20,
                                45,
                                15,
                                61,
                                46,
                                16
                            ]
                        ], e = function(t, e) {
                            var r = {};
                            return r.totalCount = t, r.dataCount = e, r;
                        }, r = {
                            getRSBlocks: function(r, n) {
                                var i = function(e, r) {
                                    switch(r){
                                        case a.L:
                                            return t[4 * (e - 1) + 0];
                                        case a.M:
                                            return t[4 * (e - 1) + 1];
                                        case a.Q:
                                            return t[4 * (e - 1) + 2];
                                        case a.H:
                                            return t[4 * (e - 1) + 3];
                                        default:
                                            return;
                                    }
                                }(r, n);
                                if (void 0 === i) throw "bad rs block @ typeNumber:" + r + "/errorCorrectionLevel:" + n;
                                for(var o = i.length / 3, s = [], u = 0; u < o; u += 1)for(var h = i[3 * u + 0], c = i[3 * u + 1], l = i[3 * u + 2], d = 0; d < h; d += 1)s.push(e(c, l));
                                return s;
                            }
                        };
                        return r;
                    }(), l = function() {
                        var t = [], e = 0, r = {
                            getBuffer: function() {
                                return t;
                            },
                            getAt: function(e) {
                                var r = Math.floor(e / 8);
                                return 1 == (t[r] >>> 7 - e % 8 & 1);
                            },
                            put: function(t, e) {
                                for(var n = 0; n < e; n += 1)r.putBit(1 == (t >>> e - n - 1 & 1));
                            },
                            getLengthInBits: function() {
                                return e;
                            },
                            putBit: function(r) {
                                var n = Math.floor(e / 8);
                                t.length <= n && t.push(0), r && (t[n] |= 128 >>> e % 8), e += 1;
                            }
                        };
                        return r;
                    }, d = function(t) {
                        var e = t, r = {
                            getMode: function() {
                                return 1;
                            },
                            getLength: function(t) {
                                return e.length;
                            },
                            write: function(t) {
                                for(var r = e, i = 0; i + 2 < r.length;)t.put(n(r.substring(i, i + 3)), 10), i += 3;
                                i < r.length && (r.length - i == 1 ? t.put(n(r.substring(i, i + 1)), 4) : r.length - i == 2 && t.put(n(r.substring(i, i + 2)), 7));
                            }
                        }, n = function(t) {
                            for(var e = 0, r = 0; r < t.length; r += 1)e = 10 * e + i(t.charAt(r));
                            return e;
                        }, i = function(t) {
                            if ("0" <= t && t <= "9") return t.charCodeAt(0) - "0".charCodeAt(0);
                            throw "illegal char :" + t;
                        };
                        return r;
                    }, f = function(t) {
                        var e = t, r = {
                            getMode: function() {
                                return 2;
                            },
                            getLength: function(t) {
                                return e.length;
                            },
                            write: function(t) {
                                for(var r = e, i = 0; i + 1 < r.length;)t.put(45 * n(r.charAt(i)) + n(r.charAt(i + 1)), 11), i += 2;
                                i < r.length && t.put(n(r.charAt(i)), 6);
                            }
                        }, n = function(t) {
                            if ("0" <= t && t <= "9") return t.charCodeAt(0) - "0".charCodeAt(0);
                            if ("A" <= t && t <= "Z") return t.charCodeAt(0) - "A".charCodeAt(0) + 10;
                            switch(t){
                                case " ":
                                    return 36;
                                case "$":
                                    return 37;
                                case "%":
                                    return 38;
                                case "*":
                                    return 39;
                                case "+":
                                    return 40;
                                case "-":
                                    return 41;
                                case ".":
                                    return 42;
                                case "/":
                                    return 43;
                                case ":":
                                    return 44;
                                default:
                                    throw "illegal char :" + t;
                            }
                        };
                        return r;
                    }, g = function(e) {
                        var r = t.stringToBytes(e);
                        return {
                            getMode: function() {
                                return 4;
                            },
                            getLength: function(t) {
                                return r.length;
                            },
                            write: function(t) {
                                for(var e = 0; e < r.length; e += 1)t.put(r[e], 8);
                            }
                        };
                    }, p = function(e) {
                        var r = t.stringToBytesFuncs.SJIS;
                        if (!r) throw "sjis not supported.";
                        !function(t, e) {
                            var n = r("\u53CB");
                            if (2 != n.length || 38726 != (n[0] << 8 | n[1])) throw "sjis not supported.";
                        }();
                        var n = r(e), i = {
                            getMode: function() {
                                return 8;
                            },
                            getLength: function(t) {
                                return ~~(n.length / 2);
                            },
                            write: function(t) {
                                for(var e = n, r = 0; r + 1 < e.length;){
                                    var i = (255 & e[r]) << 8 | 255 & e[r + 1];
                                    if (33088 <= i && i <= 40956) i -= 33088;
                                    else {
                                        if (!(57408 <= i && i <= 60351)) throw "illegal char at " + (r + 1) + "/" + i;
                                        i -= 49472;
                                    }
                                    i = 192 * (i >>> 8 & 255) + (255 & i), t.put(i, 13), r += 2;
                                }
                                if (r < e.length) throw "illegal char at " + (r + 1);
                            }
                        };
                        return i;
                    }, v = function() {
                        var t = [], e = {
                            writeByte: function(e) {
                                t.push(255 & e);
                            },
                            writeShort: function(t) {
                                e.writeByte(t), e.writeByte(t >>> 8);
                            },
                            writeBytes: function(t, r, n) {
                                r = r || 0, n = n || t.length;
                                for(var i = 0; i < n; i += 1)e.writeByte(t[i + r]);
                            },
                            writeString: function(t) {
                                for(var r = 0; r < t.length; r += 1)e.writeByte(t.charCodeAt(r));
                            },
                            toByteArray: function() {
                                return t;
                            },
                            toString: function() {
                                var e = "";
                                e += "[";
                                for(var r = 0; r < t.length; r += 1)r > 0 && (e += ","), e += t[r];
                                return e + "]";
                            }
                        };
                        return e;
                    }, w = function(t) {
                        var e = t, r = 0, n = 0, i = 0, o = {
                            read: function() {
                                for(; i < 8;){
                                    if (r >= e.length) {
                                        if (0 == i) return -1;
                                        throw "unexpected end of file./" + i;
                                    }
                                    var t = e.charAt(r);
                                    if (r += 1, "=" == t) return i = 0, -1;
                                    t.match(/^\s$/) || (n = n << 6 | a(t.charCodeAt(0)), i += 6);
                                }
                                var o = n >>> i - 8 & 255;
                                return i -= 8, o;
                            }
                        }, a = function(t) {
                            if (65 <= t && t <= 90) return t - 65;
                            if (97 <= t && t <= 122) return t - 97 + 26;
                            if (48 <= t && t <= 57) return t - 48 + 52;
                            if (43 == t) return 62;
                            if (47 == t) return 63;
                            throw "c:" + t;
                        };
                        return o;
                    }, y = function(t, e, r) {
                        for(var n = function(t, e) {
                            var r = t, n = e, i = new Array(t * e), o = {
                                setPixel: function(t, e, n) {
                                    i[e * r + t] = n;
                                },
                                write: function(t) {
                                    t.writeString("GIF87a"), t.writeShort(r), t.writeShort(n), t.writeByte(128), t.writeByte(0), t.writeByte(0), t.writeByte(0), t.writeByte(0), t.writeByte(0), t.writeByte(255), t.writeByte(255), t.writeByte(255), t.writeString(","), t.writeShort(0), t.writeShort(0), t.writeShort(r), t.writeShort(n), t.writeByte(0);
                                    var e = a(2);
                                    t.writeByte(2);
                                    for(var i = 0; e.length - i > 255;)t.writeByte(255), t.writeBytes(e, i, 255), i += 255;
                                    t.writeByte(e.length - i), t.writeBytes(e, i, e.length - i), t.writeByte(0), t.writeString(";");
                                }
                            }, a = function(t) {
                                for(var e = 1 << t, r = 1 + (1 << t), n = t + 1, o = s(), a = 0; a < e; a += 1)o.add(String.fromCharCode(a));
                                o.add(String.fromCharCode(e)), o.add(String.fromCharCode(r));
                                var u, h, c, l = v(), d = (u = l, h = 0, c = 0, {
                                    write: function(t, e) {
                                        if (t >>> e != 0) throw "length over";
                                        for(; h + e >= 8;)u.writeByte(255 & (t << h | c)), e -= 8 - h, t >>>= 8 - h, c = 0, h = 0;
                                        c |= t << h, h += e;
                                    },
                                    flush: function() {
                                        h > 0 && u.writeByte(c);
                                    }
                                });
                                d.write(e, n);
                                var f = 0, g = String.fromCharCode(i[f]);
                                for(f += 1; f < i.length;){
                                    var p = String.fromCharCode(i[f]);
                                    f += 1, o.contains(g + p) ? g += p : (d.write(o.indexOf(g), n), o.size() < 4095 && (o.size() == 1 << n && (n += 1), o.add(g + p)), g = p);
                                }
                                return d.write(o.indexOf(g), n), d.write(r, n), d.flush(), l.toByteArray();
                            }, s = function() {
                                var t = {}, e = 0, r = {
                                    add: function(n) {
                                        if (r.contains(n)) throw "dup key:" + n;
                                        t[n] = e, e += 1;
                                    },
                                    size: function() {
                                        return e;
                                    },
                                    indexOf: function(e) {
                                        return t[e];
                                    },
                                    contains: function(e) {
                                        return void 0 !== t[e];
                                    }
                                };
                                return r;
                            };
                            return o;
                        }(t, e), i = 0; i < e; i += 1)for(var o = 0; o < t; o += 1)n.setPixel(o, i, r(o, i));
                        var a = v();
                        n.write(a);
                        for(var s = function() {
                            var t = 0, e = 0, r = 0, n = "", i = {}, o = function(t) {
                                n += String.fromCharCode(a(63 & t));
                            }, a = function(t) {
                                if (t < 0) ;
                                else {
                                    if (t < 26) return 65 + t;
                                    if (t < 52) return t - 26 + 97;
                                    if (t < 62) return t - 52 + 48;
                                    if (62 == t) return 43;
                                    if (63 == t) return 47;
                                }
                                throw "n:" + t;
                            };
                            return i.writeByte = function(n) {
                                for(t = t << 8 | 255 & n, e += 8, r += 1; e >= 6;)o(t >>> e - 6), e -= 6;
                            }, i.flush = function() {
                                if (e > 0 && (o(t << 6 - e), t = 0, e = 0), r % 3 != 0) for(var i = 3 - r % 3, a = 0; a < i; a += 1)n += "=";
                            }, i.toString = function() {
                                return n;
                            }, i;
                        }(), u = a.toByteArray(), h = 0; h < u.length; h += 1)s.writeByte(u[h]);
                        return s.flush(), "data:image/gif;base64," + s;
                    };
                    return t;
                }();
                i.stringToBytesFuncs["UTF-8"] = function(t) {
                    return function(t) {
                        for(var e = [], r = 0; r < t.length; r++){
                            var n = t.charCodeAt(r);
                            n < 128 ? e.push(n) : n < 2048 ? e.push(192 | n >> 6, 128 | 63 & n) : n < 55296 || n >= 57344 ? e.push(224 | n >> 12, 128 | n >> 6 & 63, 128 | 63 & n) : (r++, n = 65536 + ((1023 & n) << 10 | 1023 & t.charCodeAt(r)), e.push(240 | n >> 18, 128 | n >> 12 & 63, 128 | n >> 6 & 63, 128 | 63 & n));
                        }
                        return e;
                    }(t);
                }, void 0 === (n = "function" == typeof (r = function() {
                    return i;
                }) ? r.apply(e, []) : r) || (t.exports = n);
            },
            676: (t, e, r)=>{
                "use strict";
                r.d(e, {
                    default: ()=>F
                });
                const n = "Numeric", i = "Alphanumeric", o = "Byte";
                var a = function() {
                    return a = Object.assign || function(t) {
                        for(var e, r = 1, n = arguments.length; r < n; r++)for(var i in e = arguments[r])Object.prototype.hasOwnProperty.call(e, i) && (t[i] = e[i]);
                        return t;
                    }, a.apply(this, arguments);
                }, s = function() {
                    for(var t = 0, e = 0, r = arguments.length; e < r; e++)t += arguments[e].length;
                    var n = Array(t), i = 0;
                    for(e = 0; e < r; e++)for(var o = arguments[e], a = 0, s = o.length; a < s; a++, i++)n[i] = o[a];
                    return n;
                }, u = function(t) {
                    return !!t && "object" == typeof t && !Array.isArray(t);
                };
                function h(t) {
                    for(var e = [], r = 1; r < arguments.length; r++)e[r - 1] = arguments[r];
                    if (!e.length) return t;
                    var n = e.shift();
                    return void 0 !== n && u(t) && u(n) ? (t = a({}, t), Object.keys(n).forEach(function(e) {
                        var r = t[e], i = n[e];
                        Array.isArray(r) && Array.isArray(i) ? t[e] = i : u(r) && u(i) ? t[e] = h(Object.assign({}, r), i) : t[e] = i;
                    }), h.apply(void 0, s([
                        t
                    ], e))) : t;
                }
                function c(t, e) {
                    var r = document.createElement("a");
                    r.download = e, r.href = t, document.body.appendChild(r), r.click(), document.body.removeChild(r);
                }
                var l = function(t, e, r, n) {
                    return new (r || (r = Promise))(function(i, o) {
                        function a(t) {
                            try {
                                u(n.next(t));
                            } catch (t) {
                                o(t);
                            }
                        }
                        function s(t) {
                            try {
                                u(n.throw(t));
                            } catch (t) {
                                o(t);
                            }
                        }
                        function u(t) {
                            var e;
                            t.done ? i(t.value) : (e = t.value, e instanceof r ? e : new r(function(t) {
                                t(e);
                            })).then(a, s);
                        }
                        u((n = n.apply(t, e || [])).next());
                    });
                }, d = function(t, e) {
                    var r, n, i, o, a = {
                        label: 0,
                        sent: function() {
                            if (1 & i[0]) throw i[1];
                            return i[1];
                        },
                        trys: [],
                        ops: []
                    };
                    return o = {
                        next: s(0),
                        throw: s(1),
                        return: s(2)
                    }, "function" == typeof Symbol && (o[Symbol.iterator] = function() {
                        return this;
                    }), o;
                    function s(o) {
                        return function(s) {
                            return function(o) {
                                if (r) throw new TypeError("Generator is already executing.");
                                for(; a;)try {
                                    if (r = 1, n && (i = 2 & o[0] ? n.return : o[0] ? n.throw || ((i = n.return) && i.call(n), 0) : n.next) && !(i = i.call(n, o[1])).done) return i;
                                    switch(n = 0, i && (o = [
                                        2 & o[0],
                                        i.value
                                    ]), o[0]){
                                        case 0:
                                        case 1:
                                            i = o;
                                            break;
                                        case 4:
                                            return a.label++, {
                                                value: o[1],
                                                done: !1
                                            };
                                        case 5:
                                            a.label++, n = o[1], o = [
                                                0
                                            ];
                                            continue;
                                        case 7:
                                            o = a.ops.pop(), a.trys.pop();
                                            continue;
                                        default:
                                            if (!((i = (i = a.trys).length > 0 && i[i.length - 1]) || 6 !== o[0] && 2 !== o[0])) {
                                                a = 0;
                                                continue;
                                            }
                                            if (3 === o[0] && (!i || o[1] > i[0] && o[1] < i[3])) {
                                                a.label = o[1];
                                                break;
                                            }
                                            if (6 === o[0] && a.label < i[1]) {
                                                a.label = i[1], i = o;
                                                break;
                                            }
                                            if (i && a.label < i[2]) {
                                                a.label = i[2], a.ops.push(o);
                                                break;
                                            }
                                            i[2] && a.ops.pop(), a.trys.pop();
                                            continue;
                                    }
                                    o = e.call(t, a);
                                } catch (t) {
                                    o = [
                                        6,
                                        t
                                    ], n = 0;
                                } finally{
                                    r = i = 0;
                                }
                                if (5 & o[0]) throw o[1];
                                return {
                                    value: o[0] ? o[1] : void 0,
                                    done: !0
                                };
                            }([
                                o,
                                s
                            ]);
                        };
                    }
                };
                function f(t) {
                    return l(this, void 0, void 0, function() {
                        return d(this, function(e) {
                            return [
                                2,
                                new Promise(function(e) {
                                    var r = new XMLHttpRequest;
                                    r.onload = function() {
                                        var t = new FileReader;
                                        t.onloadend = function() {
                                            e(t.result);
                                        }, t.readAsDataURL(r.response);
                                    }, r.open("GET", t), r.responseType = "blob", r.send();
                                })
                            ];
                        });
                    });
                }
                const g = {
                    L: .07,
                    M: .15,
                    Q: .25,
                    H: .3
                };
                var p = function() {
                    return p = Object.assign || function(t) {
                        for(var e, r = 1, n = arguments.length; r < n; r++)for(var i in e = arguments[r])Object.prototype.hasOwnProperty.call(e, i) && (t[i] = e[i]);
                        return t;
                    }, p.apply(this, arguments);
                }, v = function() {
                    function t(t) {
                        var e = t.svg, r = t.type;
                        this._svg = e, this._type = r;
                    }
                    return t.prototype.draw = function(t, e, r, n) {
                        var i;
                        switch(this._type){
                            case "dots":
                                i = this._drawDot;
                                break;
                            case "classy":
                                i = this._drawClassy;
                                break;
                            case "classy-rounded":
                                i = this._drawClassyRounded;
                                break;
                            case "rounded":
                                i = this._drawRounded;
                                break;
                            case "extra-rounded":
                                i = this._drawExtraRounded;
                                break;
                            default:
                                i = this._drawSquare;
                        }
                        i.call(this, {
                            x: t,
                            y: e,
                            size: r,
                            getNeighbor: n
                        });
                    }, t.prototype._rotateFigure = function(t) {
                        var e, r = t.x, n = t.y, i = t.size, o = t.rotation, a = void 0 === o ? 0 : o, s = r + i / 2, u = n + i / 2;
                        (0, t.draw)(), null === (e = this._element) || void 0 === e || e.setAttribute("transform", "rotate(" + 180 * a / Math.PI + "," + s + "," + u + ")");
                    }, t.prototype._basicDot = function(t) {
                        var e = this, r = t.size, n = t.x, i = t.y;
                        this._rotateFigure(p(p({}, t), {
                            draw: function() {
                                e._element = document.createElementNS("http://www.w3.org/2000/svg", "circle"), e._element.setAttribute("cx", String(n + r / 2)), e._element.setAttribute("cy", String(i + r / 2)), e._element.setAttribute("r", String(r / 2));
                            }
                        }));
                    }, t.prototype._basicSquare = function(t) {
                        var e = this, r = t.size, n = t.x, i = t.y;
                        this._rotateFigure(p(p({}, t), {
                            draw: function() {
                                e._element = document.createElementNS("http://www.w3.org/2000/svg", "rect"), e._element.setAttribute("x", String(n)), e._element.setAttribute("y", String(i)), e._element.setAttribute("width", String(r)), e._element.setAttribute("height", String(r));
                            }
                        }));
                    }, t.prototype._basicSideRounded = function(t) {
                        var e = this, r = t.size, n = t.x, i = t.y;
                        this._rotateFigure(p(p({}, t), {
                            draw: function() {
                                e._element = document.createElementNS("http://www.w3.org/2000/svg", "path"), e._element.setAttribute("d", "M " + n + " " + i + "v " + r + "h " + r / 2 + "a " + r / 2 + " " + r / 2 + ", 0, 0, 0, 0 " + -r);
                            }
                        }));
                    }, t.prototype._basicCornerRounded = function(t) {
                        var e = this, r = t.size, n = t.x, i = t.y;
                        this._rotateFigure(p(p({}, t), {
                            draw: function() {
                                e._element = document.createElementNS("http://www.w3.org/2000/svg", "path"), e._element.setAttribute("d", "M " + n + " " + i + "v " + r + "h " + r + "v " + -r / 2 + "a " + r / 2 + " " + r / 2 + ", 0, 0, 0, " + -r / 2 + " " + -r / 2);
                            }
                        }));
                    }, t.prototype._basicCornerExtraRounded = function(t) {
                        var e = this, r = t.size, n = t.x, i = t.y;
                        this._rotateFigure(p(p({}, t), {
                            draw: function() {
                                e._element = document.createElementNS("http://www.w3.org/2000/svg", "path"), e._element.setAttribute("d", "M " + n + " " + i + "v " + r + "h " + r + "a " + r + " " + r + ", 0, 0, 0, " + -r + " " + -r);
                            }
                        }));
                    }, t.prototype._basicCornersRounded = function(t) {
                        var e = this, r = t.size, n = t.x, i = t.y;
                        this._rotateFigure(p(p({}, t), {
                            draw: function() {
                                e._element = document.createElementNS("http://www.w3.org/2000/svg", "path"), e._element.setAttribute("d", "M " + n + " " + i + "v " + r / 2 + "a " + r / 2 + " " + r / 2 + ", 0, 0, 0, " + r / 2 + " " + r / 2 + "h " + r / 2 + "v " + -r / 2 + "a " + r / 2 + " " + r / 2 + ", 0, 0, 0, " + -r / 2 + " " + -r / 2);
                            }
                        }));
                    }, t.prototype._drawDot = function(t) {
                        var e = t.x, r = t.y, n = t.size;
                        this._basicDot({
                            x: e,
                            y: r,
                            size: n,
                            rotation: 0
                        });
                    }, t.prototype._drawSquare = function(t) {
                        var e = t.x, r = t.y, n = t.size;
                        this._basicSquare({
                            x: e,
                            y: r,
                            size: n,
                            rotation: 0
                        });
                    }, t.prototype._drawRounded = function(t) {
                        var e = t.x, r = t.y, n = t.size, i = t.getNeighbor, o = i ? +i(-1, 0) : 0, a = i ? +i(1, 0) : 0, s = i ? +i(0, -1) : 0, u = i ? +i(0, 1) : 0, h = o + a + s + u;
                        if (0 !== h) {
                            if (h > 2 || o && a || s && u) this._basicSquare({
                                x: e,
                                y: r,
                                size: n,
                                rotation: 0
                            });
                            else {
                                if (2 === h) {
                                    var c = 0;
                                    return o && s ? c = Math.PI / 2 : s && a ? c = Math.PI : a && u && (c = -Math.PI / 2), void this._basicCornerRounded({
                                        x: e,
                                        y: r,
                                        size: n,
                                        rotation: c
                                    });
                                }
                                if (1 === h) return c = 0, s ? c = Math.PI / 2 : a ? c = Math.PI : u && (c = -Math.PI / 2), void this._basicSideRounded({
                                    x: e,
                                    y: r,
                                    size: n,
                                    rotation: c
                                });
                            }
                        } else this._basicDot({
                            x: e,
                            y: r,
                            size: n,
                            rotation: 0
                        });
                    }, t.prototype._drawExtraRounded = function(t) {
                        var e = t.x, r = t.y, n = t.size, i = t.getNeighbor, o = i ? +i(-1, 0) : 0, a = i ? +i(1, 0) : 0, s = i ? +i(0, -1) : 0, u = i ? +i(0, 1) : 0, h = o + a + s + u;
                        if (0 !== h) {
                            if (h > 2 || o && a || s && u) this._basicSquare({
                                x: e,
                                y: r,
                                size: n,
                                rotation: 0
                            });
                            else {
                                if (2 === h) {
                                    var c = 0;
                                    return o && s ? c = Math.PI / 2 : s && a ? c = Math.PI : a && u && (c = -Math.PI / 2), void this._basicCornerExtraRounded({
                                        x: e,
                                        y: r,
                                        size: n,
                                        rotation: c
                                    });
                                }
                                if (1 === h) return c = 0, s ? c = Math.PI / 2 : a ? c = Math.PI : u && (c = -Math.PI / 2), void this._basicSideRounded({
                                    x: e,
                                    y: r,
                                    size: n,
                                    rotation: c
                                });
                            }
                        } else this._basicDot({
                            x: e,
                            y: r,
                            size: n,
                            rotation: 0
                        });
                    }, t.prototype._drawClassy = function(t) {
                        var e = t.x, r = t.y, n = t.size, i = t.getNeighbor, o = i ? +i(-1, 0) : 0, a = i ? +i(1, 0) : 0, s = i ? +i(0, -1) : 0, u = i ? +i(0, 1) : 0;
                        0 !== o + a + s + u ? o || s ? a || u ? this._basicSquare({
                            x: e,
                            y: r,
                            size: n,
                            rotation: 0
                        }) : this._basicCornerRounded({
                            x: e,
                            y: r,
                            size: n,
                            rotation: Math.PI / 2
                        }) : this._basicCornerRounded({
                            x: e,
                            y: r,
                            size: n,
                            rotation: -Math.PI / 2
                        }) : this._basicCornersRounded({
                            x: e,
                            y: r,
                            size: n,
                            rotation: Math.PI / 2
                        });
                    }, t.prototype._drawClassyRounded = function(t) {
                        var e = t.x, r = t.y, n = t.size, i = t.getNeighbor, o = i ? +i(-1, 0) : 0, a = i ? +i(1, 0) : 0, s = i ? +i(0, -1) : 0, u = i ? +i(0, 1) : 0;
                        0 !== o + a + s + u ? o || s ? a || u ? this._basicSquare({
                            x: e,
                            y: r,
                            size: n,
                            rotation: 0
                        }) : this._basicCornerExtraRounded({
                            x: e,
                            y: r,
                            size: n,
                            rotation: Math.PI / 2
                        }) : this._basicCornerExtraRounded({
                            x: e,
                            y: r,
                            size: n,
                            rotation: -Math.PI / 2
                        }) : this._basicCornersRounded({
                            x: e,
                            y: r,
                            size: n,
                            rotation: Math.PI / 2
                        });
                    }, t;
                }();
                const w = v;
                var y = function() {
                    return y = Object.assign || function(t) {
                        for(var e, r = 1, n = arguments.length; r < n; r++)for(var i in e = arguments[r])Object.prototype.hasOwnProperty.call(e, i) && (t[i] = e[i]);
                        return t;
                    }, y.apply(this, arguments);
                }, m = function() {
                    function t(t) {
                        var e = t.svg, r = t.type;
                        this._svg = e, this._type = r;
                    }
                    return t.prototype.draw = function(t, e, r, n) {
                        var i;
                        switch(this._type){
                            case "square":
                                i = this._drawSquare;
                                break;
                            case "extra-rounded":
                                i = this._drawExtraRounded;
                                break;
                            default:
                                i = this._drawDot;
                        }
                        i.call(this, {
                            x: t,
                            y: e,
                            size: r,
                            rotation: n
                        });
                    }, t.prototype._rotateFigure = function(t) {
                        var e, r = t.x, n = t.y, i = t.size, o = t.rotation, a = void 0 === o ? 0 : o, s = r + i / 2, u = n + i / 2;
                        (0, t.draw)(), null === (e = this._element) || void 0 === e || e.setAttribute("transform", "rotate(" + 180 * a / Math.PI + "," + s + "," + u + ")");
                    }, t.prototype._basicDot = function(t) {
                        var e = this, r = t.size, n = t.x, i = t.y, o = r / 7;
                        this._rotateFigure(y(y({}, t), {
                            draw: function() {
                                e._element = document.createElementNS("http://www.w3.org/2000/svg", "path"), e._element.setAttribute("clip-rule", "evenodd"), e._element.setAttribute("d", "M " + (n + r / 2) + " " + i + "a " + r / 2 + " " + r / 2 + " 0 1 0 0.1 0zm 0 " + o + "a " + (r / 2 - o) + " " + (r / 2 - o) + " 0 1 1 -0.1 0Z");
                            }
                        }));
                    }, t.prototype._basicSquare = function(t) {
                        var e = this, r = t.size, n = t.x, i = t.y, o = r / 7;
                        this._rotateFigure(y(y({}, t), {
                            draw: function() {
                                e._element = document.createElementNS("http://www.w3.org/2000/svg", "path"), e._element.setAttribute("clip-rule", "evenodd"), e._element.setAttribute("d", "M " + n + " " + i + "v " + r + "h " + r + "v " + -r + "zM " + (n + o) + " " + (i + o) + "h " + (r - 2 * o) + "v " + (r - 2 * o) + "h " + (2 * o - r) + "z");
                            }
                        }));
                    }, t.prototype._basicExtraRounded = function(t) {
                        var e = this, r = t.size, n = t.x, i = t.y, o = r / 7;
                        this._rotateFigure(y(y({}, t), {
                            draw: function() {
                                e._element = document.createElementNS("http://www.w3.org/2000/svg", "path"), e._element.setAttribute("clip-rule", "evenodd"), e._element.setAttribute("d", "M " + n + " " + (i + 2.5 * o) + "v " + 2 * o + "a " + 2.5 * o + " " + 2.5 * o + ", 0, 0, 0, " + 2.5 * o + " " + 2.5 * o + "h " + 2 * o + "a " + 2.5 * o + " " + 2.5 * o + ", 0, 0, 0, " + 2.5 * o + " " + 2.5 * -o + "v " + -2 * o + "a " + 2.5 * o + " " + 2.5 * o + ", 0, 0, 0, " + 2.5 * -o + " " + 2.5 * -o + "h " + -2 * o + "a " + 2.5 * o + " " + 2.5 * o + ", 0, 0, 0, " + 2.5 * -o + " " + 2.5 * o + "M " + (n + 2.5 * o) + " " + (i + o) + "h " + 2 * o + "a " + 1.5 * o + " " + 1.5 * o + ", 0, 0, 1, " + 1.5 * o + " " + 1.5 * o + "v " + 2 * o + "a " + 1.5 * o + " " + 1.5 * o + ", 0, 0, 1, " + 1.5 * -o + " " + 1.5 * o + "h " + -2 * o + "a " + 1.5 * o + " " + 1.5 * o + ", 0, 0, 1, " + 1.5 * -o + " " + 1.5 * -o + "v " + -2 * o + "a " + 1.5 * o + " " + 1.5 * o + ", 0, 0, 1, " + 1.5 * o + " " + 1.5 * -o);
                            }
                        }));
                    }, t.prototype._drawDot = function(t) {
                        var e = t.x, r = t.y, n = t.size, i = t.rotation;
                        this._basicDot({
                            x: e,
                            y: r,
                            size: n,
                            rotation: i
                        });
                    }, t.prototype._drawSquare = function(t) {
                        var e = t.x, r = t.y, n = t.size, i = t.rotation;
                        this._basicSquare({
                            x: e,
                            y: r,
                            size: n,
                            rotation: i
                        });
                    }, t.prototype._drawExtraRounded = function(t) {
                        var e = t.x, r = t.y, n = t.size, i = t.rotation;
                        this._basicExtraRounded({
                            x: e,
                            y: r,
                            size: n,
                            rotation: i
                        });
                    }, t;
                }();
                const _ = m;
                var b = function() {
                    return b = Object.assign || function(t) {
                        for(var e, r = 1, n = arguments.length; r < n; r++)for(var i in e = arguments[r])Object.prototype.hasOwnProperty.call(e, i) && (t[i] = e[i]);
                        return t;
                    }, b.apply(this, arguments);
                }, x = function() {
                    function t(t) {
                        var e = t.svg, r = t.type;
                        this._svg = e, this._type = r;
                    }
                    return t.prototype.draw = function(t, e, r, n) {
                        ("square" === this._type ? this._drawSquare : this._drawDot).call(this, {
                            x: t,
                            y: e,
                            size: r,
                            rotation: n
                        });
                    }, t.prototype._rotateFigure = function(t) {
                        var e, r = t.x, n = t.y, i = t.size, o = t.rotation, a = void 0 === o ? 0 : o, s = r + i / 2, u = n + i / 2;
                        (0, t.draw)(), null === (e = this._element) || void 0 === e || e.setAttribute("transform", "rotate(" + 180 * a / Math.PI + "," + s + "," + u + ")");
                    }, t.prototype._basicDot = function(t) {
                        var e = this, r = t.size, n = t.x, i = t.y;
                        this._rotateFigure(b(b({}, t), {
                            draw: function() {
                                e._element = document.createElementNS("http://www.w3.org/2000/svg", "circle"), e._element.setAttribute("cx", String(n + r / 2)), e._element.setAttribute("cy", String(i + r / 2)), e._element.setAttribute("r", String(r / 2));
                            }
                        }));
                    }, t.prototype._basicSquare = function(t) {
                        var e = this, r = t.size, n = t.x, i = t.y;
                        this._rotateFigure(b(b({}, t), {
                            draw: function() {
                                e._element = document.createElementNS("http://www.w3.org/2000/svg", "rect"), e._element.setAttribute("x", String(n)), e._element.setAttribute("y", String(i)), e._element.setAttribute("width", String(r)), e._element.setAttribute("height", String(r));
                            }
                        }));
                    }, t.prototype._drawDot = function(t) {
                        var e = t.x, r = t.y, n = t.size, i = t.rotation;
                        this._basicDot({
                            x: e,
                            y: r,
                            size: n,
                            rotation: i
                        });
                    }, t.prototype._drawSquare = function(t) {
                        var e = t.x, r = t.y, n = t.size, i = t.rotation;
                        this._basicSquare({
                            x: e,
                            y: r,
                            size: n,
                            rotation: i
                        });
                    }, t;
                }();
                const S = x, C = "circle";
                var A = function(t, e, r, n) {
                    return new (r || (r = Promise))(function(i, o) {
                        function a(t) {
                            try {
                                u(n.next(t));
                            } catch (t) {
                                o(t);
                            }
                        }
                        function s(t) {
                            try {
                                u(n.throw(t));
                            } catch (t) {
                                o(t);
                            }
                        }
                        function u(t) {
                            var e;
                            t.done ? i(t.value) : (e = t.value, e instanceof r ? e : new r(function(t) {
                                t(e);
                            })).then(a, s);
                        }
                        u((n = n.apply(t, e || [])).next());
                    });
                }, M = function(t, e) {
                    var r, n, i, o, a = {
                        label: 0,
                        sent: function() {
                            if (1 & i[0]) throw i[1];
                            return i[1];
                        },
                        trys: [],
                        ops: []
                    };
                    return o = {
                        next: s(0),
                        throw: s(1),
                        return: s(2)
                    }, "function" == typeof Symbol && (o[Symbol.iterator] = function() {
                        return this;
                    }), o;
                    function s(o) {
                        return function(s) {
                            return function(o) {
                                if (r) throw new TypeError("Generator is already executing.");
                                for(; a;)try {
                                    if (r = 1, n && (i = 2 & o[0] ? n.return : o[0] ? n.throw || ((i = n.return) && i.call(n), 0) : n.next) && !(i = i.call(n, o[1])).done) return i;
                                    switch(n = 0, i && (o = [
                                        2 & o[0],
                                        i.value
                                    ]), o[0]){
                                        case 0:
                                        case 1:
                                            i = o;
                                            break;
                                        case 4:
                                            return a.label++, {
                                                value: o[1],
                                                done: !1
                                            };
                                        case 5:
                                            a.label++, n = o[1], o = [
                                                0
                                            ];
                                            continue;
                                        case 7:
                                            o = a.ops.pop(), a.trys.pop();
                                            continue;
                                        default:
                                            if (!((i = (i = a.trys).length > 0 && i[i.length - 1]) || 6 !== o[0] && 2 !== o[0])) {
                                                a = 0;
                                                continue;
                                            }
                                            if (3 === o[0] && (!i || o[1] > i[0] && o[1] < i[3])) {
                                                a.label = o[1];
                                                break;
                                            }
                                            if (6 === o[0] && a.label < i[1]) {
                                                a.label = i[1], i = o;
                                                break;
                                            }
                                            if (i && a.label < i[2]) {
                                                a.label = i[2], a.ops.push(o);
                                                break;
                                            }
                                            i[2] && a.ops.pop(), a.trys.pop();
                                            continue;
                                    }
                                    o = e.call(t, a);
                                } catch (t) {
                                    o = [
                                        6,
                                        t
                                    ], n = 0;
                                } finally{
                                    r = i = 0;
                                }
                                if (5 & o[0]) throw o[1];
                                return {
                                    value: o[0] ? o[1] : void 0,
                                    done: !0
                                };
                            }([
                                o,
                                s
                            ]);
                        };
                    }
                }, k = [
                    [
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1
                    ],
                    [
                        1,
                        0,
                        0,
                        0,
                        0,
                        0,
                        1
                    ],
                    [
                        1,
                        0,
                        0,
                        0,
                        0,
                        0,
                        1
                    ],
                    [
                        1,
                        0,
                        0,
                        0,
                        0,
                        0,
                        1
                    ],
                    [
                        1,
                        0,
                        0,
                        0,
                        0,
                        0,
                        1
                    ],
                    [
                        1,
                        0,
                        0,
                        0,
                        0,
                        0,
                        1
                    ],
                    [
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1
                    ]
                ], O = [
                    [
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0
                    ],
                    [
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0
                    ],
                    [
                        0,
                        0,
                        1,
                        1,
                        1,
                        0,
                        0
                    ],
                    [
                        0,
                        0,
                        1,
                        1,
                        1,
                        0,
                        0
                    ],
                    [
                        0,
                        0,
                        1,
                        1,
                        1,
                        0,
                        0
                    ],
                    [
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0
                    ],
                    [
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0
                    ]
                ];
                const D = function() {
                    function t(e) {
                        this._element = document.createElementNS("http://www.w3.org/2000/svg", "svg"), this._element.setAttribute("width", String(e.width)), this._element.setAttribute("height", String(e.height)), this._defs = document.createElementNS("http://www.w3.org/2000/svg", "defs"), this._element.appendChild(this._defs), this._instanceId = t.instanceCount++, this._options = e;
                    }
                    return Object.defineProperty(t.prototype, "width", {
                        get: function() {
                            return this._options.width;
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(t.prototype, "height", {
                        get: function() {
                            return this._options.height;
                        },
                        enumerable: !1,
                        configurable: !0
                    }), t.prototype.getElement = function() {
                        return this._element;
                    }, t.prototype.drawQR = function(t) {
                        return A(this, void 0, void 0, function() {
                            var e, r, n, i, o, a, s, u, h, c, l = this;
                            return M(this, function(d) {
                                switch(d.label){
                                    case 0:
                                        return e = t.getModuleCount(), r = Math.min(this._options.width, this._options.height) - 2 * this._options.margin, n = this._options.shape === C ? r / Math.sqrt(2) : r, i = n / e, o = {
                                            hideXDots: 0,
                                            hideYDots: 0,
                                            width: 0,
                                            height: 0
                                        }, this._qr = t, this._options.image ? [
                                            4,
                                            this.loadImage()
                                        ] : [
                                            3,
                                            2
                                        ];
                                    case 1:
                                        if (d.sent(), !this._image) return [
                                            2
                                        ];
                                        a = this._options, s = a.imageOptions, u = a.qrOptions, h = s.imageSize * g[u.errorCorrectionLevel], c = Math.floor(h * e * e), o = function(t) {
                                            var e = t.originalHeight, r = t.originalWidth, n = t.maxHiddenDots, i = t.maxHiddenAxisDots, o = t.dotSize, a = {
                                                x: 0,
                                                y: 0
                                            }, s = {
                                                x: 0,
                                                y: 0
                                            };
                                            if (e <= 0 || r <= 0 || n <= 0 || o <= 0) return {
                                                height: 0,
                                                width: 0,
                                                hideYDots: 0,
                                                hideXDots: 0
                                            };
                                            var u = e / r;
                                            return a.x = Math.floor(Math.sqrt(n / u)), a.x <= 0 && (a.x = 1), i && i < a.x && (a.x = i), a.x % 2 == 0 && a.x--, s.x = a.x * o, a.y = 1 + 2 * Math.ceil((a.x * u - 1) / 2), s.y = Math.round(s.x * u), (a.y * a.x > n || i && i < a.y) && (i && i < a.y ? (a.y = i, a.y % 2 == 0 && a.x--) : a.y -= 2, s.y = a.y * o, a.x = 1 + 2 * Math.ceil((a.y / u - 1) / 2), s.x = Math.round(s.y / u)), {
                                                height: s.y,
                                                width: s.x,
                                                hideYDots: a.y,
                                                hideXDots: a.x
                                            };
                                        }({
                                            originalWidth: this._image.width,
                                            originalHeight: this._image.height,
                                            maxHiddenDots: c,
                                            maxHiddenAxisDots: e - 14,
                                            dotSize: i
                                        }), d.label = 2;
                                    case 2:
                                        return this.drawBackground(), this.drawDots(function(t, r) {
                                            var n, i, a, s, u, h;
                                            return !(l._options.imageOptions.hideBackgroundDots && t >= (e - o.hideXDots) / 2 && t < (e + o.hideXDots) / 2 && r >= (e - o.hideYDots) / 2 && r < (e + o.hideYDots) / 2 || (null === (n = k[t]) || void 0 === n ? void 0 : n[r]) || (null === (i = k[t - e + 7]) || void 0 === i ? void 0 : i[r]) || (null === (a = k[t]) || void 0 === a ? void 0 : a[r - e + 7]) || (null === (s = O[t]) || void 0 === s ? void 0 : s[r]) || (null === (u = O[t - e + 7]) || void 0 === u ? void 0 : u[r]) || (null === (h = O[t]) || void 0 === h ? void 0 : h[r - e + 7]));
                                        }), this.drawCorners(), this._options.image ? [
                                            4,
                                            this.drawImage({
                                                width: o.width,
                                                height: o.height,
                                                count: e,
                                                dotSize: i
                                            })
                                        ] : [
                                            3,
                                            4
                                        ];
                                    case 3:
                                        d.sent(), d.label = 4;
                                    case 4:
                                        return [
                                            2
                                        ];
                                }
                            });
                        });
                    }, t.prototype.drawBackground = function() {
                        var t, e, r, n = this._element, i = this._options;
                        if (n) {
                            var o = null === (t = i.backgroundOptions) || void 0 === t ? void 0 : t.gradient, a = null === (e = i.backgroundOptions) || void 0 === e ? void 0 : e.color;
                            if ((o || a) && this._createColor({
                                options: o,
                                color: a,
                                additionalRotation: 0,
                                x: 0,
                                y: 0,
                                height: i.height,
                                width: i.width,
                                name: "background-color"
                            }), null === (r = i.backgroundOptions) || void 0 === r ? void 0 : r.round) {
                                var s = Math.min(i.width, i.height), u = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                                this._backgroundClipPath = document.createElementNS("http://www.w3.org/2000/svg", "clipPath"), this._backgroundClipPath.setAttribute("id", "clip-path-background-color"), this._defs.appendChild(this._backgroundClipPath), u.setAttribute("x", String((i.width - s) / 2)), u.setAttribute("y", String((i.height - s) / 2)), u.setAttribute("width", String(s)), u.setAttribute("height", String(s)), u.setAttribute("rx", String(s / 2 * i.backgroundOptions.round)), this._backgroundClipPath.appendChild(u);
                            }
                        }
                    }, t.prototype.drawDots = function(t) {
                        var e, r, n = this;
                        if (!this._qr) throw "QR code is not defined";
                        var i = this._options, o = this._qr.getModuleCount();
                        if (o > i.width || o > i.height) throw "The canvas is too small.";
                        var a = Math.min(i.width, i.height) - 2 * i.margin, s = (i.shape === C ? a / Math.sqrt(2) : a) / o, u = (i.width - o * s) / 2, h = (i.height - o * s) / 2, c = new w({
                            svg: this._element,
                            type: i.dotsOptions.type
                        });
                        this._dotsClipPath = document.createElementNS("http://www.w3.org/2000/svg", "clipPath"), this._dotsClipPath.setAttribute("id", "clip-path-dot-color-" + this._instanceId), this._defs.appendChild(this._dotsClipPath), this._createColor({
                            options: null === (e = i.dotsOptions) || void 0 === e ? void 0 : e.gradient,
                            color: i.dotsOptions.color,
                            additionalRotation: 0,
                            x: 0,
                            y: 0,
                            height: i.height,
                            width: i.width,
                            name: "dot-color-" + this._instanceId
                        });
                        for(var l = function(e) {
                            for(var i = function(i) {
                                return t && !t(e, i) ? "continue" : (null === (r = d._qr) || void 0 === r ? void 0 : r.isDark(e, i)) ? (c.draw(u + e * s, h + i * s, s, function(r, a) {
                                    return !(e + r < 0 || i + a < 0 || e + r >= o || i + a >= o) && !(t && !t(e + r, i + a)) && !!n._qr && n._qr.isDark(e + r, i + a);
                                }), void (c._element && d._dotsClipPath && d._dotsClipPath.appendChild(c._element))) : "continue";
                            }, a = 0; a < o; a++)i(a);
                        }, d = this, f = 0; f < o; f++)l(f);
                        if (i.shape === C) {
                            var g = Math.floor((a / s - o) / 2), p = o + 2 * g, v = u - g * s, y = h - g * s, m = [], _ = Math.floor(p / 2);
                            for(f = 0; f < p; f++){
                                m[f] = [];
                                for(var b = 0; b < p; b++)f >= g - 1 && f <= p - g && b >= g - 1 && b <= p - g || Math.sqrt((f - _) * (f - _) + (b - _) * (b - _)) > _ ? m[f][b] = 0 : m[f][b] = this._qr.isDark(b - 2 * g < 0 ? b : b >= o ? b - 2 * g : b - g, f - 2 * g < 0 ? f : f >= o ? f - 2 * g : f - g) ? 1 : 0;
                            }
                            var x = function(t) {
                                for(var e = function(e) {
                                    if (!m[t][e]) return "continue";
                                    c.draw(v + t * s, y + e * s, s, function(r, n) {
                                        var i;
                                        return !!(null === (i = m[t + r]) || void 0 === i ? void 0 : i[e + n]);
                                    }), c._element && S._dotsClipPath && S._dotsClipPath.appendChild(c._element);
                                }, r = 0; r < p; r++)e(r);
                            }, S = this;
                            for(f = 0; f < p; f++)x(f);
                        }
                    }, t.prototype.drawCorners = function() {
                        var t = this;
                        if (!this._qr) throw "QR code is not defined";
                        var e = this._element, r = this._options;
                        if (!e) throw "Element code is not defined";
                        var n = this._qr.getModuleCount(), i = Math.min(r.width, r.height) - 2 * r.margin, o = (r.shape === C ? i / Math.sqrt(2) : i) / n, a = 7 * o, s = 3 * o, u = (r.width - n * o) / 2, h = (r.height - n * o) / 2;
                        [
                            [
                                0,
                                0,
                                0
                            ],
                            [
                                1,
                                0,
                                Math.PI / 2
                            ],
                            [
                                0,
                                1,
                                -Math.PI / 2
                            ]
                        ].forEach(function(e) {
                            var i, c, l, d, f, g, p, v, y, m, b, x, C = e[0], A = e[1], M = e[2], D = u + C * o * (n - 7), P = h + A * o * (n - 7), z = t._dotsClipPath, B = t._dotsClipPath;
                            if (((null === (i = r.cornersSquareOptions) || void 0 === i ? void 0 : i.gradient) || (null === (c = r.cornersSquareOptions) || void 0 === c ? void 0 : c.color)) && ((z = document.createElementNS("http://www.w3.org/2000/svg", "clipPath")).setAttribute("id", "clip-path-corners-square-color-" + C + "-" + A), t._defs.appendChild(z), t._cornersSquareClipPath = t._cornersDotClipPath = B = z, t._createColor({
                                options: null === (l = r.cornersSquareOptions) || void 0 === l ? void 0 : l.gradient,
                                color: null === (d = r.cornersSquareOptions) || void 0 === d ? void 0 : d.color,
                                additionalRotation: M,
                                x: D,
                                y: P,
                                height: a,
                                width: a,
                                name: "corners-square-color-" + C + "-" + A
                            })), null === (f = r.cornersSquareOptions) || void 0 === f ? void 0 : f.type) {
                                var q = new _({
                                    svg: t._element,
                                    type: r.cornersSquareOptions.type
                                });
                                q.draw(D, P, a, M), q._element && z && z.appendChild(q._element);
                            } else for(var I = new w({
                                svg: t._element,
                                type: r.dotsOptions.type
                            }), E = function(t) {
                                for(var e = function(e) {
                                    if (!(null === (g = k[t]) || void 0 === g ? void 0 : g[e])) return "continue";
                                    I.draw(D + t * o, P + e * o, o, function(r, n) {
                                        var i;
                                        return !!(null === (i = k[t + r]) || void 0 === i ? void 0 : i[e + n]);
                                    }), I._element && z && z.appendChild(I._element);
                                }, r = 0; r < k[t].length; r++)e(r);
                            }, L = 0; L < k.length; L++)E(L);
                            if (((null === (p = r.cornersDotOptions) || void 0 === p ? void 0 : p.gradient) || (null === (v = r.cornersDotOptions) || void 0 === v ? void 0 : v.color)) && ((B = document.createElementNS("http://www.w3.org/2000/svg", "clipPath")).setAttribute("id", "clip-path-corners-dot-color-" + C + "-" + A), t._defs.appendChild(B), t._cornersDotClipPath = B, t._createColor({
                                options: null === (y = r.cornersDotOptions) || void 0 === y ? void 0 : y.gradient,
                                color: null === (m = r.cornersDotOptions) || void 0 === m ? void 0 : m.color,
                                additionalRotation: M,
                                x: D + 2 * o,
                                y: P + 2 * o,
                                height: s,
                                width: s,
                                name: "corners-dot-color-" + C + "-" + A
                            })), null === (b = r.cornersDotOptions) || void 0 === b ? void 0 : b.type) {
                                var R = new S({
                                    svg: t._element,
                                    type: r.cornersDotOptions.type
                                });
                                R.draw(D + 2 * o, P + 2 * o, s, M), R._element && B && B.appendChild(R._element);
                            } else {
                                I = new w({
                                    svg: t._element,
                                    type: r.dotsOptions.type
                                });
                                var N = function(t) {
                                    for(var e = function(e) {
                                        if (!(null === (x = O[t]) || void 0 === x ? void 0 : x[e])) return "continue";
                                        I.draw(D + t * o, P + e * o, o, function(r, n) {
                                            var i;
                                            return !!(null === (i = O[t + r]) || void 0 === i ? void 0 : i[e + n]);
                                        }), I._element && B && B.appendChild(I._element);
                                    }, r = 0; r < O[t].length; r++)e(r);
                                };
                                for(L = 0; L < O.length; L++)N(L);
                            }
                        });
                    }, t.prototype.loadImage = function() {
                        var t = this;
                        return new Promise(function(e, r) {
                            var n = t._options, i = new Image;
                            if (!n.image) return r("Image is not defined");
                            "string" == typeof n.imageOptions.crossOrigin && (i.crossOrigin = n.imageOptions.crossOrigin), t._image = i, i.onload = function() {
                                e();
                            }, i.src = n.image;
                        });
                    }, t.prototype.drawImage = function(t) {
                        var e = t.width, r = t.height, n = t.count, i = t.dotSize;
                        return A(this, void 0, void 0, function() {
                            var t, o, a, s, u, h, c, l, d;
                            return M(this, function(g) {
                                switch(g.label){
                                    case 0:
                                        return t = this._options, o = (t.width - n * i) / 2, a = (t.height - n * i) / 2, s = o + t.imageOptions.margin + (n * i - e) / 2, u = a + t.imageOptions.margin + (n * i - r) / 2, h = e - 2 * t.imageOptions.margin, c = r - 2 * t.imageOptions.margin, (l = document.createElementNS("http://www.w3.org/2000/svg", "image")).setAttribute("x", String(s)), l.setAttribute("y", String(u)), l.setAttribute("width", h + "px"), l.setAttribute("height", c + "px"), [
                                            4,
                                            f(t.image || "")
                                        ];
                                    case 1:
                                        return d = g.sent(), l.setAttribute("href", d || ""), this._element.appendChild(l), [
                                            2
                                        ];
                                }
                            });
                        });
                    }, t.prototype._createColor = function(t) {
                        var e = t.options, r = t.color, n = t.additionalRotation, i = t.x, o = t.y, a = t.height, s = t.width, u = t.name, h = s > a ? s : a, c = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                        if (c.setAttribute("x", String(i)), c.setAttribute("y", String(o)), c.setAttribute("height", String(a)), c.setAttribute("width", String(s)), c.setAttribute("clip-path", "url('#clip-path-" + u + "')"), e) {
                            var l;
                            if ("radial" === e.type) (l = document.createElementNS("http://www.w3.org/2000/svg", "radialGradient")).setAttribute("id", u), l.setAttribute("gradientUnits", "userSpaceOnUse"), l.setAttribute("fx", String(i + s / 2)), l.setAttribute("fy", String(o + a / 2)), l.setAttribute("cx", String(i + s / 2)), l.setAttribute("cy", String(o + a / 2)), l.setAttribute("r", String(h / 2));
                            else {
                                var d = ((e.rotation || 0) + n) % (2 * Math.PI), f = (d + 2 * Math.PI) % (2 * Math.PI), g = i + s / 2, p = o + a / 2, v = i + s / 2, w = o + a / 2;
                                f >= 0 && f <= .25 * Math.PI || f > 1.75 * Math.PI && f <= 2 * Math.PI ? (g -= s / 2, p -= a / 2 * Math.tan(d), v += s / 2, w += a / 2 * Math.tan(d)) : f > .25 * Math.PI && f <= .75 * Math.PI ? (p -= a / 2, g -= s / 2 / Math.tan(d), w += a / 2, v += s / 2 / Math.tan(d)) : f > .75 * Math.PI && f <= 1.25 * Math.PI ? (g += s / 2, p += a / 2 * Math.tan(d), v -= s / 2, w -= a / 2 * Math.tan(d)) : f > 1.25 * Math.PI && f <= 1.75 * Math.PI && (p += a / 2, g += s / 2 / Math.tan(d), w -= a / 2, v -= s / 2 / Math.tan(d)), (l = document.createElementNS("http://www.w3.org/2000/svg", "linearGradient")).setAttribute("id", u), l.setAttribute("gradientUnits", "userSpaceOnUse"), l.setAttribute("x1", String(Math.round(g))), l.setAttribute("y1", String(Math.round(p))), l.setAttribute("x2", String(Math.round(v))), l.setAttribute("y2", String(Math.round(w)));
                            }
                            e.colorStops.forEach(function(t) {
                                var e = t.offset, r = t.color, n = document.createElementNS("http://www.w3.org/2000/svg", "stop");
                                n.setAttribute("offset", 100 * e + "%"), n.setAttribute("stop-color", r), l.appendChild(n);
                            }), c.setAttribute("fill", "url('#" + u + "')"), this._defs.appendChild(l);
                        } else r && c.setAttribute("fill", r);
                        this._element.appendChild(c);
                    }, t.instanceCount = 0, t;
                }(), P = "canvas";
                for(var z = {}, B = 0; B <= 40; B++)z[B] = B;
                const q = {
                    type: P,
                    shape: "square",
                    width: 300,
                    height: 300,
                    data: "",
                    margin: 0,
                    qrOptions: {
                        typeNumber: z[0],
                        mode: void 0,
                        errorCorrectionLevel: "Q"
                    },
                    imageOptions: {
                        hideBackgroundDots: !0,
                        imageSize: .4,
                        crossOrigin: void 0,
                        margin: 0
                    },
                    dotsOptions: {
                        type: "square",
                        color: "#000"
                    },
                    backgroundOptions: {
                        round: 0,
                        color: "#fff"
                    }
                };
                var I = function() {
                    return I = Object.assign || function(t) {
                        for(var e, r = 1, n = arguments.length; r < n; r++)for(var i in e = arguments[r])Object.prototype.hasOwnProperty.call(e, i) && (t[i] = e[i]);
                        return t;
                    }, I.apply(this, arguments);
                };
                function E(t) {
                    var e = I({}, t);
                    if (!e.colorStops || !e.colorStops.length) throw "Field 'colorStops' is required in gradient";
                    return e.rotation ? e.rotation = Number(e.rotation) : e.rotation = 0, e.colorStops = e.colorStops.map(function(t) {
                        return I(I({}, t), {
                            offset: Number(t.offset)
                        });
                    }), e;
                }
                function L(t) {
                    var e = I({}, t);
                    return e.width = Number(e.width), e.height = Number(e.height), e.margin = Number(e.margin), e.imageOptions = I(I({}, e.imageOptions), {
                        hideBackgroundDots: Boolean(e.imageOptions.hideBackgroundDots),
                        imageSize: Number(e.imageOptions.imageSize),
                        margin: Number(e.imageOptions.margin)
                    }), e.margin > Math.min(e.width, e.height) && (e.margin = Math.min(e.width, e.height)), e.dotsOptions = I({}, e.dotsOptions), e.dotsOptions.gradient && (e.dotsOptions.gradient = E(e.dotsOptions.gradient)), e.cornersSquareOptions && (e.cornersSquareOptions = I({}, e.cornersSquareOptions), e.cornersSquareOptions.gradient && (e.cornersSquareOptions.gradient = E(e.cornersSquareOptions.gradient))), e.cornersDotOptions && (e.cornersDotOptions = I({}, e.cornersDotOptions), e.cornersDotOptions.gradient && (e.cornersDotOptions.gradient = E(e.cornersDotOptions.gradient))), e.backgroundOptions && (e.backgroundOptions = I({}, e.backgroundOptions), e.backgroundOptions.gradient && (e.backgroundOptions.gradient = E(e.backgroundOptions.gradient))), e;
                }
                var R = r(192), N = r.n(R), j = function(t, e, r, n) {
                    return new (r || (r = Promise))(function(i, o) {
                        function a(t) {
                            try {
                                u(n.next(t));
                            } catch (t) {
                                o(t);
                            }
                        }
                        function s(t) {
                            try {
                                u(n.throw(t));
                            } catch (t) {
                                o(t);
                            }
                        }
                        function u(t) {
                            var e;
                            t.done ? i(t.value) : (e = t.value, e instanceof r ? e : new r(function(t) {
                                t(e);
                            })).then(a, s);
                        }
                        u((n = n.apply(t, e || [])).next());
                    });
                }, T = function(t, e) {
                    var r, n, i, o, a = {
                        label: 0,
                        sent: function() {
                            if (1 & i[0]) throw i[1];
                            return i[1];
                        },
                        trys: [],
                        ops: []
                    };
                    return o = {
                        next: s(0),
                        throw: s(1),
                        return: s(2)
                    }, "function" == typeof Symbol && (o[Symbol.iterator] = function() {
                        return this;
                    }), o;
                    function s(o) {
                        return function(s) {
                            return function(o) {
                                if (r) throw new TypeError("Generator is already executing.");
                                for(; a;)try {
                                    if (r = 1, n && (i = 2 & o[0] ? n.return : o[0] ? n.throw || ((i = n.return) && i.call(n), 0) : n.next) && !(i = i.call(n, o[1])).done) return i;
                                    switch(n = 0, i && (o = [
                                        2 & o[0],
                                        i.value
                                    ]), o[0]){
                                        case 0:
                                        case 1:
                                            i = o;
                                            break;
                                        case 4:
                                            return a.label++, {
                                                value: o[1],
                                                done: !1
                                            };
                                        case 5:
                                            a.label++, n = o[1], o = [
                                                0
                                            ];
                                            continue;
                                        case 7:
                                            o = a.ops.pop(), a.trys.pop();
                                            continue;
                                        default:
                                            if (!((i = (i = a.trys).length > 0 && i[i.length - 1]) || 6 !== o[0] && 2 !== o[0])) {
                                                a = 0;
                                                continue;
                                            }
                                            if (3 === o[0] && (!i || o[1] > i[0] && o[1] < i[3])) {
                                                a.label = o[1];
                                                break;
                                            }
                                            if (6 === o[0] && a.label < i[1]) {
                                                a.label = i[1], i = o;
                                                break;
                                            }
                                            if (i && a.label < i[2]) {
                                                a.label = i[2], a.ops.push(o);
                                                break;
                                            }
                                            i[2] && a.ops.pop(), a.trys.pop();
                                            continue;
                                    }
                                    o = e.call(t, a);
                                } catch (t) {
                                    o = [
                                        6,
                                        t
                                    ], n = 0;
                                } finally{
                                    r = i = 0;
                                }
                                if (5 & o[0]) throw o[1];
                                return {
                                    value: o[0] ? o[1] : void 0,
                                    done: !0
                                };
                            }([
                                o,
                                s
                            ]);
                        };
                    }
                };
                const F = function() {
                    function t(t) {
                        this._options = t ? L(h(q, t)) : q, this.update();
                    }
                    return t._clearContainer = function(t) {
                        t && (t.innerHTML = "");
                    }, t.prototype._setupSvg = function() {
                        var t = this;
                        if (this._qr) {
                            var e = new D(this._options);
                            this._svg = e.getElement(), this._svgDrawingPromise = e.drawQR(this._qr).then(function() {
                                var r;
                                t._svg && (null === (r = t._extension) || void 0 === r || r.call(t, e.getElement(), t._options));
                            });
                        }
                    }, t.prototype._setupCanvas = function() {
                        var t, e = this;
                        this._qr && (this._canvas = document.createElement("canvas"), this._canvas.width = this._options.width, this._canvas.height = this._options.height, this._setupSvg(), this._canvasDrawingPromise = null === (t = this._svgDrawingPromise) || void 0 === t ? void 0 : t.then(function() {
                            if (e._svg) {
                                var t = e._svg, r = (new XMLSerializer).serializeToString(t), n = "data:image/svg+xml;base64," + btoa(r), i = new Image;
                                return new Promise(function(t) {
                                    i.onload = function() {
                                        var r, n;
                                        null === (n = null === (r = e._canvas) || void 0 === r ? void 0 : r.getContext("2d")) || void 0 === n || n.drawImage(i, 0, 0), t();
                                    }, i.src = n;
                                });
                            }
                        }));
                    }, t.prototype._getElement = function(t) {
                        return void 0 === t && (t = "png"), j(this, void 0, void 0, function() {
                            return T(this, function(e) {
                                switch(e.label){
                                    case 0:
                                        if (!this._qr) throw "QR code is empty";
                                        return "svg" !== t.toLowerCase() ? [
                                            3,
                                            2
                                        ] : (this._svg && this._svgDrawingPromise || this._setupSvg(), [
                                            4,
                                            this._svgDrawingPromise
                                        ]);
                                    case 1:
                                        return e.sent(), [
                                            2,
                                            this._svg
                                        ];
                                    case 2:
                                        return this._canvas && this._canvasDrawingPromise || this._setupCanvas(), [
                                            4,
                                            this._canvasDrawingPromise
                                        ];
                                    case 3:
                                        return e.sent(), [
                                            2,
                                            this._canvas
                                        ];
                                }
                            });
                        });
                    }, t.prototype.update = function(e) {
                        t._clearContainer(this._container), this._options = e ? L(h(this._options, e)) : this._options, this._options.data && (this._qr = N()(this._options.qrOptions.typeNumber, this._options.qrOptions.errorCorrectionLevel), this._qr.addData(this._options.data, this._options.qrOptions.mode || function(t) {
                            switch(!0){
                                case /^[0-9]*$/.test(t):
                                    return n;
                                case /^[0-9A-Z $%*+\-./:]*$/.test(t):
                                    return i;
                                default:
                                    return o;
                            }
                        }(this._options.data)), this._qr.make(), this._options.type === P ? this._setupCanvas() : this._setupSvg(), this.append(this._container));
                    }, t.prototype.append = function(t) {
                        if (t) {
                            if ("function" != typeof t.appendChild) throw "Container should be a single DOM node";
                            this._options.type === P ? this._canvas && t.appendChild(this._canvas) : this._svg && t.appendChild(this._svg), this._container = t;
                        }
                    }, t.prototype.applyExtension = function(t) {
                        if (!t) throw "Extension function should be defined.";
                        this._extension = t, this.update();
                    }, t.prototype.deleteExtension = function() {
                        this._extension = void 0, this.update();
                    }, t.prototype.getRawData = function(t) {
                        return void 0 === t && (t = "png"), j(this, void 0, void 0, function() {
                            var e, r, n;
                            return T(this, function(i) {
                                switch(i.label){
                                    case 0:
                                        if (!this._qr) throw "QR code is empty";
                                        return [
                                            4,
                                            this._getElement(t)
                                        ];
                                    case 1:
                                        return (e = i.sent()) ? "svg" === t.toLowerCase() ? (r = new XMLSerializer, n = r.serializeToString(e), [
                                            2,
                                            new Blob([
                                                '<?xml version="1.0" standalone="no"?>\r\n' + n
                                            ], {
                                                type: "image/svg+xml"
                                            })
                                        ]) : [
                                            2,
                                            new Promise(function(r) {
                                                return e.toBlob(r, "image/" + t, 1);
                                            })
                                        ] : [
                                            2,
                                            null
                                        ];
                                }
                            });
                        });
                    }, t.prototype.download = function(t) {
                        return j(this, void 0, void 0, function() {
                            var e, r, n, i, o;
                            return T(this, function(a) {
                                switch(a.label){
                                    case 0:
                                        if (!this._qr) throw "QR code is empty";
                                        return e = "png", r = "qr", "string" == typeof t ? (e = t, console.warn("Extension is deprecated as argument for 'download' method, please pass object { name: '...', extension: '...' } as argument")) : "object" == typeof t && null !== t && (t.name && (r = t.name), t.extension && (e = t.extension)), [
                                            4,
                                            this._getElement(e)
                                        ];
                                    case 1:
                                        return (n = a.sent()) ? ("svg" === e.toLowerCase() ? (i = new XMLSerializer, o = '<?xml version="1.0" standalone="no"?>\r\n' + (o = i.serializeToString(n)), c("data:image/svg+xml;charset=utf-8," + encodeURIComponent(o), r + ".svg")) : c(n.toDataURL("image/" + e), r + "." + e), [
                                            2
                                        ]) : [
                                            2
                                        ];
                                }
                            });
                        });
                    }, t;
                }();
            }
        }, e = {};
        function r(n) {
            if (e[n]) return e[n].exports;
            var i = e[n] = {
                exports: {}
            };
            return t[n](i, i.exports, r), i.exports;
        }
        return r.n = (t)=>{
            var e = t && t.__esModule ? ()=>t.default : ()=>t;
            return r.d(e, {
                a: e
            }), e;
        }, r.d = (t, e)=>{
            for(var n in e)r.o(e, n) && !r.o(t, n) && Object.defineProperty(t, n, {
                enumerable: !0,
                get: e[n]
            });
        }, r.o = (t, e)=>Object.prototype.hasOwnProperty.call(t, e), r(676);
    })().default;
});

},{}],"4AJJw":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Thrown when a valid transaction can't be created from the inputs provided.
 */ parcelHelpers.export(exports, "CreateTransactionError", ()=>CreateTransactionError);
/**
 * Create a Solana Pay transaction.
 *
 * **Reference** implementation for wallet providers.
 *
 * @param connection - A connection to the cluster.
 * @param payer - `PublicKey` of the payer.
 * @param recipient - `recipient` in the [Solana Pay spec](https://github.com/solana-labs/solana-pay/blob/master/SPEC.md#recipient)
 * @param amount - `amount` in the [Solana Pay spec](https://github.com/solana-labs/solana-pay/blob/master/SPEC.md#amount)
 * @param {CreateTransactionParams} createTransactionParams - Additional parameters
 * @param createTransactionParams.splToken
 * @param createTransactionParams.reference
 * @param createTransactionParams.memo
 */ parcelHelpers.export(exports, "createTransaction", ()=>createTransaction);
var _splToken = require("@solana/spl-token");
var _web3Js = require("@solana/web3.js");
var _bignumberJs = require("bignumber.js");
var _bignumberJsDefault = parcelHelpers.interopDefault(_bignumberJs);
var _constantsMjs = require("./constants.mjs");
var Buffer = require("d038580faa04c705").Buffer;
class CreateTransactionError extends Error {
    constructor(){
        super(...arguments);
        this.name = "CreateTransactionError";
    }
}
async function createTransaction(connection, payer, recipient, amount, { splToken, reference, memo } = {}) {
    // Check that the payer and recipient accounts exist
    const payerInfo = await connection.getAccountInfo(payer);
    if (!payerInfo) throw new CreateTransactionError("payer not found");
    const recipientInfo = await connection.getAccountInfo(recipient);
    if (!recipientInfo) throw new CreateTransactionError("recipient not found");
    // A native SOL or SPL token transfer instruction
    let instruction;
    // If no SPL token mint is provided, transfer native SOL
    if (!splToken) {
        // Check that the payer and recipient are valid native accounts
        if (!payerInfo.owner.equals((0, _web3Js.SystemProgram).programId)) throw new CreateTransactionError("payer owner invalid");
        if (payerInfo.executable) throw new CreateTransactionError("payer executable");
        if (!recipientInfo.owner.equals((0, _web3Js.SystemProgram).programId)) throw new CreateTransactionError("recipient owner invalid");
        if (recipientInfo.executable) throw new CreateTransactionError("recipient executable");
        // Check that the amount provided doesn't have greater precision than SOL
        if (amount.decimalPlaces() > (0, _constantsMjs.SOL_DECIMALS)) throw new CreateTransactionError("amount decimals invalid");
        // Convert input decimal amount to integer lamports
        amount = amount.times((0, _web3Js.LAMPORTS_PER_SOL)).integerValue((0, _bignumberJsDefault.default).ROUND_FLOOR);
        // Check that the payer has enough lamports
        const lamports = amount.toNumber();
        if (lamports > payerInfo.lamports) throw new CreateTransactionError("insufficient funds");
        // Create an instruction to transfer native SOL
        instruction = (0, _web3Js.SystemProgram).transfer({
            fromPubkey: payer,
            toPubkey: recipient,
            lamports
        });
    } else {
        // Check that the token provided is an initialized mint
        const mint = await (0, _splToken.getMint)(connection, splToken);
        if (!mint.isInitialized) throw new CreateTransactionError("mint not initialized");
        // Check that the amount provided doesn't have greater precision than the mint
        if (amount.decimalPlaces() > mint.decimals) throw new CreateTransactionError("amount decimals invalid");
        // Convert input decimal amount to integer tokens according to the mint decimals
        amount = amount.times((0, _constantsMjs.TEN).pow(mint.decimals)).integerValue((0, _bignumberJsDefault.default).ROUND_FLOOR);
        // Get the payer's ATA and check that the account exists and can send tokens
        const payerATA = await (0, _splToken.getAssociatedTokenAddress)(splToken, payer);
        const payerAccount = await (0, _splToken.getAccount)(connection, payerATA);
        if (!payerAccount.isInitialized) throw new CreateTransactionError("payer not initialized");
        if (payerAccount.isFrozen) throw new CreateTransactionError("payer frozen");
        // Get the recipient's ATA and check that the account exists and can receive tokens
        const recipientATA = await (0, _splToken.getAssociatedTokenAddress)(splToken, recipient);
        const recipientAccount = await (0, _splToken.getAccount)(connection, recipientATA);
        if (!recipientAccount.isInitialized) throw new CreateTransactionError("recipient not initialized");
        if (recipientAccount.isFrozen) throw new CreateTransactionError("recipient frozen");
        // Check that the payer has enough tokens
        const tokens = BigInt(String(amount));
        if (tokens > payerAccount.amount) throw new CreateTransactionError("insufficient funds");
        // Create an instruction to transfer SPL tokens, asserting the mint and decimals match
        instruction = (0, _splToken.createTransferCheckedInstruction)(payerATA, splToken, recipientATA, payer, tokens, mint.decimals);
    }
    // If reference accounts are provided, add them to the transfer instruction
    if (reference) {
        if (!Array.isArray(reference)) reference = [
            reference
        ];
        for (const pubkey of reference)instruction.keys.push({
            pubkey,
            isWritable: false,
            isSigner: false
        });
    }
    // Create the transaction
    const transaction = new (0, _web3Js.Transaction)();
    // If a memo is provided, add it to the transaction before adding the transfer instruction
    if (memo != null) transaction.add(new (0, _web3Js.TransactionInstruction)({
        programId: (0, _constantsMjs.MEMO_PROGRAM_ID),
        keys: [],
        data: Buffer.from(memo, "utf8")
    }));
    // Add the transfer instruction to the transaction
    transaction.add(instruction);
    return transaction;
}

},{"d038580faa04c705":"fCgem","@solana/spl-token":"7lwom","@solana/web3.js":"5JBKN","bignumber.js":"57qkX","./constants.mjs":"6sOvE","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7lwom":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _indexMjs = require("./instructions/index.mjs");
parcelHelpers.exportAll(_indexMjs, exports);
var _indexMjs1 = require("./state/index.mjs");
parcelHelpers.exportAll(_indexMjs1, exports);
var _indexMjs2 = require("./actions/index.mjs");
parcelHelpers.exportAll(_indexMjs2, exports);
var _constantsMjs = require("./constants.mjs");
parcelHelpers.exportAll(_constantsMjs, exports);
var _errorsMjs = require("./errors.mjs");
parcelHelpers.exportAll(_errorsMjs, exports);

},{"./instructions/index.mjs":"4LHfF","./state/index.mjs":"d4xGL","./actions/index.mjs":"kWcXy","./constants.mjs":"dBO94","./errors.mjs":"3x3WE","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4LHfF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _typesMjs = require("./types.mjs");
parcelHelpers.exportAll(_typesMjs, exports);
var _initializeMintMjs = require("./initializeMint.mjs"); //       0
parcelHelpers.exportAll(_initializeMintMjs, exports);
var _initializeAccountMjs = require("./initializeAccount.mjs"); //    1
parcelHelpers.exportAll(_initializeAccountMjs, exports);
var _initializeMultisigMjs = require("./initializeMultisig.mjs"); //   2
parcelHelpers.exportAll(_initializeMultisigMjs, exports);
var _transferMjs = require("./transfer.mjs"); //             3
parcelHelpers.exportAll(_transferMjs, exports);
var _approveMjs = require("./approve.mjs"); //              4
parcelHelpers.exportAll(_approveMjs, exports);
var _revokeMjs = require("./revoke.mjs"); //               5
parcelHelpers.exportAll(_revokeMjs, exports);
var _setAuthorityMjs = require("./setAuthority.mjs"); //         6
parcelHelpers.exportAll(_setAuthorityMjs, exports);
var _mintToMjs = require("./mintTo.mjs"); //               7
parcelHelpers.exportAll(_mintToMjs, exports);
var _burnMjs = require("./burn.mjs"); //                 8
parcelHelpers.exportAll(_burnMjs, exports);
var _closeAccountMjs = require("./closeAccount.mjs"); //         9
parcelHelpers.exportAll(_closeAccountMjs, exports);
var _freezeAccountMjs = require("./freezeAccount.mjs"); //       10
parcelHelpers.exportAll(_freezeAccountMjs, exports);
var _thawAccountMjs = require("./thawAccount.mjs"); //         11
parcelHelpers.exportAll(_thawAccountMjs, exports);
var _transferCheckedMjs = require("./transferChecked.mjs"); //     12
parcelHelpers.exportAll(_transferCheckedMjs, exports);
var _approveCheckedMjs = require("./approveChecked.mjs"); //      13
parcelHelpers.exportAll(_approveCheckedMjs, exports);
var _mintToCheckedMjs = require("./mintToChecked.mjs"); //       14
parcelHelpers.exportAll(_mintToCheckedMjs, exports);
var _burnCheckedMjs = require("./burnChecked.mjs"); //         15
parcelHelpers.exportAll(_burnCheckedMjs, exports);
var _initializeAccount2Mjs = require("./initializeAccount2.mjs"); //  16
parcelHelpers.exportAll(_initializeAccount2Mjs, exports);
var _syncNativeMjs = require("./syncNative.mjs"); //          17
parcelHelpers.exportAll(_syncNativeMjs, exports);
var _initializeAccount3Mjs = require("./initializeAccount3.mjs"); //  18
parcelHelpers.exportAll(_initializeAccount3Mjs, exports);
var _initializeMultisig2Mjs = require("./initializeMultisig2.mjs"); // 19
parcelHelpers.exportAll(_initializeMultisig2Mjs, exports);
var _initializeMint2Mjs = require("./initializeMint2.mjs"); //     20
parcelHelpers.exportAll(_initializeMint2Mjs, exports);
var _decodeMjs = require("./decode.mjs");
parcelHelpers.exportAll(_decodeMjs, exports);
var _associatedTokenAccountMjs = require("./associatedTokenAccount.mjs");
parcelHelpers.exportAll(_associatedTokenAccountMjs, exports);

},{"./types.mjs":"fLCUz","./initializeMint.mjs":"j0VMi","./initializeAccount.mjs":"5cBHp","./initializeMultisig.mjs":"aub37","./transfer.mjs":"jg6EO","./approve.mjs":"kXgfG","./revoke.mjs":"lqKWe","./setAuthority.mjs":"c1Rco","./mintTo.mjs":"zvv9V","./burn.mjs":"asBxd","./closeAccount.mjs":"hLvDh","./freezeAccount.mjs":"9WKle","./thawAccount.mjs":"9TrcN","./transferChecked.mjs":"hYWCZ","./approveChecked.mjs":"8BTgm","./mintToChecked.mjs":"lAUnV","./burnChecked.mjs":"5zGbF","./initializeAccount2.mjs":"4z5Ob","./syncNative.mjs":"hlXvc","./initializeAccount3.mjs":"gWJWL","./initializeMultisig2.mjs":"3uZCv","./initializeMint2.mjs":"1EwBB","./decode.mjs":"glsNO","./associatedTokenAccount.mjs":"iat4R","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fLCUz":[function(require,module,exports) {
/** Instructions defined by the program */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "TokenInstruction", ()=>TokenInstruction);
var TokenInstruction;
(function(TokenInstruction) {
    TokenInstruction[TokenInstruction["InitializeMint"] = 0] = "InitializeMint";
    TokenInstruction[TokenInstruction["InitializeAccount"] = 1] = "InitializeAccount";
    TokenInstruction[TokenInstruction["InitializeMultisig"] = 2] = "InitializeMultisig";
    TokenInstruction[TokenInstruction["Transfer"] = 3] = "Transfer";
    TokenInstruction[TokenInstruction["Approve"] = 4] = "Approve";
    TokenInstruction[TokenInstruction["Revoke"] = 5] = "Revoke";
    TokenInstruction[TokenInstruction["SetAuthority"] = 6] = "SetAuthority";
    TokenInstruction[TokenInstruction["MintTo"] = 7] = "MintTo";
    TokenInstruction[TokenInstruction["Burn"] = 8] = "Burn";
    TokenInstruction[TokenInstruction["CloseAccount"] = 9] = "CloseAccount";
    TokenInstruction[TokenInstruction["FreezeAccount"] = 10] = "FreezeAccount";
    TokenInstruction[TokenInstruction["ThawAccount"] = 11] = "ThawAccount";
    TokenInstruction[TokenInstruction["TransferChecked"] = 12] = "TransferChecked";
    TokenInstruction[TokenInstruction["ApproveChecked"] = 13] = "ApproveChecked";
    TokenInstruction[TokenInstruction["MintToChecked"] = 14] = "MintToChecked";
    TokenInstruction[TokenInstruction["BurnChecked"] = 15] = "BurnChecked";
    TokenInstruction[TokenInstruction["InitializeAccount2"] = 16] = "InitializeAccount2";
    TokenInstruction[TokenInstruction["SyncNative"] = 17] = "SyncNative";
    TokenInstruction[TokenInstruction["InitializeAccount3"] = 18] = "InitializeAccount3";
    TokenInstruction[TokenInstruction["InitializeMultisig2"] = 19] = "InitializeMultisig2";
    TokenInstruction[TokenInstruction["InitializeMint2"] = 20] = "InitializeMint2";
})(TokenInstruction || (TokenInstruction = {}));

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"j0VMi":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "initializeMintInstructionData", ()=>initializeMintInstructionData);
/**
 * Construct an InitializeMint instruction
 *
 * @param mint            Token mint account
 * @param decimals        Number of decimals in token account amounts
 * @param mintAuthority   Minting authority
 * @param freezeAuthority Optional authority that can freeze token accounts
 * @param programId       SPL Token program account
 *
 * @return Instruction to add to a transaction
 */ parcelHelpers.export(exports, "createInitializeMintInstruction", ()=>createInitializeMintInstruction);
/**
 * Decode an InitializeMint instruction and validate it
 *
 * @param instruction Transaction instruction to decode
 * @param programId   SPL Token program account
 *
 * @return Decoded, valid instruction
 */ parcelHelpers.export(exports, "decodeInitializeMintInstruction", ()=>decodeInitializeMintInstruction);
/**
 * Decode an InitializeMint instruction without validating it
 *
 * @param instruction Transaction instruction to decode
 *
 * @return Decoded, non-validated instruction
 */ parcelHelpers.export(exports, "decodeInitializeMintInstructionUnchecked", ()=>decodeInitializeMintInstructionUnchecked);
var _bufferLayout = require("@solana/buffer-layout");
var _bufferLayoutUtils = require("@solana/buffer-layout-utils");
var _web3Js = require("@solana/web3.js");
var _constantsMjs = require("./../constants.mjs");
var _errorsMjs = require("./../errors.mjs");
var _typesMjs = require("./types.mjs");
var Buffer = require("ff627a71039596f3").Buffer;
const initializeMintInstructionData = (0, _bufferLayout.struct)([
    (0, _bufferLayout.u8)("instruction"),
    (0, _bufferLayout.u8)("decimals"),
    (0, _bufferLayoutUtils.publicKey)("mintAuthority"),
    (0, _bufferLayout.u8)("freezeAuthorityOption"),
    (0, _bufferLayoutUtils.publicKey)("freezeAuthority")
]);
function createInitializeMintInstruction(mint, decimals, mintAuthority, freezeAuthority, programId = (0, _constantsMjs.TOKEN_PROGRAM_ID)) {
    const keys = [
        {
            pubkey: mint,
            isSigner: false,
            isWritable: true
        },
        {
            pubkey: (0, _web3Js.SYSVAR_RENT_PUBKEY),
            isSigner: false,
            isWritable: false
        }
    ];
    const data = Buffer.alloc(initializeMintInstructionData.span);
    initializeMintInstructionData.encode({
        instruction: (0, _typesMjs.TokenInstruction).InitializeMint,
        decimals,
        mintAuthority,
        freezeAuthorityOption: freezeAuthority ? 1 : 0,
        freezeAuthority: freezeAuthority || new (0, _web3Js.PublicKey)(0)
    }, data);
    return new (0, _web3Js.TransactionInstruction)({
        keys,
        programId,
        data
    });
}
function decodeInitializeMintInstruction(instruction, programId = (0, _constantsMjs.TOKEN_PROGRAM_ID)) {
    if (!instruction.programId.equals(programId)) throw new (0, _errorsMjs.TokenInvalidInstructionProgramError)();
    if (instruction.data.length !== initializeMintInstructionData.span) throw new (0, _errorsMjs.TokenInvalidInstructionDataError)();
    const { keys: { mint, rent }, data } = decodeInitializeMintInstructionUnchecked(instruction);
    if (data.instruction !== (0, _typesMjs.TokenInstruction).InitializeMint) throw new (0, _errorsMjs.TokenInvalidInstructionTypeError)();
    if (!mint || !rent) throw new (0, _errorsMjs.TokenInvalidInstructionKeysError)();
    // TODO: key checks?
    return {
        programId,
        keys: {
            mint,
            rent
        },
        data
    };
}
function decodeInitializeMintInstructionUnchecked({ programId, keys: [mint, rent], data }) {
    const { instruction, decimals, mintAuthority, freezeAuthorityOption, freezeAuthority } = initializeMintInstructionData.decode(data);
    return {
        programId,
        keys: {
            mint,
            rent
        },
        data: {
            instruction,
            decimals,
            mintAuthority,
            freezeAuthority: freezeAuthorityOption ? freezeAuthority : null
        }
    };
}

},{"ff627a71039596f3":"fCgem","@solana/buffer-layout":"jD9A8","@solana/buffer-layout-utils":"hVYs1","@solana/web3.js":"5JBKN","./../constants.mjs":"dBO94","./../errors.mjs":"3x3WE","./types.mjs":"fLCUz","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hVYs1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _baseMjs = require("./base.mjs");
parcelHelpers.exportAll(_baseMjs, exports);
var _bigintMjs = require("./bigint.mjs");
parcelHelpers.exportAll(_bigintMjs, exports);
var _decimalMjs = require("./decimal.mjs");
parcelHelpers.exportAll(_decimalMjs, exports);
var _nativeMjs = require("./native.mjs");
parcelHelpers.exportAll(_nativeMjs, exports);
var _web3Mjs = require("./web3.mjs");
parcelHelpers.exportAll(_web3Mjs, exports);

},{"./base.mjs":"YgV4d","./bigint.mjs":"gMTn8","./decimal.mjs":"hezB1","./native.mjs":"jf9pw","./web3.mjs":"c1ae8","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"YgV4d":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "encodeDecode", ()=>encodeDecode);
const encodeDecode = (layout)=>{
    const decode = layout.decode.bind(layout);
    const encode = layout.encode.bind(layout);
    return {
        decode,
        encode
    };
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gMTn8":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "bigInt", ()=>bigInt);
parcelHelpers.export(exports, "bigIntBE", ()=>bigIntBE);
parcelHelpers.export(exports, "u64", ()=>u64);
parcelHelpers.export(exports, "u64be", ()=>u64be);
parcelHelpers.export(exports, "u128", ()=>u128);
parcelHelpers.export(exports, "u128be", ()=>u128be);
parcelHelpers.export(exports, "u192", ()=>u192);
parcelHelpers.export(exports, "u192be", ()=>u192be);
parcelHelpers.export(exports, "u256", ()=>u256);
parcelHelpers.export(exports, "u256be", ()=>u256be);
var _bufferLayout = require("@solana/buffer-layout");
var _bigintBuffer = require("bigint-buffer");
var _baseMjs = require("./base.mjs");
var Buffer = require("3760fda638a9c84c").Buffer;
const bigInt = (length)=>(property)=>{
        const layout = (0, _bufferLayout.blob)(length, property);
        const { encode, decode } = (0, _baseMjs.encodeDecode)(layout);
        const bigIntLayout = layout;
        bigIntLayout.decode = (buffer, offset)=>{
            const src = decode(buffer, offset);
            return (0, _bigintBuffer.toBigIntLE)(Buffer.from(src));
        };
        bigIntLayout.encode = (bigInt, buffer, offset)=>{
            const src = (0, _bigintBuffer.toBufferLE)(bigInt, length);
            return encode(src, buffer, offset);
        };
        return bigIntLayout;
    };
const bigIntBE = (length)=>(property)=>{
        const layout = (0, _bufferLayout.blob)(length, property);
        const { encode, decode } = (0, _baseMjs.encodeDecode)(layout);
        const bigIntLayout = layout;
        bigIntLayout.decode = (buffer, offset)=>{
            const src = decode(buffer, offset);
            return (0, _bigintBuffer.toBigIntBE)(Buffer.from(src));
        };
        bigIntLayout.encode = (bigInt, buffer, offset)=>{
            const src = (0, _bigintBuffer.toBufferBE)(bigInt, length);
            return encode(src, buffer, offset);
        };
        return bigIntLayout;
    };
const u64 = bigInt(8);
const u64be = bigIntBE(8);
const u128 = bigInt(16);
const u128be = bigIntBE(16);
const u192 = bigInt(24);
const u192be = bigIntBE(24);
const u256 = bigInt(32);
const u256be = bigIntBE(32);

},{"3760fda638a9c84c":"fCgem","@solana/buffer-layout":"jD9A8","bigint-buffer":"b5EGn","./base.mjs":"YgV4d","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hezB1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "WAD", ()=>WAD);
parcelHelpers.export(exports, "decimal", ()=>decimal);
var _bignumberJs = require("bignumber.js");
var _bignumberJsDefault = parcelHelpers.interopDefault(_bignumberJs);
var _baseMjs = require("./base.mjs");
var _bigintMjs = require("./bigint.mjs");
const WAD = new (0, _bignumberJsDefault.default)("1e+18");
const decimal = (property)=>{
    const layout = (0, _bigintMjs.u128)(property);
    const { encode, decode } = (0, _baseMjs.encodeDecode)(layout);
    const decimalLayout = layout;
    decimalLayout.decode = (buffer, offset)=>{
        const src = decode(buffer, offset).toString();
        return new (0, _bignumberJsDefault.default)(src).div(WAD);
    };
    decimalLayout.encode = (decimal, buffer, offset)=>{
        const src = BigInt(decimal.times(WAD).integerValue().toString());
        return encode(src, buffer, offset);
    };
    return decimalLayout;
};

},{"bignumber.js":"57qkX","./base.mjs":"YgV4d","./bigint.mjs":"gMTn8","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jf9pw":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "bool", ()=>bool);
var _bufferLayout = require("@solana/buffer-layout");
var _baseMjs = require("./base.mjs");
const bool = (property)=>{
    const layout = (0, _bufferLayout.u8)(property);
    const { encode, decode } = (0, _baseMjs.encodeDecode)(layout);
    const boolLayout = layout;
    boolLayout.decode = (buffer, offset)=>{
        const src = decode(buffer, offset);
        return !!src;
    };
    boolLayout.encode = (bool, buffer, offset)=>{
        const src = Number(bool);
        return encode(src, buffer, offset);
    };
    return boolLayout;
};

},{"@solana/buffer-layout":"jD9A8","./base.mjs":"YgV4d","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"c1ae8":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "publicKey", ()=>publicKey);
var _bufferLayout = require("@solana/buffer-layout");
var _web3Js = require("@solana/web3.js");
var _baseMjs = require("./base.mjs");
const publicKey = (property)=>{
    const layout = (0, _bufferLayout.blob)(32, property);
    const { encode, decode } = (0, _baseMjs.encodeDecode)(layout);
    const publicKeyLayout = layout;
    publicKeyLayout.decode = (buffer, offset)=>{
        const src = decode(buffer, offset);
        return new (0, _web3Js.PublicKey)(src);
    };
    publicKeyLayout.encode = (publicKey, buffer, offset)=>{
        const src = publicKey.toBuffer();
        return encode(src, buffer, offset);
    };
    return publicKeyLayout;
};

},{"@solana/buffer-layout":"jD9A8","@solana/web3.js":"5JBKN","./base.mjs":"YgV4d","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dBO94":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "TOKEN_PROGRAM_ID", ()=>TOKEN_PROGRAM_ID);
parcelHelpers.export(exports, "ASSOCIATED_TOKEN_PROGRAM_ID", ()=>ASSOCIATED_TOKEN_PROGRAM_ID);
parcelHelpers.export(exports, "NATIVE_MINT", ()=>NATIVE_MINT);
var _web3Js = require("@solana/web3.js");
const TOKEN_PROGRAM_ID = new (0, _web3Js.PublicKey)("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA");
const ASSOCIATED_TOKEN_PROGRAM_ID = new (0, _web3Js.PublicKey)("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL");
const NATIVE_MINT = new (0, _web3Js.PublicKey)("So11111111111111111111111111111111111111112");

},{"@solana/web3.js":"5JBKN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3x3WE":[function(require,module,exports) {
/** Base class for errors */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "TokenError", ()=>TokenError);
/** Thrown if an account is not found at the expected address */ parcelHelpers.export(exports, "TokenAccountNotFoundError", ()=>TokenAccountNotFoundError);
/** Thrown if a program state account is not owned by the expected token program */ parcelHelpers.export(exports, "TokenInvalidAccountOwnerError", ()=>TokenInvalidAccountOwnerError);
/** Thrown if the byte length of an program state account doesn't match the expected size */ parcelHelpers.export(exports, "TokenInvalidAccountSizeError", ()=>TokenInvalidAccountSizeError);
/** Thrown if the mint of a token account doesn't match the expected mint */ parcelHelpers.export(exports, "TokenInvalidMintError", ()=>TokenInvalidMintError);
/** Thrown if the owner of a token account doesn't match the expected owner */ parcelHelpers.export(exports, "TokenInvalidOwnerError", ()=>TokenInvalidOwnerError);
/** Thrown if the owner of a token account is a PDA (Program Derived Address) */ parcelHelpers.export(exports, "TokenOwnerOffCurveError", ()=>TokenOwnerOffCurveError);
/** Thrown if an instruction's program is invalid */ parcelHelpers.export(exports, "TokenInvalidInstructionProgramError", ()=>TokenInvalidInstructionProgramError);
/** Thrown if an instruction's keys are invalid */ parcelHelpers.export(exports, "TokenInvalidInstructionKeysError", ()=>TokenInvalidInstructionKeysError);
/** Thrown if an instruction's data is invalid */ parcelHelpers.export(exports, "TokenInvalidInstructionDataError", ()=>TokenInvalidInstructionDataError);
/** Thrown if an instruction's type is invalid */ parcelHelpers.export(exports, "TokenInvalidInstructionTypeError", ()=>TokenInvalidInstructionTypeError);
class TokenError extends Error {
    constructor(message){
        super(message);
    }
}
class TokenAccountNotFoundError extends TokenError {
    constructor(){
        super(...arguments);
        this.name = "TokenAccountNotFoundError";
    }
}
class TokenInvalidAccountOwnerError extends TokenError {
    constructor(){
        super(...arguments);
        this.name = "TokenInvalidAccountOwnerError";
    }
}
class TokenInvalidAccountSizeError extends TokenError {
    constructor(){
        super(...arguments);
        this.name = "TokenInvalidAccountSizeError";
    }
}
class TokenInvalidMintError extends TokenError {
    constructor(){
        super(...arguments);
        this.name = "TokenInvalidMintError";
    }
}
class TokenInvalidOwnerError extends TokenError {
    constructor(){
        super(...arguments);
        this.name = "TokenInvalidOwnerError";
    }
}
class TokenOwnerOffCurveError extends TokenError {
    constructor(){
        super(...arguments);
        this.name = "TokenOwnerOffCurveError";
    }
}
class TokenInvalidInstructionProgramError extends TokenError {
    constructor(){
        super(...arguments);
        this.name = "TokenInvalidInstructionProgramError";
    }
}
class TokenInvalidInstructionKeysError extends TokenError {
    constructor(){
        super(...arguments);
        this.name = "TokenInvalidInstructionKeysError";
    }
}
class TokenInvalidInstructionDataError extends TokenError {
    constructor(){
        super(...arguments);
        this.name = "TokenInvalidInstructionDataError";
    }
}
class TokenInvalidInstructionTypeError extends TokenError {
    constructor(){
        super(...arguments);
        this.name = "TokenInvalidInstructionTypeError";
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5cBHp":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "initializeAccountInstructionData", ()=>initializeAccountInstructionData);
/**
 * Construct an InitializeAccount instruction
 *
 * @param account   New token account
 * @param mint      Mint account
 * @param owner     Owner of the new account
 * @param programId SPL Token program account
 *
 * @return Instruction to add to a transaction
 */ parcelHelpers.export(exports, "createInitializeAccountInstruction", ()=>createInitializeAccountInstruction);
/**
 * Decode an InitializeAccount instruction and validate it
 *
 * @param instruction Transaction instruction to decode
 * @param programId   SPL Token program account
 *
 * @return Decoded, valid instruction
 */ parcelHelpers.export(exports, "decodeInitializeAccountInstruction", ()=>decodeInitializeAccountInstruction);
/**
 * Decode an InitializeAccount instruction without validating it
 *
 * @param instruction Transaction instruction to decode
 *
 * @return Decoded, non-validated instruction
 */ parcelHelpers.export(exports, "decodeInitializeAccountInstructionUnchecked", ()=>decodeInitializeAccountInstructionUnchecked);
var _bufferLayout = require("@solana/buffer-layout");
var _web3Js = require("@solana/web3.js");
var _constantsMjs = require("./../constants.mjs");
var _errorsMjs = require("./../errors.mjs");
var _typesMjs = require("./types.mjs");
var Buffer = require("aeb27310f91c1844").Buffer;
const initializeAccountInstructionData = (0, _bufferLayout.struct)([
    (0, _bufferLayout.u8)("instruction")
]);
function createInitializeAccountInstruction(account, mint, owner, programId = (0, _constantsMjs.TOKEN_PROGRAM_ID)) {
    const keys = [
        {
            pubkey: account,
            isSigner: false,
            isWritable: true
        },
        {
            pubkey: mint,
            isSigner: false,
            isWritable: false
        },
        {
            pubkey: owner,
            isSigner: false,
            isWritable: false
        },
        {
            pubkey: (0, _web3Js.SYSVAR_RENT_PUBKEY),
            isSigner: false,
            isWritable: false
        }
    ];
    const data = Buffer.alloc(initializeAccountInstructionData.span);
    initializeAccountInstructionData.encode({
        instruction: (0, _typesMjs.TokenInstruction).InitializeAccount
    }, data);
    return new (0, _web3Js.TransactionInstruction)({
        keys,
        programId,
        data
    });
}
function decodeInitializeAccountInstruction(instruction, programId = (0, _constantsMjs.TOKEN_PROGRAM_ID)) {
    if (!instruction.programId.equals(programId)) throw new (0, _errorsMjs.TokenInvalidInstructionProgramError)();
    if (instruction.data.length !== initializeAccountInstructionData.span) throw new (0, _errorsMjs.TokenInvalidInstructionDataError)();
    const { keys: { account, mint, owner, rent }, data } = decodeInitializeAccountInstructionUnchecked(instruction);
    if (data.instruction !== (0, _typesMjs.TokenInstruction).InitializeAccount) throw new (0, _errorsMjs.TokenInvalidInstructionTypeError)();
    if (!account || !mint || !owner || !rent) throw new (0, _errorsMjs.TokenInvalidInstructionKeysError)();
    // TODO: key checks?
    return {
        programId,
        keys: {
            account,
            mint,
            owner,
            rent
        },
        data
    };
}
function decodeInitializeAccountInstructionUnchecked({ programId, keys: [account, mint, owner, rent], data }) {
    return {
        programId,
        keys: {
            account,
            mint,
            owner,
            rent
        },
        data: initializeAccountInstructionData.decode(data)
    };
}

},{"aeb27310f91c1844":"fCgem","@solana/buffer-layout":"jD9A8","@solana/web3.js":"5JBKN","./../constants.mjs":"dBO94","./../errors.mjs":"3x3WE","./types.mjs":"fLCUz","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aub37":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "initializeMultisigInstructionData", ()=>initializeMultisigInstructionData);
/**
 * Construct an InitializeMultisig instruction
 *
 * @param account   Multisig account
 * @param signers   Full set of signers
 * @param m         Number of required signatures
 * @param programId SPL Token program account
 *
 * @return Instruction to add to a transaction
 */ parcelHelpers.export(exports, "createInitializeMultisigInstruction", ()=>createInitializeMultisigInstruction);
/**
 * Decode an InitializeMultisig instruction and validate it
 *
 * @param instruction Transaction instruction to decode
 * @param programId   SPL Token program account
 *
 * @return Decoded, valid instruction
 */ parcelHelpers.export(exports, "decodeInitializeMultisigInstruction", ()=>decodeInitializeMultisigInstruction);
/**
 * Decode an InitializeMultisig instruction without validating it
 *
 * @param instruction Transaction instruction to decode
 *
 * @return Decoded, non-validated instruction
 */ parcelHelpers.export(exports, "decodeInitializeMultisigInstructionUnchecked", ()=>decodeInitializeMultisigInstructionUnchecked);
var _bufferLayout = require("@solana/buffer-layout");
var _web3Js = require("@solana/web3.js");
var _constantsMjs = require("./../constants.mjs");
var _errorsMjs = require("./../errors.mjs");
var _typesMjs = require("./types.mjs");
var Buffer = require("4d2451f34e10ec66").Buffer;
const initializeMultisigInstructionData = (0, _bufferLayout.struct)([
    (0, _bufferLayout.u8)("instruction"),
    (0, _bufferLayout.u8)("m")
]);
function createInitializeMultisigInstruction(account, signers, m, programId = (0, _constantsMjs.TOKEN_PROGRAM_ID)) {
    const keys = [
        {
            pubkey: account,
            isSigner: false,
            isWritable: true
        },
        {
            pubkey: (0, _web3Js.SYSVAR_RENT_PUBKEY),
            isSigner: false,
            isWritable: false
        }
    ];
    for (const signer of signers)keys.push({
        pubkey: signer,
        isSigner: false,
        isWritable: false
    });
    const data = Buffer.alloc(initializeMultisigInstructionData.span);
    initializeMultisigInstructionData.encode({
        instruction: (0, _typesMjs.TokenInstruction).InitializeMultisig,
        m
    }, data);
    return new (0, _web3Js.TransactionInstruction)({
        keys,
        programId,
        data
    });
}
function decodeInitializeMultisigInstruction(instruction, programId = (0, _constantsMjs.TOKEN_PROGRAM_ID)) {
    if (!instruction.programId.equals(programId)) throw new (0, _errorsMjs.TokenInvalidInstructionProgramError)();
    if (instruction.data.length !== initializeMultisigInstructionData.span) throw new (0, _errorsMjs.TokenInvalidInstructionDataError)();
    const { keys: { account, rent, signers }, data } = decodeInitializeMultisigInstructionUnchecked(instruction);
    if (data.instruction !== (0, _typesMjs.TokenInstruction).InitializeMultisig) throw new (0, _errorsMjs.TokenInvalidInstructionTypeError)();
    if (!account || !rent || !signers.length) throw new (0, _errorsMjs.TokenInvalidInstructionKeysError)();
    // TODO: key checks?
    return {
        programId,
        keys: {
            account,
            rent,
            signers
        },
        data
    };
}
function decodeInitializeMultisigInstructionUnchecked({ programId, keys: [account, rent, ...signers], data }) {
    return {
        programId,
        keys: {
            account,
            rent,
            signers
        },
        data: initializeMultisigInstructionData.decode(data)
    };
}

},{"4d2451f34e10ec66":"fCgem","@solana/buffer-layout":"jD9A8","@solana/web3.js":"5JBKN","./../constants.mjs":"dBO94","./../errors.mjs":"3x3WE","./types.mjs":"fLCUz","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jg6EO":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "transferInstructionData", ()=>transferInstructionData);
/**
 * Construct a Transfer instruction
 *
 * @param source       Source account
 * @param destination  Destination account
 * @param owner        Owner of the source account
 * @param amount       Number of tokens to transfer
 * @param multiSigners Signing accounts if `owner` is a multisig
 * @param programId    SPL Token program account
 *
 * @return Instruction to add to a transaction
 */ parcelHelpers.export(exports, "createTransferInstruction", ()=>createTransferInstruction);
/**
 * Decode a Transfer instruction and validate it
 *
 * @param instruction Transaction instruction to decode
 * @param programId   SPL Token program account
 *
 * @return Decoded, valid instruction
 */ parcelHelpers.export(exports, "decodeTransferInstruction", ()=>decodeTransferInstruction);
/**
 * Decode a Transfer instruction without validating it
 *
 * @param instruction Transaction instruction to decode
 *
 * @return Decoded, non-validated instruction
 */ parcelHelpers.export(exports, "decodeTransferInstructionUnchecked", ()=>decodeTransferInstructionUnchecked);
var _bufferLayout = require("@solana/buffer-layout");
var _bufferLayoutUtils = require("@solana/buffer-layout-utils");
var _web3Js = require("@solana/web3.js");
var _constantsMjs = require("./../constants.mjs");
var _errorsMjs = require("./../errors.mjs");
var _internalMjs = require("./internal.mjs");
var _typesMjs = require("./types.mjs");
var Buffer = require("8501758f1ea0344").Buffer;
const transferInstructionData = (0, _bufferLayout.struct)([
    (0, _bufferLayout.u8)("instruction"),
    (0, _bufferLayoutUtils.u64)("amount")
]);
function createTransferInstruction(source, destination, owner, amount, multiSigners = [], programId = (0, _constantsMjs.TOKEN_PROGRAM_ID)) {
    const keys = (0, _internalMjs.addSigners)([
        {
            pubkey: source,
            isSigner: false,
            isWritable: true
        },
        {
            pubkey: destination,
            isSigner: false,
            isWritable: true
        }
    ], owner, multiSigners);
    const data = Buffer.alloc(transferInstructionData.span);
    transferInstructionData.encode({
        instruction: (0, _typesMjs.TokenInstruction).Transfer,
        amount: BigInt(amount)
    }, data);
    return new (0, _web3Js.TransactionInstruction)({
        keys,
        programId,
        data
    });
}
function decodeTransferInstruction(instruction, programId = (0, _constantsMjs.TOKEN_PROGRAM_ID)) {
    if (!instruction.programId.equals(programId)) throw new (0, _errorsMjs.TokenInvalidInstructionProgramError)();
    if (instruction.data.length !== transferInstructionData.span) throw new (0, _errorsMjs.TokenInvalidInstructionDataError)();
    const { keys: { source, destination, owner, multiSigners }, data } = decodeTransferInstructionUnchecked(instruction);
    if (data.instruction !== (0, _typesMjs.TokenInstruction).Transfer) throw new (0, _errorsMjs.TokenInvalidInstructionTypeError)();
    if (!source || !destination || !owner) throw new (0, _errorsMjs.TokenInvalidInstructionKeysError)();
    // TODO: key checks?
    return {
        programId,
        keys: {
            source,
            destination,
            owner,
            multiSigners
        },
        data
    };
}
function decodeTransferInstructionUnchecked({ programId, keys: [source, destination, owner, ...multiSigners], data }) {
    return {
        programId,
        keys: {
            source,
            destination,
            owner,
            multiSigners
        },
        data: transferInstructionData.decode(data)
    };
}

},{"8501758f1ea0344":"fCgem","@solana/buffer-layout":"jD9A8","@solana/buffer-layout-utils":"hVYs1","@solana/web3.js":"5JBKN","./../constants.mjs":"dBO94","./../errors.mjs":"3x3WE","./internal.mjs":"hvqv6","./types.mjs":"fLCUz","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hvqv6":[function(require,module,exports) {
/** @internal */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "addSigners", ()=>addSigners);
function addSigners(keys, ownerOrAuthority, multiSigners) {
    if (multiSigners.length) {
        keys.push({
            pubkey: ownerOrAuthority,
            isSigner: false,
            isWritable: false
        });
        for (const signer of multiSigners)keys.push({
            pubkey: signer.publicKey,
            isSigner: true,
            isWritable: false
        });
    } else keys.push({
        pubkey: ownerOrAuthority,
        isSigner: true,
        isWritable: false
    });
    return keys;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kXgfG":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "approveInstructionData", ()=>approveInstructionData);
/**
 * Construct an Approve instruction
 *
 * @param account      Account to set the delegate for
 * @param delegate     Account authorized to transfer tokens from the account
 * @param owner        Owner of the account
 * @param amount       Maximum number of tokens the delegate may transfer
 * @param multiSigners Signing accounts if `owner` is a multisig
 * @param programId    SPL Token program account
 *
 * @return Instruction to add to a transaction
 */ parcelHelpers.export(exports, "createApproveInstruction", ()=>createApproveInstruction);
/**
 * Decode an Approve instruction and validate it
 *
 * @param instruction Transaction instruction to decode
 * @param programId   SPL Token program account
 *
 * @return Decoded, valid instruction
 */ parcelHelpers.export(exports, "decodeApproveInstruction", ()=>decodeApproveInstruction);
/**
 * Decode an Approve instruction without validating it
 *
 * @param instruction Transaction instruction to decode
 *
 * @return Decoded, non-validated instruction
 */ parcelHelpers.export(exports, "decodeApproveInstructionUnchecked", ()=>decodeApproveInstructionUnchecked);
var _bufferLayout = require("@solana/buffer-layout");
var _bufferLayoutUtils = require("@solana/buffer-layout-utils");
var _web3Js = require("@solana/web3.js");
var _constantsMjs = require("./../constants.mjs");
var _errorsMjs = require("./../errors.mjs");
var _internalMjs = require("./internal.mjs");
var _typesMjs = require("./types.mjs");
var Buffer = require("53bdd5afaa6d7970").Buffer;
const approveInstructionData = (0, _bufferLayout.struct)([
    (0, _bufferLayout.u8)("instruction"),
    (0, _bufferLayoutUtils.u64)("amount")
]);
function createApproveInstruction(account, delegate, owner, amount, multiSigners = [], programId = (0, _constantsMjs.TOKEN_PROGRAM_ID)) {
    const keys = (0, _internalMjs.addSigners)([
        {
            pubkey: account,
            isSigner: false,
            isWritable: true
        },
        {
            pubkey: delegate,
            isSigner: false,
            isWritable: false
        }
    ], owner, multiSigners);
    const data = Buffer.alloc(approveInstructionData.span);
    approveInstructionData.encode({
        instruction: (0, _typesMjs.TokenInstruction).Approve,
        amount: BigInt(amount)
    }, data);
    return new (0, _web3Js.TransactionInstruction)({
        keys,
        programId,
        data
    });
}
function decodeApproveInstruction(instruction, programId = (0, _constantsMjs.TOKEN_PROGRAM_ID)) {
    if (!instruction.programId.equals(programId)) throw new (0, _errorsMjs.TokenInvalidInstructionProgramError)();
    if (instruction.data.length !== approveInstructionData.span) throw new (0, _errorsMjs.TokenInvalidInstructionDataError)();
    const { keys: { account, delegate, owner, multiSigners }, data } = decodeApproveInstructionUnchecked(instruction);
    if (data.instruction !== (0, _typesMjs.TokenInstruction).Approve) throw new (0, _errorsMjs.TokenInvalidInstructionTypeError)();
    if (!account || !delegate || !owner) throw new (0, _errorsMjs.TokenInvalidInstructionKeysError)();
    // TODO: key checks?
    return {
        programId,
        keys: {
            account,
            delegate,
            owner,
            multiSigners
        },
        data
    };
}
function decodeApproveInstructionUnchecked({ programId, keys: [account, delegate, owner, ...multiSigners], data }) {
    return {
        programId,
        keys: {
            account,
            delegate,
            owner,
            multiSigners
        },
        data: approveInstructionData.decode(data)
    };
}

},{"53bdd5afaa6d7970":"fCgem","@solana/buffer-layout":"jD9A8","@solana/buffer-layout-utils":"hVYs1","@solana/web3.js":"5JBKN","./../constants.mjs":"dBO94","./../errors.mjs":"3x3WE","./internal.mjs":"hvqv6","./types.mjs":"fLCUz","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lqKWe":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "revokeInstructionData", ()=>revokeInstructionData);
/**
 * Construct a Revoke instruction
 *
 * @param account      Address of the token account
 * @param owner        Owner of the account
 * @param multiSigners Signing accounts if `owner` is a multisig
 * @param programId    SPL Token program account
 *
 * @return Instruction to add to a transaction
 */ parcelHelpers.export(exports, "createRevokeInstruction", ()=>createRevokeInstruction);
/**
 * Decode a Revoke instruction and validate it
 *
 * @param instruction Transaction instruction to decode
 * @param programId   SPL Token program account
 *
 * @return Decoded, valid instruction
 */ parcelHelpers.export(exports, "decodeRevokeInstruction", ()=>decodeRevokeInstruction);
/**
 * Decode a Revoke instruction without validating it
 *
 * @param instruction Transaction instruction to decode
 *
 * @return Decoded, non-validated instruction
 */ parcelHelpers.export(exports, "decodeRevokeInstructionUnchecked", ()=>decodeRevokeInstructionUnchecked);
var _bufferLayout = require("@solana/buffer-layout");
var _web3Js = require("@solana/web3.js");
var _constantsMjs = require("./../constants.mjs");
var _errorsMjs = require("./../errors.mjs");
var _internalMjs = require("./internal.mjs");
var _typesMjs = require("./types.mjs");
var Buffer = require("fedddcfc79bd25d0").Buffer;
const revokeInstructionData = (0, _bufferLayout.struct)([
    (0, _bufferLayout.u8)("instruction")
]);
function createRevokeInstruction(account, owner, multiSigners = [], programId = (0, _constantsMjs.TOKEN_PROGRAM_ID)) {
    const keys = (0, _internalMjs.addSigners)([
        {
            pubkey: account,
            isSigner: false,
            isWritable: true
        }
    ], owner, multiSigners);
    const data = Buffer.alloc(revokeInstructionData.span);
    revokeInstructionData.encode({
        instruction: (0, _typesMjs.TokenInstruction).Revoke
    }, data);
    return new (0, _web3Js.TransactionInstruction)({
        keys,
        programId,
        data
    });
}
function decodeRevokeInstruction(instruction, programId = (0, _constantsMjs.TOKEN_PROGRAM_ID)) {
    if (!instruction.programId.equals(programId)) throw new (0, _errorsMjs.TokenInvalidInstructionProgramError)();
    if (instruction.data.length !== revokeInstructionData.span) throw new (0, _errorsMjs.TokenInvalidInstructionDataError)();
    const { keys: { account, owner, multiSigners }, data } = decodeRevokeInstructionUnchecked(instruction);
    if (data.instruction !== (0, _typesMjs.TokenInstruction).Revoke) throw new (0, _errorsMjs.TokenInvalidInstructionTypeError)();
    if (!account || !owner) throw new (0, _errorsMjs.TokenInvalidInstructionKeysError)();
    // TODO: key checks?
    return {
        programId,
        keys: {
            account,
            owner,
            multiSigners
        },
        data
    };
}
function decodeRevokeInstructionUnchecked({ programId, keys: [account, owner, ...multiSigners], data }) {
    return {
        programId,
        keys: {
            account,
            owner,
            multiSigners
        },
        data: revokeInstructionData.decode(data)
    };
}

},{"fedddcfc79bd25d0":"fCgem","@solana/buffer-layout":"jD9A8","@solana/web3.js":"5JBKN","./../constants.mjs":"dBO94","./../errors.mjs":"3x3WE","./internal.mjs":"hvqv6","./types.mjs":"fLCUz","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"c1Rco":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AuthorityType", ()=>AuthorityType);
parcelHelpers.export(exports, "setAuthorityInstructionData", ()=>setAuthorityInstructionData);
/**
 * Construct a SetAuthority instruction
 *
 * @param account          Address of the token account
 * @param currentAuthority Current authority of the specified type
 * @param authorityType    Type of authority to set
 * @param newAuthority     New authority of the account
 * @param multiSigners     Signing accounts if `currentAuthority` is a multisig
 * @param programId        SPL Token program account
 *
 * @return Instruction to add to a transaction
 */ parcelHelpers.export(exports, "createSetAuthorityInstruction", ()=>createSetAuthorityInstruction);
/**
 * Decode a SetAuthority instruction and validate it
 *
 * @param instruction Transaction instruction to decode
 * @param programId   SPL Token program account
 *
 * @return Decoded, valid instruction
 */ parcelHelpers.export(exports, "decodeSetAuthorityInstruction", ()=>decodeSetAuthorityInstruction);
/**
 * Decode a SetAuthority instruction without validating it
 *
 * @param instruction Transaction instruction to decode
 *
 * @return Decoded, non-validated instruction
 */ parcelHelpers.export(exports, "decodeSetAuthorityInstructionUnchecked", ()=>decodeSetAuthorityInstructionUnchecked);
var _bufferLayout = require("@solana/buffer-layout");
var _bufferLayoutUtils = require("@solana/buffer-layout-utils");
var _web3Js = require("@solana/web3.js");
var _constantsMjs = require("./../constants.mjs");
var _errorsMjs = require("./../errors.mjs");
var _internalMjs = require("./internal.mjs");
var _typesMjs = require("./types.mjs");
var Buffer = require("6cc588d3a09e1b5e").Buffer;
var AuthorityType;
(function(AuthorityType) {
    AuthorityType[AuthorityType["MintTokens"] = 0] = "MintTokens";
    AuthorityType[AuthorityType["FreezeAccount"] = 1] = "FreezeAccount";
    AuthorityType[AuthorityType["AccountOwner"] = 2] = "AccountOwner";
    AuthorityType[AuthorityType["CloseAccount"] = 3] = "CloseAccount";
})(AuthorityType || (AuthorityType = {}));
const setAuthorityInstructionData = (0, _bufferLayout.struct)([
    (0, _bufferLayout.u8)("instruction"),
    (0, _bufferLayout.u8)("authorityType"),
    (0, _bufferLayout.u8)("newAuthorityOption"),
    (0, _bufferLayoutUtils.publicKey)("newAuthority")
]);
function createSetAuthorityInstruction(account, currentAuthority, authorityType, newAuthority, multiSigners = [], programId = (0, _constantsMjs.TOKEN_PROGRAM_ID)) {
    const keys = (0, _internalMjs.addSigners)([
        {
            pubkey: account,
            isSigner: false,
            isWritable: true
        }
    ], currentAuthority, multiSigners);
    const data = Buffer.alloc(setAuthorityInstructionData.span);
    setAuthorityInstructionData.encode({
        instruction: (0, _typesMjs.TokenInstruction).SetAuthority,
        authorityType,
        newAuthorityOption: newAuthority ? 1 : 0,
        newAuthority: newAuthority || new (0, _web3Js.PublicKey)(0)
    }, data);
    return new (0, _web3Js.TransactionInstruction)({
        keys,
        programId,
        data
    });
}
function decodeSetAuthorityInstruction(instruction, programId = (0, _constantsMjs.TOKEN_PROGRAM_ID)) {
    if (!instruction.programId.equals(programId)) throw new (0, _errorsMjs.TokenInvalidInstructionProgramError)();
    if (instruction.data.length !== setAuthorityInstructionData.span) throw new (0, _errorsMjs.TokenInvalidInstructionDataError)();
    const { keys: { account, currentAuthority, multiSigners }, data } = decodeSetAuthorityInstructionUnchecked(instruction);
    if (data.instruction !== (0, _typesMjs.TokenInstruction).SetAuthority) throw new (0, _errorsMjs.TokenInvalidInstructionTypeError)();
    if (!account || !currentAuthority) throw new (0, _errorsMjs.TokenInvalidInstructionKeysError)();
    // TODO: key checks?
    return {
        programId,
        keys: {
            account,
            currentAuthority,
            multiSigners
        },
        data
    };
}
function decodeSetAuthorityInstructionUnchecked({ programId, keys: [account, currentAuthority, ...multiSigners], data }) {
    const { instruction, authorityType, newAuthorityOption, newAuthority } = setAuthorityInstructionData.decode(data);
    return {
        programId,
        keys: {
            account,
            currentAuthority,
            multiSigners
        },
        data: {
            instruction,
            authorityType,
            newAuthority: newAuthorityOption ? newAuthority : null
        }
    };
}

},{"6cc588d3a09e1b5e":"fCgem","@solana/buffer-layout":"jD9A8","@solana/buffer-layout-utils":"hVYs1","@solana/web3.js":"5JBKN","./../constants.mjs":"dBO94","./../errors.mjs":"3x3WE","./internal.mjs":"hvqv6","./types.mjs":"fLCUz","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"zvv9V":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "mintToInstructionData", ()=>mintToInstructionData);
/**
 * Construct a MintTo instruction
 *
 * @param mint         Public key of the mint
 * @param destination  Address of the token account to mint to
 * @param authority    The mint authority
 * @param amount       Amount to mint
 * @param multiSigners Signing accounts if `authority` is a multisig
 * @param programId    SPL Token program account
 *
 * @return Instruction to add to a transaction
 */ parcelHelpers.export(exports, "createMintToInstruction", ()=>createMintToInstruction);
/**
 * Decode a MintTo instruction and validate it
 *
 * @param instruction Transaction instruction to decode
 * @param programId   SPL Token program account
 *
 * @return Decoded, valid instruction
 */ parcelHelpers.export(exports, "decodeMintToInstruction", ()=>decodeMintToInstruction);
/**
 * Decode a MintTo instruction without validating it
 *
 * @param instruction Transaction instruction to decode
 *
 * @return Decoded, non-validated instruction
 */ parcelHelpers.export(exports, "decodeMintToInstructionUnchecked", ()=>decodeMintToInstructionUnchecked);
var _bufferLayout = require("@solana/buffer-layout");
var _bufferLayoutUtils = require("@solana/buffer-layout-utils");
var _web3Js = require("@solana/web3.js");
var _constantsMjs = require("./../constants.mjs");
var _errorsMjs = require("./../errors.mjs");
var _internalMjs = require("./internal.mjs");
var _typesMjs = require("./types.mjs");
var Buffer = require("d16787c1f9ad1f9f").Buffer;
const mintToInstructionData = (0, _bufferLayout.struct)([
    (0, _bufferLayout.u8)("instruction"),
    (0, _bufferLayoutUtils.u64)("amount")
]);
function createMintToInstruction(mint, destination, authority, amount, multiSigners = [], programId = (0, _constantsMjs.TOKEN_PROGRAM_ID)) {
    const keys = (0, _internalMjs.addSigners)([
        {
            pubkey: mint,
            isSigner: false,
            isWritable: true
        },
        {
            pubkey: destination,
            isSigner: false,
            isWritable: true
        }
    ], authority, multiSigners);
    const data = Buffer.alloc(mintToInstructionData.span);
    mintToInstructionData.encode({
        instruction: (0, _typesMjs.TokenInstruction).MintTo,
        amount: BigInt(amount)
    }, data);
    return new (0, _web3Js.TransactionInstruction)({
        keys,
        programId,
        data
    });
}
function decodeMintToInstruction(instruction, programId = (0, _constantsMjs.TOKEN_PROGRAM_ID)) {
    if (!instruction.programId.equals(programId)) throw new (0, _errorsMjs.TokenInvalidInstructionProgramError)();
    if (instruction.data.length !== mintToInstructionData.span) throw new (0, _errorsMjs.TokenInvalidInstructionDataError)();
    const { keys: { mint, destination, authority, multiSigners }, data } = decodeMintToInstructionUnchecked(instruction);
    if (data.instruction !== (0, _typesMjs.TokenInstruction).MintTo) throw new (0, _errorsMjs.TokenInvalidInstructionTypeError)();
    if (!mint || !destination || !authority) throw new (0, _errorsMjs.TokenInvalidInstructionKeysError)();
    // TODO: key checks?
    return {
        programId,
        keys: {
            mint,
            destination,
            authority,
            multiSigners
        },
        data
    };
}
function decodeMintToInstructionUnchecked({ programId, keys: [mint, destination, authority, ...multiSigners], data }) {
    return {
        programId,
        keys: {
            mint,
            destination,
            authority,
            multiSigners
        },
        data: mintToInstructionData.decode(data)
    };
}

},{"d16787c1f9ad1f9f":"fCgem","@solana/buffer-layout":"jD9A8","@solana/buffer-layout-utils":"hVYs1","@solana/web3.js":"5JBKN","./../constants.mjs":"dBO94","./../errors.mjs":"3x3WE","./internal.mjs":"hvqv6","./types.mjs":"fLCUz","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"asBxd":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "burnInstructionData", ()=>burnInstructionData);
/**
 * Construct a Burn instruction
 *
 * @param account      Account to burn tokens from
 * @param mint         Mint for the account
 * @param owner        Owner of the account
 * @param amount       Number of tokens to burn
 * @param multiSigners Signing accounts if `owner` is a multisig
 * @param programId    SPL Token program account
 *
 * @return Instruction to add to a transaction
 */ parcelHelpers.export(exports, "createBurnInstruction", ()=>createBurnInstruction);
/**
 * Decode a Burn instruction and validate it
 *
 * @param instruction Transaction instruction to decode
 * @param programId   SPL Token program account
 *
 * @return Decoded, valid instruction
 */ parcelHelpers.export(exports, "decodeBurnInstruction", ()=>decodeBurnInstruction);
/**
 * Decode a Burn instruction without validating it
 *
 * @param instruction Transaction instruction to decode
 *
 * @return Decoded, non-validated instruction
 */ parcelHelpers.export(exports, "decodeBurnInstructionUnchecked", ()=>decodeBurnInstructionUnchecked);
var _bufferLayout = require("@solana/buffer-layout");
var _bufferLayoutUtils = require("@solana/buffer-layout-utils");
var _web3Js = require("@solana/web3.js");
var _constantsMjs = require("./../constants.mjs");
var _errorsMjs = require("./../errors.mjs");
var _internalMjs = require("./internal.mjs");
var _typesMjs = require("./types.mjs");
var Buffer = require("ef3633fe0e50f637").Buffer;
const burnInstructionData = (0, _bufferLayout.struct)([
    (0, _bufferLayout.u8)("instruction"),
    (0, _bufferLayoutUtils.u64)("amount")
]);
function createBurnInstruction(account, mint, owner, amount, multiSigners = [], programId = (0, _constantsMjs.TOKEN_PROGRAM_ID)) {
    const keys = (0, _internalMjs.addSigners)([
        {
            pubkey: account,
            isSigner: false,
            isWritable: true
        },
        {
            pubkey: mint,
            isSigner: false,
            isWritable: true
        }
    ], owner, multiSigners);
    const data = Buffer.alloc(burnInstructionData.span);
    burnInstructionData.encode({
        instruction: (0, _typesMjs.TokenInstruction).Burn,
        amount: BigInt(amount)
    }, data);
    return new (0, _web3Js.TransactionInstruction)({
        keys,
        programId,
        data
    });
}
function decodeBurnInstruction(instruction, programId = (0, _constantsMjs.TOKEN_PROGRAM_ID)) {
    if (!instruction.programId.equals(programId)) throw new (0, _errorsMjs.TokenInvalidInstructionProgramError)();
    if (instruction.data.length !== burnInstructionData.span) throw new (0, _errorsMjs.TokenInvalidInstructionDataError)();
    const { keys: { account, mint, owner, multiSigners }, data } = decodeBurnInstructionUnchecked(instruction);
    if (data.instruction !== (0, _typesMjs.TokenInstruction).Burn) throw new (0, _errorsMjs.TokenInvalidInstructionTypeError)();
    if (!account || !mint || !owner) throw new (0, _errorsMjs.TokenInvalidInstructionKeysError)();
    // TODO: key checks?
    return {
        programId,
        keys: {
            account,
            mint,
            owner,
            multiSigners
        },
        data
    };
}
function decodeBurnInstructionUnchecked({ programId, keys: [account, mint, owner, ...multiSigners], data }) {
    return {
        programId,
        keys: {
            account,
            mint,
            owner,
            multiSigners
        },
        data: burnInstructionData.decode(data)
    };
}

},{"ef3633fe0e50f637":"fCgem","@solana/buffer-layout":"jD9A8","@solana/buffer-layout-utils":"hVYs1","@solana/web3.js":"5JBKN","./../constants.mjs":"dBO94","./../errors.mjs":"3x3WE","./internal.mjs":"hvqv6","./types.mjs":"fLCUz","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hLvDh":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "closeAccountInstructionData", ()=>closeAccountInstructionData);
/**
 * Construct a CloseAccount instruction
 *
 * @param account      Account to close
 * @param destination  Account to receive the remaining balance of the closed account
 * @param authority    Account close authority
 * @param multiSigners Signing accounts if `authority` is a multisig
 * @param programId    SPL Token program account
 *
 * @return Instruction to add to a transaction
 */ parcelHelpers.export(exports, "createCloseAccountInstruction", ()=>createCloseAccountInstruction);
/**
 * Decode a CloseAccount instruction and validate it
 *
 * @param instruction Transaction instruction to decode
 * @param programId   SPL Token program account
 *
 * @return Decoded, valid instruction
 */ parcelHelpers.export(exports, "decodeCloseAccountInstruction", ()=>decodeCloseAccountInstruction);
/**
 * Decode a CloseAccount instruction without validating it
 *
 * @param instruction Transaction instruction to decode
 *
 * @return Decoded, non-validated instruction
 */ parcelHelpers.export(exports, "decodeCloseAccountInstructionUnchecked", ()=>decodeCloseAccountInstructionUnchecked);
var _bufferLayout = require("@solana/buffer-layout");
var _web3Js = require("@solana/web3.js");
var _constantsMjs = require("./../constants.mjs");
var _errorsMjs = require("./../errors.mjs");
var _internalMjs = require("./internal.mjs");
var _typesMjs = require("./types.mjs");
var Buffer = require("21658c7e65e6cf01").Buffer;
const closeAccountInstructionData = (0, _bufferLayout.struct)([
    (0, _bufferLayout.u8)("instruction")
]);
function createCloseAccountInstruction(account, destination, authority, multiSigners = [], programId = (0, _constantsMjs.TOKEN_PROGRAM_ID)) {
    const keys = (0, _internalMjs.addSigners)([
        {
            pubkey: account,
            isSigner: false,
            isWritable: true
        },
        {
            pubkey: destination,
            isSigner: false,
            isWritable: true
        }
    ], authority, multiSigners);
    const data = Buffer.alloc(closeAccountInstructionData.span);
    closeAccountInstructionData.encode({
        instruction: (0, _typesMjs.TokenInstruction).CloseAccount
    }, data);
    return new (0, _web3Js.TransactionInstruction)({
        keys,
        programId,
        data
    });
}
function decodeCloseAccountInstruction(instruction, programId = (0, _constantsMjs.TOKEN_PROGRAM_ID)) {
    if (!instruction.programId.equals(programId)) throw new (0, _errorsMjs.TokenInvalidInstructionProgramError)();
    if (instruction.data.length !== closeAccountInstructionData.span) throw new (0, _errorsMjs.TokenInvalidInstructionDataError)();
    const { keys: { account, destination, authority, multiSigners }, data } = decodeCloseAccountInstructionUnchecked(instruction);
    if (data.instruction !== (0, _typesMjs.TokenInstruction).CloseAccount) throw new (0, _errorsMjs.TokenInvalidInstructionTypeError)();
    if (!account || !destination || !authority) throw new (0, _errorsMjs.TokenInvalidInstructionKeysError)();
    // TODO: key checks?
    return {
        programId,
        keys: {
            account,
            destination,
            authority,
            multiSigners
        },
        data
    };
}
function decodeCloseAccountInstructionUnchecked({ programId, keys: [account, destination, authority, ...multiSigners], data }) {
    return {
        programId,
        keys: {
            account,
            destination,
            authority,
            multiSigners
        },
        data: closeAccountInstructionData.decode(data)
    };
}

},{"21658c7e65e6cf01":"fCgem","@solana/buffer-layout":"jD9A8","@solana/web3.js":"5JBKN","./../constants.mjs":"dBO94","./../errors.mjs":"3x3WE","./internal.mjs":"hvqv6","./types.mjs":"fLCUz","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9WKle":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "freezeAccountInstructionData", ()=>freezeAccountInstructionData);
/**
 * Construct a FreezeAccount instruction
 *
 * @param account      Account to freeze
 * @param mint         Mint account
 * @param authority    Mint freeze authority
 * @param multiSigners Signing accounts if `authority` is a multisig
 * @param programId    SPL Token program account
 *
 * @return Instruction to add to a transaction
 */ parcelHelpers.export(exports, "createFreezeAccountInstruction", ()=>createFreezeAccountInstruction);
/**
 * Decode a FreezeAccount instruction and validate it
 *
 * @param instruction Transaction instruction to decode
 * @param programId   SPL Token program account
 *
 * @return Decoded, valid instruction
 */ parcelHelpers.export(exports, "decodeFreezeAccountInstruction", ()=>decodeFreezeAccountInstruction);
/**
 * Decode a FreezeAccount instruction without validating it
 *
 * @param instruction Transaction instruction to decode
 *
 * @return Decoded, non-validated instruction
 */ parcelHelpers.export(exports, "decodeFreezeAccountInstructionUnchecked", ()=>decodeFreezeAccountInstructionUnchecked);
var _bufferLayout = require("@solana/buffer-layout");
var _web3Js = require("@solana/web3.js");
var _constantsMjs = require("./../constants.mjs");
var _errorsMjs = require("./../errors.mjs");
var _internalMjs = require("./internal.mjs");
var _typesMjs = require("./types.mjs");
var Buffer = require("beda401bea9c7f25").Buffer;
const freezeAccountInstructionData = (0, _bufferLayout.struct)([
    (0, _bufferLayout.u8)("instruction")
]);
function createFreezeAccountInstruction(account, mint, authority, multiSigners = [], programId = (0, _constantsMjs.TOKEN_PROGRAM_ID)) {
    const keys = (0, _internalMjs.addSigners)([
        {
            pubkey: account,
            isSigner: false,
            isWritable: true
        },
        {
            pubkey: mint,
            isSigner: false,
            isWritable: false
        }
    ], authority, multiSigners);
    const data = Buffer.alloc(freezeAccountInstructionData.span);
    freezeAccountInstructionData.encode({
        instruction: (0, _typesMjs.TokenInstruction).FreezeAccount
    }, data);
    return new (0, _web3Js.TransactionInstruction)({
        keys,
        programId,
        data
    });
}
function decodeFreezeAccountInstruction(instruction, programId = (0, _constantsMjs.TOKEN_PROGRAM_ID)) {
    if (!instruction.programId.equals(programId)) throw new (0, _errorsMjs.TokenInvalidInstructionProgramError)();
    if (instruction.data.length !== freezeAccountInstructionData.span) throw new (0, _errorsMjs.TokenInvalidInstructionDataError)();
    const { keys: { account, mint, authority, multiSigners }, data } = decodeFreezeAccountInstructionUnchecked(instruction);
    if (data.instruction !== (0, _typesMjs.TokenInstruction).FreezeAccount) throw new (0, _errorsMjs.TokenInvalidInstructionTypeError)();
    if (!account || !mint || !authority) throw new (0, _errorsMjs.TokenInvalidInstructionKeysError)();
    // TODO: key checks?
    return {
        programId,
        keys: {
            account,
            mint,
            authority,
            multiSigners
        },
        data
    };
}
function decodeFreezeAccountInstructionUnchecked({ programId, keys: [account, mint, authority, ...multiSigners], data }) {
    return {
        programId,
        keys: {
            account,
            mint,
            authority,
            multiSigners
        },
        data: freezeAccountInstructionData.decode(data)
    };
}

},{"beda401bea9c7f25":"fCgem","@solana/buffer-layout":"jD9A8","@solana/web3.js":"5JBKN","./../constants.mjs":"dBO94","./../errors.mjs":"3x3WE","./internal.mjs":"hvqv6","./types.mjs":"fLCUz","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9TrcN":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "thawAccountInstructionData", ()=>thawAccountInstructionData);
/**
 * Construct a ThawAccount instruction
 *
 * @param account      Account to thaw
 * @param mint         Mint account
 * @param authority    Mint freeze authority
 * @param multiSigners Signing accounts if `authority` is a multisig
 * @param programId    SPL Token program account
 *
 * @return Instruction to add to a transaction
 */ parcelHelpers.export(exports, "createThawAccountInstruction", ()=>createThawAccountInstruction);
/**
 * Decode a ThawAccount instruction and validate it
 *
 * @param instruction Transaction instruction to decode
 * @param programId   SPL Token program account
 *
 * @return Decoded, valid instruction
 */ parcelHelpers.export(exports, "decodeThawAccountInstruction", ()=>decodeThawAccountInstruction);
/**
 * Decode a ThawAccount instruction without validating it
 *
 * @param instruction Transaction instruction to decode
 *
 * @return Decoded, non-validated instruction
 */ parcelHelpers.export(exports, "decodeThawAccountInstructionUnchecked", ()=>decodeThawAccountInstructionUnchecked);
var _bufferLayout = require("@solana/buffer-layout");
var _web3Js = require("@solana/web3.js");
var _constantsMjs = require("./../constants.mjs");
var _errorsMjs = require("./../errors.mjs");
var _internalMjs = require("./internal.mjs");
var _typesMjs = require("./types.mjs");
var Buffer = require("6c53c04f91a86c25").Buffer;
const thawAccountInstructionData = (0, _bufferLayout.struct)([
    (0, _bufferLayout.u8)("instruction")
]);
function createThawAccountInstruction(account, mint, authority, multiSigners = [], programId = (0, _constantsMjs.TOKEN_PROGRAM_ID)) {
    const keys = (0, _internalMjs.addSigners)([
        {
            pubkey: account,
            isSigner: false,
            isWritable: true
        },
        {
            pubkey: mint,
            isSigner: false,
            isWritable: false
        }
    ], authority, multiSigners);
    const data = Buffer.alloc(thawAccountInstructionData.span);
    thawAccountInstructionData.encode({
        instruction: (0, _typesMjs.TokenInstruction).ThawAccount
    }, data);
    return new (0, _web3Js.TransactionInstruction)({
        keys,
        programId,
        data
    });
}
function decodeThawAccountInstruction(instruction, programId = (0, _constantsMjs.TOKEN_PROGRAM_ID)) {
    if (!instruction.programId.equals(programId)) throw new (0, _errorsMjs.TokenInvalidInstructionProgramError)();
    if (instruction.data.length !== thawAccountInstructionData.span) throw new (0, _errorsMjs.TokenInvalidInstructionDataError)();
    const { keys: { account, mint, authority, multiSigners }, data } = decodeThawAccountInstructionUnchecked(instruction);
    if (data.instruction !== (0, _typesMjs.TokenInstruction).ThawAccount) throw new (0, _errorsMjs.TokenInvalidInstructionTypeError)();
    if (!account || !mint || !authority) throw new (0, _errorsMjs.TokenInvalidInstructionKeysError)();
    // TODO: key checks?
    return {
        programId,
        keys: {
            account,
            mint,
            authority,
            multiSigners
        },
        data
    };
}
function decodeThawAccountInstructionUnchecked({ programId, keys: [account, mint, authority, ...multiSigners], data }) {
    return {
        programId,
        keys: {
            account,
            mint,
            authority,
            multiSigners
        },
        data: thawAccountInstructionData.decode(data)
    };
}

},{"6c53c04f91a86c25":"fCgem","@solana/buffer-layout":"jD9A8","@solana/web3.js":"5JBKN","./../constants.mjs":"dBO94","./../errors.mjs":"3x3WE","./internal.mjs":"hvqv6","./types.mjs":"fLCUz","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hYWCZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "transferCheckedInstructionData", ()=>transferCheckedInstructionData);
/**
 * Construct a TransferChecked instruction
 *
 * @param source       Source account
 * @param mint         Mint account
 * @param destination  Destination account
 * @param owner        Owner of the source account
 * @param amount       Number of tokens to transfer
 * @param decimals     Number of decimals in transfer amount
 * @param multiSigners Signing accounts if `owner` is a multisig
 * @param programId    SPL Token program account
 *
 * @return Instruction to add to a transaction
 */ parcelHelpers.export(exports, "createTransferCheckedInstruction", ()=>createTransferCheckedInstruction);
/**
 * Decode a TransferChecked instruction and validate it
 *
 * @param instruction Transaction instruction to decode
 * @param programId   SPL Token program account
 *
 * @return Decoded, valid instruction
 */ parcelHelpers.export(exports, "decodeTransferCheckedInstruction", ()=>decodeTransferCheckedInstruction);
/**
 * Decode a TransferChecked instruction without validating it
 *
 * @param instruction Transaction instruction to decode
 *
 * @return Decoded, non-validated instruction
 */ parcelHelpers.export(exports, "decodeTransferCheckedInstructionUnchecked", ()=>decodeTransferCheckedInstructionUnchecked);
var _bufferLayout = require("@solana/buffer-layout");
var _bufferLayoutUtils = require("@solana/buffer-layout-utils");
var _web3Js = require("@solana/web3.js");
var _constantsMjs = require("./../constants.mjs");
var _errorsMjs = require("./../errors.mjs");
var _internalMjs = require("./internal.mjs");
var _typesMjs = require("./types.mjs");
var Buffer = require("588d26777ef0b9df").Buffer;
const transferCheckedInstructionData = (0, _bufferLayout.struct)([
    (0, _bufferLayout.u8)("instruction"),
    (0, _bufferLayoutUtils.u64)("amount"),
    (0, _bufferLayout.u8)("decimals")
]);
function createTransferCheckedInstruction(source, mint, destination, owner, amount, decimals, multiSigners = [], programId = (0, _constantsMjs.TOKEN_PROGRAM_ID)) {
    const keys = (0, _internalMjs.addSigners)([
        {
            pubkey: source,
            isSigner: false,
            isWritable: true
        },
        {
            pubkey: mint,
            isSigner: false,
            isWritable: false
        },
        {
            pubkey: destination,
            isSigner: false,
            isWritable: true
        }
    ], owner, multiSigners);
    const data = Buffer.alloc(transferCheckedInstructionData.span);
    transferCheckedInstructionData.encode({
        instruction: (0, _typesMjs.TokenInstruction).TransferChecked,
        amount: BigInt(amount),
        decimals
    }, data);
    return new (0, _web3Js.TransactionInstruction)({
        keys,
        programId,
        data
    });
}
function decodeTransferCheckedInstruction(instruction, programId = (0, _constantsMjs.TOKEN_PROGRAM_ID)) {
    if (!instruction.programId.equals(programId)) throw new (0, _errorsMjs.TokenInvalidInstructionProgramError)();
    if (instruction.data.length !== transferCheckedInstructionData.span) throw new (0, _errorsMjs.TokenInvalidInstructionDataError)();
    const { keys: { source, mint, destination, owner, multiSigners }, data } = decodeTransferCheckedInstructionUnchecked(instruction);
    if (data.instruction !== (0, _typesMjs.TokenInstruction).TransferChecked) throw new (0, _errorsMjs.TokenInvalidInstructionTypeError)();
    if (!source || !mint || !destination || !owner) throw new (0, _errorsMjs.TokenInvalidInstructionKeysError)();
    // TODO: key checks?
    return {
        programId,
        keys: {
            source,
            mint,
            destination,
            owner,
            multiSigners
        },
        data
    };
}
function decodeTransferCheckedInstructionUnchecked({ programId, keys: [source, mint, destination, owner, ...multiSigners], data }) {
    return {
        programId,
        keys: {
            source,
            mint,
            destination,
            owner,
            multiSigners
        },
        data: transferCheckedInstructionData.decode(data)
    };
}

},{"588d26777ef0b9df":"fCgem","@solana/buffer-layout":"jD9A8","@solana/buffer-layout-utils":"hVYs1","@solana/web3.js":"5JBKN","./../constants.mjs":"dBO94","./../errors.mjs":"3x3WE","./internal.mjs":"hvqv6","./types.mjs":"fLCUz","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8BTgm":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "approveCheckedInstructionData", ()=>approveCheckedInstructionData);
/**
 * Construct an ApproveChecked instruction
 *
 * @param account      Account to set the delegate for
 * @param mint         Mint account
 * @param delegate     Account authorized to transfer of tokens from the account
 * @param owner        Owner of the account
 * @param amount       Maximum number of tokens the delegate may transfer
 * @param decimals     Number of decimals in approve amount
 * @param multiSigners Signing accounts if `owner` is a multisig
 * @param programId    SPL Token program account
 *
 * @return Instruction to add to a transaction
 */ parcelHelpers.export(exports, "createApproveCheckedInstruction", ()=>createApproveCheckedInstruction);
/**
 * Decode an ApproveChecked instruction and validate it
 *
 * @param instruction Transaction instruction to decode
 * @param programId   SPL Token program account
 *
 * @return Decoded, valid instruction
 */ parcelHelpers.export(exports, "decodeApproveCheckedInstruction", ()=>decodeApproveCheckedInstruction);
/**
 * Decode an ApproveChecked instruction without validating it
 *
 * @param instruction Transaction instruction to decode
 *
 * @return Decoded, non-validated instruction
 */ parcelHelpers.export(exports, "decodeApproveCheckedInstructionUnchecked", ()=>decodeApproveCheckedInstructionUnchecked);
var _bufferLayout = require("@solana/buffer-layout");
var _bufferLayoutUtils = require("@solana/buffer-layout-utils");
var _web3Js = require("@solana/web3.js");
var _constantsMjs = require("./../constants.mjs");
var _errorsMjs = require("./../errors.mjs");
var _internalMjs = require("./internal.mjs");
var _typesMjs = require("./types.mjs");
var Buffer = require("493b96f9dbdc5f8").Buffer;
const approveCheckedInstructionData = (0, _bufferLayout.struct)([
    (0, _bufferLayout.u8)("instruction"),
    (0, _bufferLayoutUtils.u64)("amount"),
    (0, _bufferLayout.u8)("decimals")
]);
function createApproveCheckedInstruction(account, mint, delegate, owner, amount, decimals, multiSigners = [], programId = (0, _constantsMjs.TOKEN_PROGRAM_ID)) {
    const keys = (0, _internalMjs.addSigners)([
        {
            pubkey: account,
            isSigner: false,
            isWritable: true
        },
        {
            pubkey: mint,
            isSigner: false,
            isWritable: false
        },
        {
            pubkey: delegate,
            isSigner: false,
            isWritable: false
        }
    ], owner, multiSigners);
    const data = Buffer.alloc(approveCheckedInstructionData.span);
    approveCheckedInstructionData.encode({
        instruction: (0, _typesMjs.TokenInstruction).ApproveChecked,
        amount: BigInt(amount),
        decimals
    }, data);
    return new (0, _web3Js.TransactionInstruction)({
        keys,
        programId,
        data
    });
}
function decodeApproveCheckedInstruction(instruction, programId = (0, _constantsMjs.TOKEN_PROGRAM_ID)) {
    if (!instruction.programId.equals(programId)) throw new (0, _errorsMjs.TokenInvalidInstructionProgramError)();
    if (instruction.data.length !== approveCheckedInstructionData.span) throw new (0, _errorsMjs.TokenInvalidInstructionDataError)();
    const { keys: { account, mint, delegate, owner, multiSigners }, data } = decodeApproveCheckedInstructionUnchecked(instruction);
    if (data.instruction !== (0, _typesMjs.TokenInstruction).ApproveChecked) throw new (0, _errorsMjs.TokenInvalidInstructionTypeError)();
    if (!account || !mint || !delegate || !owner) throw new (0, _errorsMjs.TokenInvalidInstructionKeysError)();
    // TODO: key checks?
    return {
        programId,
        keys: {
            account,
            mint,
            delegate,
            owner,
            multiSigners
        },
        data
    };
}
function decodeApproveCheckedInstructionUnchecked({ programId, keys: [account, mint, delegate, owner, ...multiSigners], data }) {
    return {
        programId,
        keys: {
            account,
            mint,
            delegate,
            owner,
            multiSigners
        },
        data: approveCheckedInstructionData.decode(data)
    };
}

},{"493b96f9dbdc5f8":"fCgem","@solana/buffer-layout":"jD9A8","@solana/buffer-layout-utils":"hVYs1","@solana/web3.js":"5JBKN","./../constants.mjs":"dBO94","./../errors.mjs":"3x3WE","./internal.mjs":"hvqv6","./types.mjs":"fLCUz","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lAUnV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "mintToCheckedInstructionData", ()=>mintToCheckedInstructionData);
/**
 * Construct a MintToChecked instruction
 *
 * @param mint         Public key of the mint
 * @param destination  Address of the token account to mint to
 * @param authority    The mint authority
 * @param amount       Amount to mint
 * @param decimals     Number of decimals in amount to mint
 * @param multiSigners Signing accounts if `authority` is a multisig
 * @param programId    SPL Token program account
 *
 * @return Instruction to add to a transaction
 */ parcelHelpers.export(exports, "createMintToCheckedInstruction", ()=>createMintToCheckedInstruction);
/**
 * Decode a MintToChecked instruction and validate it
 *
 * @param instruction Transaction instruction to decode
 * @param programId   SPL Token program account
 *
 * @return Decoded, valid instruction
 */ parcelHelpers.export(exports, "decodeMintToCheckedInstruction", ()=>decodeMintToCheckedInstruction);
/**
 * Decode a MintToChecked instruction without validating it
 *
 * @param instruction Transaction instruction to decode
 *
 * @return Decoded, non-validated instruction
 */ parcelHelpers.export(exports, "decodeMintToCheckedInstructionUnchecked", ()=>decodeMintToCheckedInstructionUnchecked);
var _bufferLayout = require("@solana/buffer-layout");
var _bufferLayoutUtils = require("@solana/buffer-layout-utils");
var _web3Js = require("@solana/web3.js");
var _constantsMjs = require("./../constants.mjs");
var _errorsMjs = require("./../errors.mjs");
var _internalMjs = require("./internal.mjs");
var _typesMjs = require("./types.mjs");
var Buffer = require("984392d50ee28cbc").Buffer;
const mintToCheckedInstructionData = (0, _bufferLayout.struct)([
    (0, _bufferLayout.u8)("instruction"),
    (0, _bufferLayoutUtils.u64)("amount"),
    (0, _bufferLayout.u8)("decimals")
]);
function createMintToCheckedInstruction(mint, destination, authority, amount, decimals, multiSigners = [], programId = (0, _constantsMjs.TOKEN_PROGRAM_ID)) {
    const keys = (0, _internalMjs.addSigners)([
        {
            pubkey: mint,
            isSigner: false,
            isWritable: true
        },
        {
            pubkey: destination,
            isSigner: false,
            isWritable: true
        }
    ], authority, multiSigners);
    const data = Buffer.alloc(mintToCheckedInstructionData.span);
    mintToCheckedInstructionData.encode({
        instruction: (0, _typesMjs.TokenInstruction).MintToChecked,
        amount: BigInt(amount),
        decimals
    }, data);
    return new (0, _web3Js.TransactionInstruction)({
        keys,
        programId,
        data
    });
}
function decodeMintToCheckedInstruction(instruction, programId = (0, _constantsMjs.TOKEN_PROGRAM_ID)) {
    if (!instruction.programId.equals(programId)) throw new (0, _errorsMjs.TokenInvalidInstructionProgramError)();
    if (instruction.data.length !== mintToCheckedInstructionData.span) throw new (0, _errorsMjs.TokenInvalidInstructionDataError)();
    const { keys: { mint, destination, authority, multiSigners }, data } = decodeMintToCheckedInstructionUnchecked(instruction);
    if (data.instruction !== (0, _typesMjs.TokenInstruction).MintToChecked) throw new (0, _errorsMjs.TokenInvalidInstructionTypeError)();
    if (!mint || !destination || !authority) throw new (0, _errorsMjs.TokenInvalidInstructionKeysError)();
    // TODO: key checks?
    return {
        programId,
        keys: {
            mint,
            destination,
            authority,
            multiSigners
        },
        data
    };
}
function decodeMintToCheckedInstructionUnchecked({ programId, keys: [mint, destination, authority, ...multiSigners], data }) {
    return {
        programId,
        keys: {
            mint,
            destination,
            authority,
            multiSigners
        },
        data: mintToCheckedInstructionData.decode(data)
    };
}

},{"984392d50ee28cbc":"fCgem","@solana/buffer-layout":"jD9A8","@solana/buffer-layout-utils":"hVYs1","@solana/web3.js":"5JBKN","./../constants.mjs":"dBO94","./../errors.mjs":"3x3WE","./internal.mjs":"hvqv6","./types.mjs":"fLCUz","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5zGbF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "burnCheckedInstructionData", ()=>burnCheckedInstructionData);
/**
 * Construct a BurnChecked instruction
 *
 * @param mint         Mint for the account
 * @param account      Account to burn tokens from
 * @param owner        Owner of the account
 * @param amount       Number of tokens to burn
 * @param decimals     Number of decimals in burn amount
 * @param multiSigners Signing accounts if `owner` is a multisig
 * @param programId    SPL Token program account
 *
 * @return Instruction to add to a transaction
 */ parcelHelpers.export(exports, "createBurnCheckedInstruction", ()=>createBurnCheckedInstruction);
/**
 * Decode a BurnChecked instruction and validate it
 *
 * @param instruction Transaction instruction to decode
 * @param programId   SPL Token program account
 *
 * @return Decoded, valid instruction
 */ parcelHelpers.export(exports, "decodeBurnCheckedInstruction", ()=>decodeBurnCheckedInstruction);
/**
 * Decode a BurnChecked instruction without validating it
 *
 * @param instruction Transaction instruction to decode
 *
 * @return Decoded, non-validated instruction
 */ parcelHelpers.export(exports, "decodeBurnCheckedInstructionUnchecked", ()=>decodeBurnCheckedInstructionUnchecked);
var _bufferLayout = require("@solana/buffer-layout");
var _bufferLayoutUtils = require("@solana/buffer-layout-utils");
var _web3Js = require("@solana/web3.js");
var _constantsMjs = require("./../constants.mjs");
var _errorsMjs = require("./../errors.mjs");
var _internalMjs = require("./internal.mjs");
var _typesMjs = require("./types.mjs");
var Buffer = require("9654d7cbbd560a03").Buffer;
const burnCheckedInstructionData = (0, _bufferLayout.struct)([
    (0, _bufferLayout.u8)("instruction"),
    (0, _bufferLayoutUtils.u64)("amount"),
    (0, _bufferLayout.u8)("decimals")
]);
function createBurnCheckedInstruction(account, mint, owner, amount, decimals, multiSigners = [], programId = (0, _constantsMjs.TOKEN_PROGRAM_ID)) {
    const keys = (0, _internalMjs.addSigners)([
        {
            pubkey: account,
            isSigner: false,
            isWritable: true
        },
        {
            pubkey: mint,
            isSigner: false,
            isWritable: true
        }
    ], owner, multiSigners);
    const data = Buffer.alloc(burnCheckedInstructionData.span);
    burnCheckedInstructionData.encode({
        instruction: (0, _typesMjs.TokenInstruction).BurnChecked,
        amount: BigInt(amount),
        decimals
    }, data);
    return new (0, _web3Js.TransactionInstruction)({
        keys,
        programId,
        data
    });
}
function decodeBurnCheckedInstruction(instruction, programId = (0, _constantsMjs.TOKEN_PROGRAM_ID)) {
    if (!instruction.programId.equals(programId)) throw new (0, _errorsMjs.TokenInvalidInstructionProgramError)();
    if (instruction.data.length !== burnCheckedInstructionData.span) throw new (0, _errorsMjs.TokenInvalidInstructionDataError)();
    const { keys: { account, mint, owner, multiSigners }, data } = decodeBurnCheckedInstructionUnchecked(instruction);
    if (data.instruction !== (0, _typesMjs.TokenInstruction).BurnChecked) throw new (0, _errorsMjs.TokenInvalidInstructionTypeError)();
    if (!account || !mint || !owner) throw new (0, _errorsMjs.TokenInvalidInstructionKeysError)();
    // TODO: key checks?
    return {
        programId,
        keys: {
            account,
            mint,
            owner,
            multiSigners
        },
        data
    };
}
function decodeBurnCheckedInstructionUnchecked({ programId, keys: [account, mint, owner, ...multiSigners], data }) {
    return {
        programId,
        keys: {
            account,
            mint,
            owner,
            multiSigners
        },
        data: burnCheckedInstructionData.decode(data)
    };
}

},{"9654d7cbbd560a03":"fCgem","@solana/buffer-layout":"jD9A8","@solana/buffer-layout-utils":"hVYs1","@solana/web3.js":"5JBKN","./../constants.mjs":"dBO94","./../errors.mjs":"3x3WE","./internal.mjs":"hvqv6","./types.mjs":"fLCUz","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4z5Ob":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hlXvc":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "syncNativeInstructionData", ()=>syncNativeInstructionData);
/**
 * Construct a SyncNative instruction
 *
 * @param account   Native account to sync lamports from
 * @param programId SPL Token program account
 *
 * @return Instruction to add to a transaction
 */ parcelHelpers.export(exports, "createSyncNativeInstruction", ()=>createSyncNativeInstruction);
/**
 * Decode a SyncNative instruction and validate it
 *
 * @param instruction Transaction instruction to decode
 * @param programId   SPL Token program account
 *
 * @return Decoded, valid instruction
 */ parcelHelpers.export(exports, "decodeSyncNativeInstruction", ()=>decodeSyncNativeInstruction);
/**
 * Decode a SyncNative instruction without validating it
 *
 * @param instruction Transaction instruction to decode
 *
 * @return Decoded, non-validated instruction
 */ parcelHelpers.export(exports, "decodeSyncNativeInstructionUnchecked", ()=>decodeSyncNativeInstructionUnchecked);
var _bufferLayout = require("@solana/buffer-layout");
var _web3Js = require("@solana/web3.js");
var _constantsMjs = require("./../constants.mjs");
var _errorsMjs = require("./../errors.mjs");
var _typesMjs = require("./types.mjs");
var Buffer = require("c621aa6bf888b936").Buffer;
const syncNativeInstructionData = (0, _bufferLayout.struct)([
    (0, _bufferLayout.u8)("instruction")
]);
function createSyncNativeInstruction(account, programId = (0, _constantsMjs.TOKEN_PROGRAM_ID)) {
    const keys = [
        {
            pubkey: account,
            isSigner: false,
            isWritable: true
        }
    ];
    const data = Buffer.alloc(syncNativeInstructionData.span);
    syncNativeInstructionData.encode({
        instruction: (0, _typesMjs.TokenInstruction).SyncNative
    }, data);
    return new (0, _web3Js.TransactionInstruction)({
        keys,
        programId,
        data
    });
}
function decodeSyncNativeInstruction(instruction, programId = (0, _constantsMjs.TOKEN_PROGRAM_ID)) {
    if (!instruction.programId.equals(programId)) throw new (0, _errorsMjs.TokenInvalidInstructionProgramError)();
    if (instruction.data.length !== syncNativeInstructionData.span) throw new (0, _errorsMjs.TokenInvalidInstructionDataError)();
    const { keys: { account }, data } = decodeSyncNativeInstructionUnchecked(instruction);
    if (data.instruction !== (0, _typesMjs.TokenInstruction).SyncNative) throw new (0, _errorsMjs.TokenInvalidInstructionTypeError)();
    if (!account) throw new (0, _errorsMjs.TokenInvalidInstructionKeysError)();
    // TODO: key checks?
    return {
        programId,
        keys: {
            account
        },
        data
    };
}
function decodeSyncNativeInstructionUnchecked({ programId, keys: [account], data }) {
    return {
        programId,
        keys: {
            account
        },
        data: syncNativeInstructionData.decode(data)
    };
}

},{"c621aa6bf888b936":"fCgem","@solana/buffer-layout":"jD9A8","@solana/web3.js":"5JBKN","./../constants.mjs":"dBO94","./../errors.mjs":"3x3WE","./types.mjs":"fLCUz","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gWJWL":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3uZCv":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1EwBB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"glsNO":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/** TODO: docs */ parcelHelpers.export(exports, "decodeInstruction", ()=>decodeInstruction);
/** TODO: docs */ parcelHelpers.export(exports, "isInitializeMintInstruction", ()=>isInitializeMintInstruction);
/** TODO: docs */ parcelHelpers.export(exports, "isInitializeAccountInstruction", ()=>isInitializeAccountInstruction);
/** TODO: docs */ parcelHelpers.export(exports, "isInitializeMultisigInstruction", ()=>isInitializeMultisigInstruction);
/** TODO: docs */ parcelHelpers.export(exports, "isTransferInstruction", ()=>isTransferInstruction);
/** TODO: docs */ parcelHelpers.export(exports, "isApproveInstruction", ()=>isApproveInstruction);
/** TODO: docs */ parcelHelpers.export(exports, "isRevokeInstruction", ()=>isRevokeInstruction);
/** TODO: docs */ parcelHelpers.export(exports, "isSetAuthorityInstruction", ()=>isSetAuthorityInstruction);
/** TODO: docs */ parcelHelpers.export(exports, "isMintToInstruction", ()=>isMintToInstruction);
/** TODO: docs */ parcelHelpers.export(exports, "isBurnInstruction", ()=>isBurnInstruction);
/** TODO: docs */ parcelHelpers.export(exports, "isCloseAccountInstruction", ()=>isCloseAccountInstruction);
/** TODO: docs */ parcelHelpers.export(exports, "isFreezeAccountInstruction", ()=>isFreezeAccountInstruction);
/** TODO: docs */ parcelHelpers.export(exports, "isThawAccountInstruction", ()=>isThawAccountInstruction);
/** TODO: docs */ parcelHelpers.export(exports, "isTransferCheckedInstruction", ()=>isTransferCheckedInstruction);
/** TODO: docs */ parcelHelpers.export(exports, "isApproveCheckedInstruction", ()=>isApproveCheckedInstruction);
/** TODO: docs */ parcelHelpers.export(exports, "isMintToCheckedInstruction", ()=>isMintToCheckedInstruction);
/** TODO: docs */ parcelHelpers.export(exports, "isBurnCheckedInstruction", ()=>isBurnCheckedInstruction);
/** TODO: docs, implement */ // export function isInitializeAccount2Instruction(
//     decoded: DecodedInstruction
// ): decoded is DecodedInitializeAccount2Instruction {
//     return decoded.data.instruction === TokenInstruction.InitializeAccount2;
// }
/** TODO: docs */ parcelHelpers.export(exports, "isSyncNativeInstruction", ()=>isSyncNativeInstruction) /** TODO: docs, implement */  // export function isInitializeAccount3Instruction(
 //     decoded: DecodedInstruction
 // ): decoded is DecodedInitializeAccount3Instruction {
 //     return decoded.data.instruction === TokenInstruction.InitializeAccount3;
 // }
 /** TODO: docs, implement */  // export function isInitializeMultisig2Instruction(
 //     decoded: DecodedInstruction
 // ): decoded is DecodedInitializeMultisig2Instruction {
 //     return decoded.data.instruction === TokenInstruction.InitializeMultisig2;
 // }
 /** TODO: docs, implement */  // export function isInitializeMint2Instruction(
 //     decoded: DecodedInstruction
 // ): decoded is DecodedInitializeMint2Instruction {
 //     return decoded.data.instruction === TokenInstruction.InitializeMint2;
 // }
;
var _bufferLayout = require("@solana/buffer-layout");
var _constantsMjs = require("./../constants.mjs");
var _errorsMjs = require("./../errors.mjs");
var _approveMjs = require("./approve.mjs");
var _approveCheckedMjs = require("./approveChecked.mjs");
var _burnMjs = require("./burn.mjs");
var _burnCheckedMjs = require("./burnChecked.mjs");
var _closeAccountMjs = require("./closeAccount.mjs");
var _freezeAccountMjs = require("./freezeAccount.mjs");
var _initializeAccountMjs = require("./initializeAccount.mjs");
var _initializeMintMjs = require("./initializeMint.mjs");
var _initializeMultisigMjs = require("./initializeMultisig.mjs");
var _mintToMjs = require("./mintTo.mjs");
var _mintToCheckedMjs = require("./mintToChecked.mjs");
var _revokeMjs = require("./revoke.mjs");
var _setAuthorityMjs = require("./setAuthority.mjs");
var _syncNativeMjs = require("./syncNative.mjs");
var _thawAccountMjs = require("./thawAccount.mjs");
var _transferMjs = require("./transfer.mjs");
var _transferCheckedMjs = require("./transferChecked.mjs");
var _typesMjs = require("./types.mjs");
function decodeInstruction(instruction, programId = (0, _constantsMjs.TOKEN_PROGRAM_ID)) {
    if (!instruction.data.length) throw new (0, _errorsMjs.TokenInvalidInstructionDataError)();
    const type = (0, _bufferLayout.u8)().decode(instruction.data);
    if (type === (0, _typesMjs.TokenInstruction).InitializeMint) return (0, _initializeMintMjs.decodeInitializeMintInstruction)(instruction, programId);
    if (type === (0, _typesMjs.TokenInstruction).InitializeAccount) return (0, _initializeAccountMjs.decodeInitializeAccountInstruction)(instruction, programId);
    if (type === (0, _typesMjs.TokenInstruction).InitializeMultisig) return (0, _initializeMultisigMjs.decodeInitializeMultisigInstruction)(instruction, programId);
    if (type === (0, _typesMjs.TokenInstruction).Transfer) return (0, _transferMjs.decodeTransferInstruction)(instruction, programId);
    if (type === (0, _typesMjs.TokenInstruction).Approve) return (0, _approveMjs.decodeApproveInstruction)(instruction, programId);
    if (type === (0, _typesMjs.TokenInstruction).Revoke) return (0, _revokeMjs.decodeRevokeInstruction)(instruction, programId);
    if (type === (0, _typesMjs.TokenInstruction).SetAuthority) return (0, _setAuthorityMjs.decodeSetAuthorityInstruction)(instruction, programId);
    if (type === (0, _typesMjs.TokenInstruction).MintTo) return (0, _mintToMjs.decodeMintToInstruction)(instruction, programId);
    if (type === (0, _typesMjs.TokenInstruction).Burn) return (0, _burnMjs.decodeBurnInstruction)(instruction, programId);
    if (type === (0, _typesMjs.TokenInstruction).CloseAccount) return (0, _closeAccountMjs.decodeCloseAccountInstruction)(instruction, programId);
    if (type === (0, _typesMjs.TokenInstruction).FreezeAccount) return (0, _freezeAccountMjs.decodeFreezeAccountInstruction)(instruction, programId);
    if (type === (0, _typesMjs.TokenInstruction).ThawAccount) return (0, _thawAccountMjs.decodeThawAccountInstruction)(instruction, programId);
    if (type === (0, _typesMjs.TokenInstruction).TransferChecked) return (0, _transferCheckedMjs.decodeTransferCheckedInstruction)(instruction, programId);
    if (type === (0, _typesMjs.TokenInstruction).ApproveChecked) return (0, _approveCheckedMjs.decodeApproveCheckedInstruction)(instruction, programId);
    if (type === (0, _typesMjs.TokenInstruction).MintToChecked) return (0, _mintToCheckedMjs.decodeMintToCheckedInstruction)(instruction, programId);
    if (type === (0, _typesMjs.TokenInstruction).BurnChecked) return (0, _burnCheckedMjs.decodeBurnCheckedInstruction)(instruction, programId);
    // TODO: implement
    if (type === (0, _typesMjs.TokenInstruction).InitializeAccount2) throw new (0, _errorsMjs.TokenInvalidInstructionTypeError)();
    if (type === (0, _typesMjs.TokenInstruction).SyncNative) return (0, _syncNativeMjs.decodeSyncNativeInstruction)(instruction, programId);
    // TODO: implement
    if (type === (0, _typesMjs.TokenInstruction).InitializeAccount3) throw new (0, _errorsMjs.TokenInvalidInstructionTypeError)();
    // TODO: implement
    if (type === (0, _typesMjs.TokenInstruction).InitializeMultisig2) throw new (0, _errorsMjs.TokenInvalidInstructionTypeError)();
    // TODO: implement
    if (type === (0, _typesMjs.TokenInstruction).InitializeMint2) throw new (0, _errorsMjs.TokenInvalidInstructionTypeError)();
    throw new (0, _errorsMjs.TokenInvalidInstructionTypeError)();
}
function isInitializeMintInstruction(decoded) {
    return decoded.data.instruction === (0, _typesMjs.TokenInstruction).InitializeMint;
}
function isInitializeAccountInstruction(decoded) {
    return decoded.data.instruction === (0, _typesMjs.TokenInstruction).InitializeAccount;
}
function isInitializeMultisigInstruction(decoded) {
    return decoded.data.instruction === (0, _typesMjs.TokenInstruction).InitializeMultisig;
}
function isTransferInstruction(decoded) {
    return decoded.data.instruction === (0, _typesMjs.TokenInstruction).Transfer;
}
function isApproveInstruction(decoded) {
    return decoded.data.instruction === (0, _typesMjs.TokenInstruction).Approve;
}
function isRevokeInstruction(decoded) {
    return decoded.data.instruction === (0, _typesMjs.TokenInstruction).Revoke;
}
function isSetAuthorityInstruction(decoded) {
    return decoded.data.instruction === (0, _typesMjs.TokenInstruction).SetAuthority;
}
function isMintToInstruction(decoded) {
    return decoded.data.instruction === (0, _typesMjs.TokenInstruction).MintTo;
}
function isBurnInstruction(decoded) {
    return decoded.data.instruction === (0, _typesMjs.TokenInstruction).Burn;
}
function isCloseAccountInstruction(decoded) {
    return decoded.data.instruction === (0, _typesMjs.TokenInstruction).CloseAccount;
}
function isFreezeAccountInstruction(decoded) {
    return decoded.data.instruction === (0, _typesMjs.TokenInstruction).FreezeAccount;
}
function isThawAccountInstruction(decoded) {
    return decoded.data.instruction === (0, _typesMjs.TokenInstruction).ThawAccount;
}
function isTransferCheckedInstruction(decoded) {
    return decoded.data.instruction === (0, _typesMjs.TokenInstruction).TransferChecked;
}
function isApproveCheckedInstruction(decoded) {
    return decoded.data.instruction === (0, _typesMjs.TokenInstruction).ApproveChecked;
}
function isMintToCheckedInstruction(decoded) {
    return decoded.data.instruction === (0, _typesMjs.TokenInstruction).MintToChecked;
}
function isBurnCheckedInstruction(decoded) {
    return decoded.data.instruction === (0, _typesMjs.TokenInstruction).BurnChecked;
}
function isSyncNativeInstruction(decoded) {
    return decoded.data.instruction === (0, _typesMjs.TokenInstruction).SyncNative;
}

},{"@solana/buffer-layout":"jD9A8","./../constants.mjs":"dBO94","./../errors.mjs":"3x3WE","./approve.mjs":"kXgfG","./approveChecked.mjs":"8BTgm","./burn.mjs":"asBxd","./burnChecked.mjs":"5zGbF","./closeAccount.mjs":"hLvDh","./freezeAccount.mjs":"9WKle","./initializeAccount.mjs":"5cBHp","./initializeMint.mjs":"j0VMi","./initializeMultisig.mjs":"aub37","./mintTo.mjs":"zvv9V","./mintToChecked.mjs":"lAUnV","./revoke.mjs":"lqKWe","./setAuthority.mjs":"c1Rco","./syncNative.mjs":"hlXvc","./thawAccount.mjs":"9TrcN","./transfer.mjs":"jg6EO","./transferChecked.mjs":"hYWCZ","./types.mjs":"fLCUz","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iat4R":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Construct an AssociatedTokenAccount instruction
 *
 * @param payer                    Payer of the initialization fees
 * @param associatedToken          New associated token account
 * @param owner                    Owner of the new account
 * @param mint                     Token mint account
 * @param programId                SPL Token program account
 * @param associatedTokenProgramId SPL Associated Token program account
 *
 * @return Instruction to add to a transaction
 */ parcelHelpers.export(exports, "createAssociatedTokenAccountInstruction", ()=>createAssociatedTokenAccountInstruction);
var _web3Js = require("@solana/web3.js");
var _constantsMjs = require("./../constants.mjs");
var Buffer = require("82650e7d97277d5d").Buffer;
function createAssociatedTokenAccountInstruction(payer, associatedToken, owner, mint, programId = (0, _constantsMjs.TOKEN_PROGRAM_ID), associatedTokenProgramId = (0, _constantsMjs.ASSOCIATED_TOKEN_PROGRAM_ID)) {
    const keys = [
        {
            pubkey: payer,
            isSigner: true,
            isWritable: true
        },
        {
            pubkey: associatedToken,
            isSigner: false,
            isWritable: true
        },
        {
            pubkey: owner,
            isSigner: false,
            isWritable: false
        },
        {
            pubkey: mint,
            isSigner: false,
            isWritable: false
        },
        {
            pubkey: (0, _web3Js.SystemProgram).programId,
            isSigner: false,
            isWritable: false
        },
        {
            pubkey: programId,
            isSigner: false,
            isWritable: false
        },
        {
            pubkey: (0, _web3Js.SYSVAR_RENT_PUBKEY),
            isSigner: false,
            isWritable: false
        }
    ];
    return new (0, _web3Js.TransactionInstruction)({
        keys,
        programId: associatedTokenProgramId,
        data: Buffer.alloc(0)
    });
}

},{"82650e7d97277d5d":"fCgem","@solana/web3.js":"5JBKN","./../constants.mjs":"dBO94","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"d4xGL":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _accountMjs = require("./account.mjs");
parcelHelpers.exportAll(_accountMjs, exports);
var _mintMjs = require("./mint.mjs");
parcelHelpers.exportAll(_mintMjs, exports);
var _multisigMjs = require("./multisig.mjs");
parcelHelpers.exportAll(_multisigMjs, exports);

},{"./account.mjs":"c5T8r","./mint.mjs":"ernxC","./multisig.mjs":"ip1cF","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"c5T8r":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AccountState", ()=>AccountState);
parcelHelpers.export(exports, "AccountLayout", ()=>AccountLayout);
parcelHelpers.export(exports, "ACCOUNT_SIZE", ()=>ACCOUNT_SIZE);
/**
 * Retrieve information about a token account
 *
 * @param connection Connection to use
 * @param address    Token account
 * @param commitment Desired level of commitment for querying the state
 * @param programId  SPL Token program account
 *
 * @return Token account information
 */ parcelHelpers.export(exports, "getAccount", ()=>getAccount);
/** Get the minimum lamport balance for a token account to be rent exempt
 *
 * @param connection Connection to use
 * @param commitment Desired level of commitment for querying the state
 *
 * @return Amount of lamports required
 */ parcelHelpers.export(exports, "getMinimumBalanceForRentExemptAccount", ()=>getMinimumBalanceForRentExemptAccount);
var _bufferLayout = require("@solana/buffer-layout");
var _bufferLayoutUtils = require("@solana/buffer-layout-utils");
var _constantsMjs = require("./../constants.mjs");
var _errorsMjs = require("./../errors.mjs");
var AccountState;
(function(AccountState) {
    AccountState[AccountState["Uninitialized"] = 0] = "Uninitialized";
    AccountState[AccountState["Initialized"] = 1] = "Initialized";
    AccountState[AccountState["Frozen"] = 2] = "Frozen";
})(AccountState || (AccountState = {}));
const AccountLayout = (0, _bufferLayout.struct)([
    (0, _bufferLayoutUtils.publicKey)("mint"),
    (0, _bufferLayoutUtils.publicKey)("owner"),
    (0, _bufferLayoutUtils.u64)("amount"),
    (0, _bufferLayout.u32)("delegateOption"),
    (0, _bufferLayoutUtils.publicKey)("delegate"),
    (0, _bufferLayout.u8)("state"),
    (0, _bufferLayout.u32)("isNativeOption"),
    (0, _bufferLayoutUtils.u64)("isNative"),
    (0, _bufferLayoutUtils.u64)("delegatedAmount"),
    (0, _bufferLayout.u32)("closeAuthorityOption"),
    (0, _bufferLayoutUtils.publicKey)("closeAuthority")
]);
const ACCOUNT_SIZE = AccountLayout.span;
async function getAccount(connection, address, commitment, programId = (0, _constantsMjs.TOKEN_PROGRAM_ID)) {
    const info = await connection.getAccountInfo(address, commitment);
    if (!info) throw new (0, _errorsMjs.TokenAccountNotFoundError)();
    if (!info.owner.equals(programId)) throw new (0, _errorsMjs.TokenInvalidAccountOwnerError)();
    if (info.data.length != ACCOUNT_SIZE) throw new (0, _errorsMjs.TokenInvalidAccountSizeError)();
    const rawAccount = AccountLayout.decode(info.data);
    return {
        address,
        mint: rawAccount.mint,
        owner: rawAccount.owner,
        amount: rawAccount.amount,
        delegate: rawAccount.delegateOption ? rawAccount.delegate : null,
        delegatedAmount: rawAccount.delegatedAmount,
        isInitialized: rawAccount.state !== AccountState.Uninitialized,
        isFrozen: rawAccount.state === AccountState.Frozen,
        isNative: !!rawAccount.isNativeOption,
        rentExemptReserve: rawAccount.isNativeOption ? rawAccount.isNative : null,
        closeAuthority: rawAccount.closeAuthorityOption ? rawAccount.closeAuthority : null
    };
}
async function getMinimumBalanceForRentExemptAccount(connection, commitment) {
    return await connection.getMinimumBalanceForRentExemption(ACCOUNT_SIZE, commitment);
}

},{"@solana/buffer-layout":"jD9A8","@solana/buffer-layout-utils":"hVYs1","./../constants.mjs":"dBO94","./../errors.mjs":"3x3WE","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ernxC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "MintLayout", ()=>MintLayout);
parcelHelpers.export(exports, "MINT_SIZE", ()=>MINT_SIZE);
/**
 * Retrieve information about a mint
 *
 * @param connection Connection to use
 * @param address    Mint account
 * @param commitment Desired level of commitment for querying the state
 * @param programId  SPL Token program account
 *
 * @return Mint information
 */ parcelHelpers.export(exports, "getMint", ()=>getMint);
/** Get the minimum lamport balance for a mint to be rent exempt
 *
 * @param connection Connection to use
 * @param commitment Desired level of commitment for querying the state
 *
 * @return Amount of lamports required
 */ parcelHelpers.export(exports, "getMinimumBalanceForRentExemptMint", ()=>getMinimumBalanceForRentExemptMint);
/**
 * Get the address of the associated token account for a given mint and owner
 *
 * @param mint                     Token mint account
 * @param owner                    Owner of the new account
 * @param allowOwnerOffCurve       Allow the owner account to be a PDA (Program Derived Address)
 * @param programId                SPL Token program account
 * @param associatedTokenProgramId SPL Associated Token program account
 *
 * @return Address of the associated token account
 */ parcelHelpers.export(exports, "getAssociatedTokenAddress", ()=>getAssociatedTokenAddress);
var _bufferLayout = require("@solana/buffer-layout");
var _bufferLayoutUtils = require("@solana/buffer-layout-utils");
var _web3Js = require("@solana/web3.js");
var _constantsMjs = require("./../constants.mjs");
var _errorsMjs = require("./../errors.mjs");
const MintLayout = (0, _bufferLayout.struct)([
    (0, _bufferLayout.u32)("mintAuthorityOption"),
    (0, _bufferLayoutUtils.publicKey)("mintAuthority"),
    (0, _bufferLayoutUtils.u64)("supply"),
    (0, _bufferLayout.u8)("decimals"),
    (0, _bufferLayoutUtils.bool)("isInitialized"),
    (0, _bufferLayout.u32)("freezeAuthorityOption"),
    (0, _bufferLayoutUtils.publicKey)("freezeAuthority")
]);
const MINT_SIZE = MintLayout.span;
async function getMint(connection, address, commitment, programId = (0, _constantsMjs.TOKEN_PROGRAM_ID)) {
    const info = await connection.getAccountInfo(address, commitment);
    if (!info) throw new (0, _errorsMjs.TokenAccountNotFoundError)();
    if (!info.owner.equals(programId)) throw new (0, _errorsMjs.TokenInvalidAccountOwnerError)();
    if (info.data.length != MINT_SIZE) throw new (0, _errorsMjs.TokenInvalidAccountSizeError)();
    const rawMint = MintLayout.decode(info.data);
    return {
        address,
        mintAuthority: rawMint.mintAuthorityOption ? rawMint.mintAuthority : null,
        supply: rawMint.supply,
        decimals: rawMint.decimals,
        isInitialized: rawMint.isInitialized,
        freezeAuthority: rawMint.freezeAuthorityOption ? rawMint.freezeAuthority : null
    };
}
async function getMinimumBalanceForRentExemptMint(connection, commitment) {
    return await connection.getMinimumBalanceForRentExemption(MINT_SIZE, commitment);
}
async function getAssociatedTokenAddress(mint, owner, allowOwnerOffCurve = false, programId = (0, _constantsMjs.TOKEN_PROGRAM_ID), associatedTokenProgramId = (0, _constantsMjs.ASSOCIATED_TOKEN_PROGRAM_ID)) {
    if (!allowOwnerOffCurve && !(0, _web3Js.PublicKey).isOnCurve(owner.toBuffer())) throw new (0, _errorsMjs.TokenOwnerOffCurveError)();
    const [address] = await (0, _web3Js.PublicKey).findProgramAddress([
        owner.toBuffer(),
        programId.toBuffer(),
        mint.toBuffer()
    ], associatedTokenProgramId);
    return address;
}

},{"@solana/buffer-layout":"jD9A8","@solana/buffer-layout-utils":"hVYs1","@solana/web3.js":"5JBKN","./../constants.mjs":"dBO94","./../errors.mjs":"3x3WE","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ip1cF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "MultisigLayout", ()=>MultisigLayout);
parcelHelpers.export(exports, "MULTISIG_SIZE", ()=>MULTISIG_SIZE);
/**
 * Retrieve information about a multisig
 *
 * @param connection Connection to use
 * @param address    Multisig account
 * @param commitment Desired level of commitment for querying the state
 * @param programId  SPL Token program account
 *
 * @return Multisig information
 */ parcelHelpers.export(exports, "getMultisig", ()=>getMultisig);
/** Get the minimum lamport balance for a multisig to be rent exempt
 *
 * @param connection Connection to use
 * @param commitment Desired level of commitment for querying the state
 *
 * @return Amount of lamports required
 */ parcelHelpers.export(exports, "getMinimumBalanceForRentExemptMultisig", ()=>getMinimumBalanceForRentExemptMultisig);
var _bufferLayout = require("@solana/buffer-layout");
var _bufferLayoutUtils = require("@solana/buffer-layout-utils");
var _constantsMjs = require("./../constants.mjs");
var _errorsMjs = require("./../errors.mjs");
const MultisigLayout = (0, _bufferLayout.struct)([
    (0, _bufferLayout.u8)("m"),
    (0, _bufferLayout.u8)("n"),
    (0, _bufferLayoutUtils.bool)("isInitialized"),
    (0, _bufferLayoutUtils.publicKey)("signer1"),
    (0, _bufferLayoutUtils.publicKey)("signer2"),
    (0, _bufferLayoutUtils.publicKey)("signer3"),
    (0, _bufferLayoutUtils.publicKey)("signer4"),
    (0, _bufferLayoutUtils.publicKey)("signer5"),
    (0, _bufferLayoutUtils.publicKey)("signer6"),
    (0, _bufferLayoutUtils.publicKey)("signer7"),
    (0, _bufferLayoutUtils.publicKey)("signer8"),
    (0, _bufferLayoutUtils.publicKey)("signer9"),
    (0, _bufferLayoutUtils.publicKey)("signer10"),
    (0, _bufferLayoutUtils.publicKey)("signer11")
]);
const MULTISIG_SIZE = MultisigLayout.span;
async function getMultisig(connection, address, commitment, programId = (0, _constantsMjs.TOKEN_PROGRAM_ID)) {
    const info = await connection.getAccountInfo(address, commitment);
    if (!info) throw new (0, _errorsMjs.TokenAccountNotFoundError)();
    if (!info.owner.equals(programId)) throw new (0, _errorsMjs.TokenInvalidAccountOwnerError)();
    if (info.data.length != MULTISIG_SIZE) throw new (0, _errorsMjs.TokenInvalidAccountSizeError)();
    return {
        address,
        ...MultisigLayout.decode(info.data)
    };
}
async function getMinimumBalanceForRentExemptMultisig(connection, commitment) {
    return await connection.getMinimumBalanceForRentExemption(MULTISIG_SIZE, commitment);
}

},{"@solana/buffer-layout":"jD9A8","@solana/buffer-layout-utils":"hVYs1","./../constants.mjs":"dBO94","./../errors.mjs":"3x3WE","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kWcXy":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _createMintMjs = require("./createMint.mjs");
parcelHelpers.exportAll(_createMintMjs, exports);
var _createAccountMjs = require("./createAccount.mjs");
parcelHelpers.exportAll(_createAccountMjs, exports);
var _createWrappedNativeAccountMjs = require("./createWrappedNativeAccount.mjs");
parcelHelpers.exportAll(_createWrappedNativeAccountMjs, exports);
var _createMultisigMjs = require("./createMultisig.mjs");
parcelHelpers.exportAll(_createMultisigMjs, exports);
var _transferMjs = require("./transfer.mjs");
parcelHelpers.exportAll(_transferMjs, exports);
var _approveMjs = require("./approve.mjs");
parcelHelpers.exportAll(_approveMjs, exports);
var _revokeMjs = require("./revoke.mjs");
parcelHelpers.exportAll(_revokeMjs, exports);
var _setAuthorityMjs = require("./setAuthority.mjs");
parcelHelpers.exportAll(_setAuthorityMjs, exports);
var _mintToMjs = require("./mintTo.mjs");
parcelHelpers.exportAll(_mintToMjs, exports);
var _burnMjs = require("./burn.mjs");
parcelHelpers.exportAll(_burnMjs, exports);
var _closeAccountMjs = require("./closeAccount.mjs");
parcelHelpers.exportAll(_closeAccountMjs, exports);
var _freezeAccountMjs = require("./freezeAccount.mjs");
parcelHelpers.exportAll(_freezeAccountMjs, exports);
var _thawAccountMjs = require("./thawAccount.mjs");
parcelHelpers.exportAll(_thawAccountMjs, exports);
var _transferCheckedMjs = require("./transferChecked.mjs");
parcelHelpers.exportAll(_transferCheckedMjs, exports);
var _approveCheckedMjs = require("./approveChecked.mjs");
parcelHelpers.exportAll(_approveCheckedMjs, exports);
var _mintToCheckedMjs = require("./mintToChecked.mjs");
parcelHelpers.exportAll(_mintToCheckedMjs, exports);
var _burnCheckedMjs = require("./burnChecked.mjs");
parcelHelpers.exportAll(_burnCheckedMjs, exports);
var _syncNativeMjs = require("./syncNative.mjs");
parcelHelpers.exportAll(_syncNativeMjs, exports);
var _createAssociatedTokenAccountMjs = require("./createAssociatedTokenAccount.mjs");
parcelHelpers.exportAll(_createAssociatedTokenAccountMjs, exports);
var _getOrCreateAssociatedTokenAccountMjs = require("./getOrCreateAssociatedTokenAccount.mjs");
parcelHelpers.exportAll(_getOrCreateAssociatedTokenAccountMjs, exports);

},{"./createMint.mjs":"5AKcX","./createAccount.mjs":"2dA2b","./createWrappedNativeAccount.mjs":"gBJD7","./createMultisig.mjs":"1a5Xz","./transfer.mjs":"nY7FD","./approve.mjs":"4vhcG","./revoke.mjs":"9B77D","./setAuthority.mjs":"62JDd","./mintTo.mjs":"hFXbT","./burn.mjs":"86FNj","./closeAccount.mjs":"k38va","./freezeAccount.mjs":"cYB3z","./thawAccount.mjs":"34cLv","./transferChecked.mjs":"jM5tB","./approveChecked.mjs":"hMMyr","./mintToChecked.mjs":"dkqYu","./burnChecked.mjs":"bS44F","./syncNative.mjs":"k78J0","./createAssociatedTokenAccount.mjs":"8PqcG","./getOrCreateAssociatedTokenAccount.mjs":"dIEOx","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5AKcX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Create and initialize a new mint
 *
 * @param connection      Connection to use
 * @param payer           Payer of the transaction and initialization fees
 * @param mintAuthority   Account or multisig that will control minting
 * @param freezeAuthority Optional account or multisig that can freeze token accounts
 * @param decimals        Location of the decimal place
 * @param keypair         Optional keypair, defaulting to a new random one
 * @param confirmOptions  Options for confirming the transaction
 * @param programId       SPL Token program account
 *
 * @return Address of the new mint
 */ parcelHelpers.export(exports, "createMint", ()=>createMint);
var _web3Js = require("@solana/web3.js");
var _constantsMjs = require("./../constants.mjs");
var _indexMjs = require("./../instructions/index.mjs");
var _indexMjs1 = require("./../state/index.mjs");
async function createMint(connection, payer, mintAuthority, freezeAuthority, decimals, keypair = (0, _web3Js.Keypair).generate(), confirmOptions, programId = (0, _constantsMjs.TOKEN_PROGRAM_ID)) {
    const lamports = await (0, _indexMjs1.getMinimumBalanceForRentExemptMint)(connection);
    const transaction = new (0, _web3Js.Transaction)().add((0, _web3Js.SystemProgram).createAccount({
        fromPubkey: payer.publicKey,
        newAccountPubkey: keypair.publicKey,
        space: (0, _indexMjs1.MINT_SIZE),
        lamports,
        programId
    }), (0, _indexMjs.createInitializeMintInstruction)(keypair.publicKey, decimals, mintAuthority, freezeAuthority, programId));
    await (0, _web3Js.sendAndConfirmTransaction)(connection, transaction, [
        payer,
        keypair
    ], confirmOptions);
    return keypair.publicKey;
}

},{"@solana/web3.js":"5JBKN","./../constants.mjs":"dBO94","./../instructions/index.mjs":"4LHfF","./../state/index.mjs":"d4xGL","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2dA2b":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Create and initialize a new token account
 *
 * @param connection     Connection to use
 * @param payer          Payer of the transaction and initialization fees
 * @param mint           Mint for the account
 * @param owner          Owner of the new account
 * @param keypair        Optional keypair, defaulting to the associated token account for the `mint` and `owner`
 * @param confirmOptions Options for confirming the transaction
 * @param programId      SPL Token program account
 *
 * @return Address of the new token account
 */ parcelHelpers.export(exports, "createAccount", ()=>createAccount);
var _web3Js = require("@solana/web3.js");
var _constantsMjs = require("./../constants.mjs");
var _indexMjs = require("./../instructions/index.mjs");
var _indexMjs1 = require("./../state/index.mjs");
var _createAssociatedTokenAccountMjs = require("./createAssociatedTokenAccount.mjs");
async function createAccount(connection, payer, mint, owner, keypair, confirmOptions, programId = (0, _constantsMjs.TOKEN_PROGRAM_ID)) {
    // If a keypair isn't provided, create the associated token account and return its address
    if (!keypair) return await (0, _createAssociatedTokenAccountMjs.createAssociatedTokenAccount)(connection, payer, mint, owner, confirmOptions, programId);
    // Otherwise, create the account with the provided keypair and return its public key
    const lamports = await (0, _indexMjs1.getMinimumBalanceForRentExemptAccount)(connection);
    const transaction = new (0, _web3Js.Transaction)().add((0, _web3Js.SystemProgram).createAccount({
        fromPubkey: payer.publicKey,
        newAccountPubkey: keypair.publicKey,
        space: (0, _indexMjs1.ACCOUNT_SIZE),
        lamports,
        programId
    }), (0, _indexMjs.createInitializeAccountInstruction)(keypair.publicKey, mint, owner, programId));
    await (0, _web3Js.sendAndConfirmTransaction)(connection, transaction, [
        payer,
        keypair
    ], confirmOptions);
    return keypair.publicKey;
}

},{"@solana/web3.js":"5JBKN","./../constants.mjs":"dBO94","./../instructions/index.mjs":"4LHfF","./../state/index.mjs":"d4xGL","./createAssociatedTokenAccount.mjs":"8PqcG","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8PqcG":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Create and initialize a new associated token account
 *
 * @param connection               Connection to use
 * @param payer                    Payer of the transaction and initialization fees
 * @param mint                     Mint for the account
 * @param owner                    Owner of the new account
 * @param confirmOptions           Options for confirming the transaction
 * @param programId                SPL Token program account
 * @param associatedTokenProgramId SPL Associated Token program account
 *
 * @return Address of the new associated token account
 */ parcelHelpers.export(exports, "createAssociatedTokenAccount", ()=>createAssociatedTokenAccount);
var _web3Js = require("@solana/web3.js");
var _constantsMjs = require("./../constants.mjs");
var _indexMjs = require("./../instructions/index.mjs");
var _indexMjs1 = require("./../state/index.mjs");
async function createAssociatedTokenAccount(connection, payer, mint, owner, confirmOptions, programId = (0, _constantsMjs.TOKEN_PROGRAM_ID), associatedTokenProgramId = (0, _constantsMjs.ASSOCIATED_TOKEN_PROGRAM_ID)) {
    const associatedToken = await (0, _indexMjs1.getAssociatedTokenAddress)(mint, owner, false, programId, associatedTokenProgramId);
    const transaction = new (0, _web3Js.Transaction)().add((0, _indexMjs.createAssociatedTokenAccountInstruction)(payer.publicKey, associatedToken, owner, mint, programId, associatedTokenProgramId));
    await (0, _web3Js.sendAndConfirmTransaction)(connection, transaction, [
        payer
    ], confirmOptions);
    return associatedToken;
}

},{"@solana/web3.js":"5JBKN","./../constants.mjs":"dBO94","./../instructions/index.mjs":"4LHfF","./../state/index.mjs":"d4xGL","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gBJD7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Create, initialize, and fund a new wrapped native SOL account
 *
 * @param connection     Connection to use
 * @param payer          Payer of the transaction and initialization fees
 * @param owner          Owner of the new token account
 * @param amount         Number of lamports to wrap
 * @param keypair        Optional keypair, defaulting to the associated token account for the native mint and `owner`
 * @param confirmOptions Options for confirming the transaction
 * @param programId      SPL Token program account
 *
 * @return Address of the new wrapped native SOL account
 */ parcelHelpers.export(exports, "createWrappedNativeAccount", ()=>createWrappedNativeAccount);
var _web3Js = require("@solana/web3.js");
var _constantsMjs = require("./../constants.mjs");
var _indexMjs = require("./../instructions/index.mjs");
var _indexMjs1 = require("./../state/index.mjs");
var _createAccountMjs = require("./createAccount.mjs");
async function createWrappedNativeAccount(connection, payer, owner, amount, keypair, confirmOptions, programId = (0, _constantsMjs.TOKEN_PROGRAM_ID)) {
    // If the amount provided is explicitly 0 or NaN, just create the account without funding it
    if (!amount) return await (0, _createAccountMjs.createAccount)(connection, payer, (0, _constantsMjs.NATIVE_MINT), owner, keypair, confirmOptions, programId);
    // If a keypair isn't provided, create the account at the owner's ATA for the native mint and return its address
    if (!keypair) {
        const associatedToken = await (0, _indexMjs1.getAssociatedTokenAddress)((0, _constantsMjs.NATIVE_MINT), owner, false, programId, (0, _constantsMjs.ASSOCIATED_TOKEN_PROGRAM_ID));
        const transaction = new (0, _web3Js.Transaction)().add((0, _indexMjs.createAssociatedTokenAccountInstruction)(payer.publicKey, associatedToken, owner, (0, _constantsMjs.NATIVE_MINT), programId, (0, _constantsMjs.ASSOCIATED_TOKEN_PROGRAM_ID)), (0, _web3Js.SystemProgram).transfer({
            fromPubkey: payer.publicKey,
            toPubkey: associatedToken,
            lamports: amount
        }), (0, _indexMjs.createSyncNativeInstruction)(associatedToken, programId));
        await (0, _web3Js.sendAndConfirmTransaction)(connection, transaction, [
            payer
        ], confirmOptions);
        return associatedToken;
    }
    // Otherwise, create the account with the provided keypair and return its public key
    const lamports = await (0, _indexMjs1.getMinimumBalanceForRentExemptAccount)(connection);
    const transaction = new (0, _web3Js.Transaction)().add((0, _web3Js.SystemProgram).createAccount({
        fromPubkey: payer.publicKey,
        newAccountPubkey: keypair.publicKey,
        space: (0, _indexMjs1.ACCOUNT_SIZE),
        lamports,
        programId
    }), (0, _web3Js.SystemProgram).transfer({
        fromPubkey: payer.publicKey,
        toPubkey: keypair.publicKey,
        lamports: amount
    }), (0, _indexMjs.createInitializeAccountInstruction)(keypair.publicKey, (0, _constantsMjs.NATIVE_MINT), owner, programId));
    await (0, _web3Js.sendAndConfirmTransaction)(connection, transaction, [
        payer,
        keypair
    ], confirmOptions);
    return keypair.publicKey;
}

},{"@solana/web3.js":"5JBKN","./../constants.mjs":"dBO94","./../instructions/index.mjs":"4LHfF","./../state/index.mjs":"d4xGL","./createAccount.mjs":"2dA2b","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1a5Xz":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Create and initialize a new multisig
 *
 * @param connection     Connection to use
 * @param payer          Payer of the transaction and initialization fees
 * @param signers        Full set of signers
 * @param m              Number of required signatures
 * @param keypair        Optional keypair, defaulting to a new random one
 * @param confirmOptions Options for confirming the transaction
 * @param programId      SPL Token program account
 *
 * @return Address of the new multisig
 */ parcelHelpers.export(exports, "createMultisig", ()=>createMultisig);
var _web3Js = require("@solana/web3.js");
var _constantsMjs = require("./../constants.mjs");
var _indexMjs = require("./../instructions/index.mjs");
var _indexMjs1 = require("./../state/index.mjs");
async function createMultisig(connection, payer, signers, m, keypair = (0, _web3Js.Keypair).generate(), confirmOptions, programId = (0, _constantsMjs.TOKEN_PROGRAM_ID)) {
    const lamports = await (0, _indexMjs1.getMinimumBalanceForRentExemptMultisig)(connection);
    const transaction = new (0, _web3Js.Transaction)().add((0, _web3Js.SystemProgram).createAccount({
        fromPubkey: payer.publicKey,
        newAccountPubkey: keypair.publicKey,
        space: (0, _indexMjs1.MULTISIG_SIZE),
        lamports,
        programId
    }), (0, _indexMjs.createInitializeMultisigInstruction)(keypair.publicKey, signers, m, programId));
    await (0, _web3Js.sendAndConfirmTransaction)(connection, transaction, [
        payer,
        keypair
    ], confirmOptions);
    return keypair.publicKey;
}

},{"@solana/web3.js":"5JBKN","./../constants.mjs":"dBO94","./../instructions/index.mjs":"4LHfF","./../state/index.mjs":"d4xGL","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"nY7FD":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Transfer tokens from one account to another
 *
 * @param connection     Connection to use
 * @param payer          Payer of the transaction fees
 * @param source         Source account
 * @param destination    Destination account
 * @param owner          Owner of the source account
 * @param amount         Number of tokens to transfer
 * @param multiSigners   Signing accounts if `owner` is a multisig
 * @param confirmOptions Options for confirming the transaction
 * @param programId      SPL Token program account
 *
 * @return Signature of the confirmed transaction
 */ parcelHelpers.export(exports, "transfer", ()=>transfer);
var _web3Js = require("@solana/web3.js");
var _constantsMjs = require("./../constants.mjs");
var _indexMjs = require("./../instructions/index.mjs");
var _internalMjs = require("./internal.mjs");
async function transfer(connection, payer, source, destination, owner, amount, multiSigners = [], confirmOptions, programId = (0, _constantsMjs.TOKEN_PROGRAM_ID)) {
    const [ownerPublicKey, signers] = (0, _internalMjs.getSigners)(owner, multiSigners);
    const transaction = new (0, _web3Js.Transaction)().add((0, _indexMjs.createTransferInstruction)(source, destination, ownerPublicKey, amount, multiSigners, programId));
    return await (0, _web3Js.sendAndConfirmTransaction)(connection, transaction, [
        payer,
        ...signers
    ], confirmOptions);
}

},{"@solana/web3.js":"5JBKN","./../constants.mjs":"dBO94","./../instructions/index.mjs":"4LHfF","./internal.mjs":"3aZFG","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3aZFG":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/** @internal */ parcelHelpers.export(exports, "getSigners", ()=>getSigners);
var _web3Js = require("@solana/web3.js");
function getSigners(signerOrMultisig, multiSigners) {
    return signerOrMultisig instanceof (0, _web3Js.PublicKey) ? [
        signerOrMultisig,
        multiSigners
    ] : [
        signerOrMultisig.publicKey,
        [
            signerOrMultisig
        ]
    ];
}

},{"@solana/web3.js":"5JBKN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4vhcG":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Approve a delegate to transfer up to a maximum number of tokens from an account
 *
 * @param connection     Connection to use
 * @param payer          Payer of the transaction fees
 * @param account        Address of the token account
 * @param delegate       Account authorized to transfer tokens from the account
 * @param owner          Owner of the account
 * @param amount         Maximum number of tokens the delegate may transfer
 * @param multiSigners   Signing accounts if `owner` is a multisig
 * @param confirmOptions Options for confirming the transaction
 * @param programId      SPL Token program account
 *
 * @return Signature of the confirmed transaction
 */ parcelHelpers.export(exports, "approve", ()=>approve);
var _web3Js = require("@solana/web3.js");
var _constantsMjs = require("./../constants.mjs");
var _indexMjs = require("./../instructions/index.mjs");
var _internalMjs = require("./internal.mjs");
async function approve(connection, payer, account, delegate, owner, amount, multiSigners = [], confirmOptions, programId = (0, _constantsMjs.TOKEN_PROGRAM_ID)) {
    const [ownerPublicKey, signers] = (0, _internalMjs.getSigners)(owner, multiSigners);
    const transaction = new (0, _web3Js.Transaction)().add((0, _indexMjs.createApproveInstruction)(account, delegate, ownerPublicKey, amount, multiSigners, programId));
    return await (0, _web3Js.sendAndConfirmTransaction)(connection, transaction, [
        payer,
        ...signers
    ], confirmOptions);
}

},{"@solana/web3.js":"5JBKN","./../constants.mjs":"dBO94","./../instructions/index.mjs":"4LHfF","./internal.mjs":"3aZFG","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9B77D":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Revoke approval for the transfer of tokens from an account
 *
 * @param connection     Connection to use
 * @param payer          Payer of the transaction fees
 * @param account        Address of the token account
 * @param owner          Owner of the account
 * @param multiSigners   Signing accounts if `owner` is a multisig
 * @param confirmOptions Options for confirming the transaction
 * @param programId      SPL Token program account
 *
 * @return Signature of the confirmed transaction
 */ parcelHelpers.export(exports, "revoke", ()=>revoke);
var _web3Js = require("@solana/web3.js");
var _constantsMjs = require("./../constants.mjs");
var _indexMjs = require("./../instructions/index.mjs");
var _internalMjs = require("./internal.mjs");
async function revoke(connection, payer, account, owner, multiSigners = [], confirmOptions, programId = (0, _constantsMjs.TOKEN_PROGRAM_ID)) {
    const [ownerPublicKey, signers] = (0, _internalMjs.getSigners)(owner, multiSigners);
    const transaction = new (0, _web3Js.Transaction)().add((0, _indexMjs.createRevokeInstruction)(account, ownerPublicKey, multiSigners, programId));
    return await (0, _web3Js.sendAndConfirmTransaction)(connection, transaction, [
        payer,
        ...signers
    ], confirmOptions);
}

},{"@solana/web3.js":"5JBKN","./../constants.mjs":"dBO94","./../instructions/index.mjs":"4LHfF","./internal.mjs":"3aZFG","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"62JDd":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Assign a new authority to the account
 *
 * @param connection       Connection to use
 * @param payer            Payer of the transaction fees
 * @param account          Address of the account
 * @param currentAuthority Current authority of the specified type
 * @param authorityType    Type of authority to set
 * @param newAuthority     New authority of the account
 * @param multiSigners     Signing accounts if `currentAuthority` is a multisig
 * @param confirmOptions   Options for confirming the transaction
 * @param programId        SPL Token program account
 *
 * @return Signature of the confirmed transaction
 */ parcelHelpers.export(exports, "setAuthority", ()=>setAuthority);
var _web3Js = require("@solana/web3.js");
var _constantsMjs = require("./../constants.mjs");
var _indexMjs = require("./../instructions/index.mjs");
var _internalMjs = require("./internal.mjs");
async function setAuthority(connection, payer, account, currentAuthority, authorityType, newAuthority, multiSigners = [], confirmOptions, programId = (0, _constantsMjs.TOKEN_PROGRAM_ID)) {
    const [currentAuthorityPublicKey, signers] = (0, _internalMjs.getSigners)(currentAuthority, multiSigners);
    const transaction = new (0, _web3Js.Transaction)().add((0, _indexMjs.createSetAuthorityInstruction)(account, currentAuthorityPublicKey, authorityType, newAuthority, multiSigners, programId));
    return await (0, _web3Js.sendAndConfirmTransaction)(connection, transaction, [
        payer,
        ...signers
    ], confirmOptions);
}

},{"@solana/web3.js":"5JBKN","./../constants.mjs":"dBO94","./../instructions/index.mjs":"4LHfF","./internal.mjs":"3aZFG","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hFXbT":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Mint tokens to an account
 *
 * @param connection     Connection to use
 * @param payer          Payer of the transaction fees
 * @param mint           Mint for the account
 * @param destination    Address of the account to mint to
 * @param authority      Minting authority
 * @param amount         Amount to mint
 * @param multiSigners   Signing accounts if `authority` is a multisig
 * @param confirmOptions Options for confirming the transaction
 * @param programId      SPL Token program account
 *
 * @return Signature of the confirmed transaction
 */ parcelHelpers.export(exports, "mintTo", ()=>mintTo);
var _web3Js = require("@solana/web3.js");
var _constantsMjs = require("./../constants.mjs");
var _indexMjs = require("./../instructions/index.mjs");
var _internalMjs = require("./internal.mjs");
async function mintTo(connection, payer, mint, destination, authority, amount, multiSigners = [], confirmOptions, programId = (0, _constantsMjs.TOKEN_PROGRAM_ID)) {
    const [authorityPublicKey, signers] = (0, _internalMjs.getSigners)(authority, multiSigners);
    const transaction = new (0, _web3Js.Transaction)().add((0, _indexMjs.createMintToInstruction)(mint, destination, authorityPublicKey, amount, multiSigners, programId));
    return await (0, _web3Js.sendAndConfirmTransaction)(connection, transaction, [
        payer,
        ...signers
    ], confirmOptions);
}

},{"@solana/web3.js":"5JBKN","./../constants.mjs":"dBO94","./../instructions/index.mjs":"4LHfF","./internal.mjs":"3aZFG","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"86FNj":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Burn tokens from an account
 *
 * @param connection     Connection to use
 * @param payer          Payer of the transaction fees
 * @param account        Account to burn tokens from
 * @param mint           Mint for the account
 * @param owner          Account owner
 * @param amount         Amount to burn
 * @param multiSigners   Signing accounts if `owner` is a multisig
 * @param confirmOptions Options for confirming the transaction
 * @param programId      SPL Token program account
 *
 * @return Signature of the confirmed transaction
 */ parcelHelpers.export(exports, "burn", ()=>burn);
var _web3Js = require("@solana/web3.js");
var _constantsMjs = require("./../constants.mjs");
var _indexMjs = require("./../instructions/index.mjs");
var _internalMjs = require("./internal.mjs");
async function burn(connection, payer, account, mint, owner, amount, multiSigners = [], confirmOptions, programId = (0, _constantsMjs.TOKEN_PROGRAM_ID)) {
    const [ownerPublicKey, signers] = (0, _internalMjs.getSigners)(owner, multiSigners);
    const transaction = new (0, _web3Js.Transaction)().add((0, _indexMjs.createBurnInstruction)(account, mint, ownerPublicKey, amount, multiSigners, programId));
    return await (0, _web3Js.sendAndConfirmTransaction)(connection, transaction, [
        payer,
        ...signers
    ], confirmOptions);
}

},{"@solana/web3.js":"5JBKN","./../constants.mjs":"dBO94","./../instructions/index.mjs":"4LHfF","./internal.mjs":"3aZFG","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"k38va":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Close a token account
 *
 * @param connection     Connection to use
 * @param payer          Payer of the transaction fees
 * @param account        Account to close
 * @param destination    Account to receive the remaining balance of the closed account
 * @param authority      Authority which is allowed to close the account
 * @param multiSigners   Signing accounts if `authority` is a multisig
 * @param confirmOptions Options for confirming the transaction
 * @param programId      SPL Token program account
 *
 * @return Signature of the confirmed transaction
 */ parcelHelpers.export(exports, "closeAccount", ()=>closeAccount);
var _web3Js = require("@solana/web3.js");
var _constantsMjs = require("./../constants.mjs");
var _indexMjs = require("./../instructions/index.mjs");
var _internalMjs = require("./internal.mjs");
async function closeAccount(connection, payer, account, destination, authority, multiSigners = [], confirmOptions, programId = (0, _constantsMjs.TOKEN_PROGRAM_ID)) {
    const [authorityPublicKey, signers] = (0, _internalMjs.getSigners)(authority, multiSigners);
    const transaction = new (0, _web3Js.Transaction)().add((0, _indexMjs.createCloseAccountInstruction)(account, destination, authorityPublicKey, multiSigners, programId));
    return await (0, _web3Js.sendAndConfirmTransaction)(connection, transaction, [
        payer,
        ...signers
    ], confirmOptions);
}

},{"@solana/web3.js":"5JBKN","./../constants.mjs":"dBO94","./../instructions/index.mjs":"4LHfF","./internal.mjs":"3aZFG","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cYB3z":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Freeze a token account
 *
 * @param connection     Connection to use
 * @param payer          Payer of the transaction fees
 * @param account        Account to freeze
 * @param mint           Mint for the account
 * @param authority      Mint freeze authority
 * @param multiSigners   Signing accounts if `authority` is a multisig
 * @param confirmOptions Options for confirming the transaction
 * @param programId      SPL Token program account
 *
 * @return Signature of the confirmed transaction
 */ parcelHelpers.export(exports, "freezeAccount", ()=>freezeAccount);
var _web3Js = require("@solana/web3.js");
var _constantsMjs = require("./../constants.mjs");
var _indexMjs = require("./../instructions/index.mjs");
var _internalMjs = require("./internal.mjs");
async function freezeAccount(connection, payer, account, mint, authority, multiSigners = [], confirmOptions, programId = (0, _constantsMjs.TOKEN_PROGRAM_ID)) {
    const [authorityPublicKey, signers] = (0, _internalMjs.getSigners)(authority, multiSigners);
    const transaction = new (0, _web3Js.Transaction)().add((0, _indexMjs.createFreezeAccountInstruction)(account, mint, authorityPublicKey, multiSigners, programId));
    return await (0, _web3Js.sendAndConfirmTransaction)(connection, transaction, [
        payer,
        ...signers
    ], confirmOptions);
}

},{"@solana/web3.js":"5JBKN","./../constants.mjs":"dBO94","./../instructions/index.mjs":"4LHfF","./internal.mjs":"3aZFG","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"34cLv":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Thaw (unfreeze) a token account
 *
 * @param connection     Connection to use
 * @param payer          Payer of the transaction fees
 * @param account        Account to thaw
 * @param mint           Mint for the account
 * @param authority      Mint freeze authority
 * @param multiSigners   Signing accounts if `authority` is a multisig
 * @param confirmOptions Options for confirming the transaction
 * @param programId      SPL Token program account
 *
 * @return Signature of the confirmed transaction
 */ parcelHelpers.export(exports, "thawAccount", ()=>thawAccount);
var _web3Js = require("@solana/web3.js");
var _constantsMjs = require("./../constants.mjs");
var _indexMjs = require("./../instructions/index.mjs");
var _internalMjs = require("./internal.mjs");
async function thawAccount(connection, payer, account, mint, authority, multiSigners = [], confirmOptions, programId = (0, _constantsMjs.TOKEN_PROGRAM_ID)) {
    const [authorityPublicKey, signers] = (0, _internalMjs.getSigners)(authority, multiSigners);
    const transaction = new (0, _web3Js.Transaction)().add((0, _indexMjs.createThawAccountInstruction)(account, mint, authorityPublicKey, multiSigners, programId));
    return await (0, _web3Js.sendAndConfirmTransaction)(connection, transaction, [
        payer,
        ...signers
    ], confirmOptions);
}

},{"@solana/web3.js":"5JBKN","./../constants.mjs":"dBO94","./../instructions/index.mjs":"4LHfF","./internal.mjs":"3aZFG","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jM5tB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Transfer tokens from one account to another, asserting the token mint and decimals
 *
 * @param connection     Connection to use
 * @param payer          Payer of the transaction fees
 * @param source         Source account
 * @param mint           Mint for the account
 * @param destination    Destination account
 * @param owner          Owner of the source account
 * @param amount         Number of tokens to transfer
 * @param decimals       Number of decimals in transfer amount
 * @param multiSigners   Signing accounts if `owner` is a multisig
 * @param confirmOptions Options for confirming the transaction
 * @param programId      SPL Token program account
 *
 * @return Signature of the confirmed transaction
 */ parcelHelpers.export(exports, "transferChecked", ()=>transferChecked);
var _web3Js = require("@solana/web3.js");
var _constantsMjs = require("./../constants.mjs");
var _indexMjs = require("./../instructions/index.mjs");
var _internalMjs = require("./internal.mjs");
async function transferChecked(connection, payer, source, mint, destination, owner, amount, decimals, multiSigners = [], confirmOptions, programId = (0, _constantsMjs.TOKEN_PROGRAM_ID)) {
    const [ownerPublicKey, signers] = (0, _internalMjs.getSigners)(owner, multiSigners);
    const transaction = new (0, _web3Js.Transaction)().add((0, _indexMjs.createTransferCheckedInstruction)(source, mint, destination, ownerPublicKey, amount, decimals, multiSigners, programId));
    return await (0, _web3Js.sendAndConfirmTransaction)(connection, transaction, [
        payer,
        ...signers
    ], confirmOptions);
}

},{"@solana/web3.js":"5JBKN","./../constants.mjs":"dBO94","./../instructions/index.mjs":"4LHfF","./internal.mjs":"3aZFG","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hMMyr":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Approve a delegate to transfer up to a maximum number of tokens from an account, asserting the token mint and
 * decimals
 *
 * @param connection     Connection to use
 * @param payer          Payer of the transaction fees
 * @param account        Address of the account
 * @param delegate       Account authorized to perform a transfer tokens from the source account
 * @param owner          Owner of the source account
 * @param amount         Maximum number of tokens the delegate may transfer
 * @param decimals       Number of decimals in approve amount
 * @param multiSigners   Signing accounts if `owner` is a multisig
 * @param confirmOptions Options for confirming the transaction
 * @param programId      SPL Token program account
 *
 * @return Signature of the confirmed transaction
 */ parcelHelpers.export(exports, "approveChecked", ()=>approveChecked);
var _web3Js = require("@solana/web3.js");
var _constantsMjs = require("./../constants.mjs");
var _indexMjs = require("./../instructions/index.mjs");
var _internalMjs = require("./internal.mjs");
async function approveChecked(connection, payer, mint, account, delegate, owner, amount, decimals, multiSigners = [], confirmOptions, programId = (0, _constantsMjs.TOKEN_PROGRAM_ID)) {
    const [ownerPublicKey, signers] = (0, _internalMjs.getSigners)(owner, multiSigners);
    const transaction = new (0, _web3Js.Transaction)().add((0, _indexMjs.createApproveCheckedInstruction)(account, mint, delegate, ownerPublicKey, amount, decimals, multiSigners, programId));
    return await (0, _web3Js.sendAndConfirmTransaction)(connection, transaction, [
        payer,
        ...signers
    ], confirmOptions);
}

},{"@solana/web3.js":"5JBKN","./../constants.mjs":"dBO94","./../instructions/index.mjs":"4LHfF","./internal.mjs":"3aZFG","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dkqYu":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Mint tokens to an account, asserting the token mint and decimals
 *
 * @param connection     Connection to use
 * @param payer          Payer of the transaction fees
 * @param mint           Mint for the account
 * @param destination    Address of the account to mint to
 * @param authority      Minting authority
 * @param amount         Amount to mint
 * @param decimals       Number of decimals in amount to mint
 * @param multiSigners   Signing accounts if `authority` is a multisig
 * @param confirmOptions Options for confirming the transaction
 * @param programId      SPL Token program account
 *
 * @return Signature of the confirmed transaction
 */ parcelHelpers.export(exports, "mintToChecked", ()=>mintToChecked);
var _web3Js = require("@solana/web3.js");
var _constantsMjs = require("./../constants.mjs");
var _indexMjs = require("./../instructions/index.mjs");
var _internalMjs = require("./internal.mjs");
async function mintToChecked(connection, payer, mint, destination, authority, amount, decimals, multiSigners = [], confirmOptions, programId = (0, _constantsMjs.TOKEN_PROGRAM_ID)) {
    const [authorityPublicKey, signers] = (0, _internalMjs.getSigners)(authority, multiSigners);
    const transaction = new (0, _web3Js.Transaction)().add((0, _indexMjs.createMintToCheckedInstruction)(mint, destination, authorityPublicKey, amount, decimals, multiSigners, programId));
    return await (0, _web3Js.sendAndConfirmTransaction)(connection, transaction, [
        payer,
        ...signers
    ], confirmOptions);
}

},{"@solana/web3.js":"5JBKN","./../constants.mjs":"dBO94","./../instructions/index.mjs":"4LHfF","./internal.mjs":"3aZFG","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bS44F":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Burn tokens from an account, asserting the token mint and decimals
 *
 * @param connection     Connection to use
 * @param payer          Payer of the transaction fees
 * @param account        Account to burn tokens from
 * @param mint           Mint for the account
 * @param owner          Account owner
 * @param amount         Amount to burn
 * @param decimals       Number of decimals in amount to burn
 * @param multiSigners   Signing accounts if `owner` is a multisig
 * @param confirmOptions Options for confirming the transaction
 * @param programId      SPL Token program account
 *
 * @return Signature of the confirmed transaction
 */ parcelHelpers.export(exports, "burnChecked", ()=>burnChecked);
var _web3Js = require("@solana/web3.js");
var _constantsMjs = require("./../constants.mjs");
var _indexMjs = require("./../instructions/index.mjs");
var _internalMjs = require("./internal.mjs");
async function burnChecked(connection, payer, account, mint, owner, amount, decimals, multiSigners = [], confirmOptions, programId = (0, _constantsMjs.TOKEN_PROGRAM_ID)) {
    const [ownerPublicKey, signers] = (0, _internalMjs.getSigners)(owner, multiSigners);
    const transaction = new (0, _web3Js.Transaction)().add((0, _indexMjs.createBurnCheckedInstruction)(account, mint, ownerPublicKey, amount, decimals, multiSigners, programId));
    return await (0, _web3Js.sendAndConfirmTransaction)(connection, transaction, [
        payer,
        ...signers
    ], confirmOptions);
}

},{"@solana/web3.js":"5JBKN","./../constants.mjs":"dBO94","./../instructions/index.mjs":"4LHfF","./internal.mjs":"3aZFG","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"k78J0":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Sync the balance of a native SPL token account to the underlying system account's lamports
 *
 * @param connection     Connection to use
 * @param payer          Payer of the transaction fees
 * @param account        Native account to sync
 * @param confirmOptions Options for confirming the transaction
 * @param programId      SPL Token program account
 *
 * @return Signature of the confirmed transaction
 */ parcelHelpers.export(exports, "syncNative", ()=>syncNative);
var _web3Js = require("@solana/web3.js");
var _constantsMjs = require("./../constants.mjs");
var _indexMjs = require("./../instructions/index.mjs");
async function syncNative(connection, payer, account, confirmOptions, programId = (0, _constantsMjs.TOKEN_PROGRAM_ID)) {
    const transaction = new (0, _web3Js.Transaction)().add((0, _indexMjs.createSyncNativeInstruction)(account, programId));
    return await (0, _web3Js.sendAndConfirmTransaction)(connection, transaction, [
        payer
    ], confirmOptions);
}

},{"@solana/web3.js":"5JBKN","./../constants.mjs":"dBO94","./../instructions/index.mjs":"4LHfF","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dIEOx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Retrieve the associated token account, or create it if it doesn't exist
 *
 * @param connection               Connection to use
 * @param payer                    Payer of the transaction and initialization fees
 * @param mint                     Mint associated with the account to set or verify
 * @param owner                    Owner of the account to set or verify
 * @param allowOwnerOffCurve       Allow the owner account to be a PDA (Program Derived Address)
 * @param commitment               Desired level of commitment for querying the state
 * @param confirmOptions           Options for confirming the transaction
 * @param programId                SPL Token program account
 * @param associatedTokenProgramId SPL Associated Token program account
 *
 * @return Address of the new associated token account
 */ parcelHelpers.export(exports, "getOrCreateAssociatedTokenAccount", ()=>getOrCreateAssociatedTokenAccount);
var _web3Js = require("@solana/web3.js");
var _constantsMjs = require("./../constants.mjs");
var _errorsMjs = require("./../errors.mjs");
var _indexMjs = require("./../instructions/index.mjs");
var _indexMjs1 = require("./../state/index.mjs");
async function getOrCreateAssociatedTokenAccount(connection, payer, mint, owner, allowOwnerOffCurve = false, commitment, confirmOptions, programId = (0, _constantsMjs.TOKEN_PROGRAM_ID), associatedTokenProgramId = (0, _constantsMjs.ASSOCIATED_TOKEN_PROGRAM_ID)) {
    const associatedToken = await (0, _indexMjs1.getAssociatedTokenAddress)(mint, owner, allowOwnerOffCurve, programId, associatedTokenProgramId);
    // This is the optimal logic, considering TX fee, client-side computation, RPC roundtrips and guaranteed idempotent.
    // Sadly we can't do this atomically.
    let account;
    try {
        account = await (0, _indexMjs1.getAccount)(connection, associatedToken, commitment, programId);
    } catch (error) {
        // TokenAccountNotFoundError can be possible if the associated address has already received some lamports,
        // becoming a system account. Assuming program derived addressing is safe, this is the only case for the
        // TokenInvalidAccountOwnerError in this code path.
        if (error instanceof (0, _errorsMjs.TokenAccountNotFoundError) || error instanceof (0, _errorsMjs.TokenInvalidAccountOwnerError)) {
            // As this isn't atomic, it's possible others can create associated accounts meanwhile.
            try {
                const transaction = new (0, _web3Js.Transaction)().add((0, _indexMjs.createAssociatedTokenAccountInstruction)(payer.publicKey, associatedToken, owner, mint, programId, associatedTokenProgramId));
                await (0, _web3Js.sendAndConfirmTransaction)(connection, transaction, [
                    payer
                ], confirmOptions);
            } catch (error) {
            // Ignore all errors; for now there is no API-compatible way to selectively ignore the expected
            // instruction error if the associated account exists already.
            }
            // Now this should always succeed
            account = await (0, _indexMjs1.getAccount)(connection, associatedToken, commitment, programId);
        } else throw error;
    }
    if (!account.mint.equals(mint)) throw new (0, _errorsMjs.TokenInvalidMintError)();
    if (!account.owner.equals(owner)) throw new (0, _errorsMjs.TokenInvalidOwnerError)();
    return account;
}

},{"@solana/web3.js":"5JBKN","./../constants.mjs":"dBO94","./../errors.mjs":"3x3WE","./../instructions/index.mjs":"4LHfF","./../state/index.mjs":"d4xGL","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7bkwb":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Encode a Solana Pay URL from required and optional components.
 *
 * @param {EncodeURLComponents} components
 *
 * @param components.recipient
 * @param components.amount
 * @param components.splToken
 * @param components.reference
 * @param components.label
 * @param components.message
 * @param components.memo
 */ parcelHelpers.export(exports, "encodeURL", ()=>encodeURL);
var _constantsMjs = require("./constants.mjs");
function encodeURL({ recipient, ...params }) {
    let url = (0, _constantsMjs.URL_PROTOCOL) + encodeURIComponent(recipient.toBase58());
    const encodedParams = encodeURLParams(params);
    if (encodedParams) url += "?" + encodedParams;
    return url;
}
function encodeURLParams({ amount, splToken, reference, label, message, memo }) {
    const params = [];
    if (amount) params.push([
        "amount",
        amount.toFixed(amount.decimalPlaces())
    ]);
    if (splToken) params.push([
        "spl-token",
        splToken.toBase58()
    ]);
    if (reference) {
        if (!Array.isArray(reference)) reference = [
            reference
        ];
        for (const pubkey of reference)params.push([
            "reference",
            pubkey.toBase58()
        ]);
    }
    if (label) params.push([
        "label",
        label
    ]);
    if (message) params.push([
        "message",
        message
    ]);
    if (memo) params.push([
        "memo",
        memo
    ]);
    return params.map(([key, value])=>`${key}=${encodeURIComponent(value)}`).join("&");
}

},{"./constants.mjs":"6sOvE","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4PUc9":[function(require,module,exports) {
/**
 * Thrown when no transaction signature can be found referencing a given public key.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "FindTransactionSignatureError", ()=>FindTransactionSignatureError);
/**
 * Find the oldest transaction signature referencing a given public key.
 *
 * @throws if signature can't be found
 *
 * @param connection - A connection to the cluster.
 * @param reference - `reference` in the [Solana Pay spec](https://github.com/solana-labs/solana-pay/blob/master/SPEC.md#reference)
 * @param {SignaturesForAddressOptions} options - Options for `getSignaturesForAddress`.
 * @param {Finality} finality - A subset of Commitment levels, which are at least optimistically confirmed.
 */ parcelHelpers.export(exports, "findTransactionSignature", ()=>findTransactionSignature);
class FindTransactionSignatureError extends Error {
    constructor(){
        super(...arguments);
        this.name = "FindTransactionSignatureError";
    }
}
async function findTransactionSignature(connection, reference, options, finality) {
    const signatures = await connection.getSignaturesForAddress(reference, options, finality);
    const length = signatures.length;
    if (!length) throw new FindTransactionSignatureError("not found");
    // If multiple transaction signatures are found within the limit, return the oldest one.
    if (length < ((options === null || options === void 0 ? void 0 : options.limit) || 1000)) return signatures[length - 1];
    try {
        // In the unlikely event that more signatures than the limit are found, recursively find the oldest one.
        return await findTransactionSignature(connection, reference, options, finality);
    } catch (error) {
        if (error instanceof FindTransactionSignatureError) return signatures[length - 1];
        throw error;
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"goAqI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Thrown when a URL can't be parsed as a Solana Pay URL.
 */ parcelHelpers.export(exports, "ParseURLError", ()=>ParseURLError);
/**
 * Parse the components of a Solana Pay URL.
 *
 * **Reference** implementation for wallet providers.
 *
 * @param url - A Solana Pay URL
 */ parcelHelpers.export(exports, "parseURL", ()=>parseURL);
var _web3Js = require("@solana/web3.js");
var _bignumberJs = require("bignumber.js");
var _bignumberJsDefault = parcelHelpers.interopDefault(_bignumberJs);
var _constantsMjs = require("./constants.mjs");
class ParseURLError extends Error {
    constructor(){
        super(...arguments);
        this.name = "ParseURLError";
    }
}
function parseURL(url) {
    if (url.length > 2048) throw new ParseURLError("length invalid");
    const { protocol, pathname, searchParams } = new URL(url);
    if (protocol !== (0, _constantsMjs.URL_PROTOCOL)) throw new ParseURLError("protocol invalid");
    if (!pathname) throw new ParseURLError("recipient missing");
    let recipient;
    try {
        recipient = new (0, _web3Js.PublicKey)(pathname);
    } catch (error) {
        throw new ParseURLError("recipient invalid");
    }
    let amount;
    const amountParam = searchParams.get("amount");
    if (amountParam != null) {
        if (!/^\d+(\.\d+)?$/.test(amountParam)) throw new ParseURLError("amount invalid");
        amount = new (0, _bignumberJsDefault.default)(amountParam);
        if (amount.isNaN()) throw new ParseURLError("amount NaN");
        if (amount.isNegative()) throw new ParseURLError("amount negative");
    }
    let splToken;
    const splTokenParam = searchParams.get("spl-token");
    if (splTokenParam != null) try {
        splToken = new (0, _web3Js.PublicKey)(splTokenParam);
    } catch (error) {
        throw new ParseURLError("token invalid");
    }
    let reference;
    const referenceParam = searchParams.getAll("reference");
    if (referenceParam.length) try {
        reference = referenceParam.map((reference)=>new (0, _web3Js.PublicKey)(reference));
    } catch (error) {
        throw new ParseURLError("reference invalid");
    }
    const label = searchParams.get("label") || undefined;
    const message = searchParams.get("message") || undefined;
    const memo = searchParams.get("memo") || undefined;
    return {
        recipient,
        amount,
        splToken,
        reference,
        label,
        message,
        memo
    };
}

},{"@solana/web3.js":"5JBKN","bignumber.js":"57qkX","./constants.mjs":"6sOvE","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"djp50":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Thrown when a transaction doesn't contain a valid Solana Pay transfer.
 */ parcelHelpers.export(exports, "ValidateTransactionSignatureError", ()=>ValidateTransactionSignatureError);
/**
 * Validate that a given transaction signature corresponds with a transaction containing a valid Solana Pay transfer.
 *
 * @param connection - A connection to the cluster.
 * @param signature -  The signature to validate.
 * @param recipient - `recipient` in the [Solana Pay spec](https://github.com/solana-labs/solana-pay/blob/master/SPEC.md#recipient)
 * @param amount - `amount` in the [Solana Pay spec](https://github.com/solana-labs/solana-pay/blob/master/SPEC.md#amount)
 * @param splToken - `splToken` in the [Solana Pay spec](https://github.com/solana-labs/solana-pay/blob/master/SPEC.md#spl-token)
 * @param reference -`reference` in the [Solana Pay spec](https://github.com/solana-labs/solana-pay/blob/master/SPEC.md#reference)
 * @param {Finality} finality - A subset of Commitment levels, which are at least optimistically confirmed
 */ parcelHelpers.export(exports, "validateTransactionSignature", ()=>validateTransactionSignature);
var _splToken = require("@solana/spl-token");
var _web3Js = require("@solana/web3.js");
var _bignumberJs = require("bignumber.js");
var _bignumberJsDefault = parcelHelpers.interopDefault(_bignumberJs);
class ValidateTransactionSignatureError extends Error {
    constructor(){
        super(...arguments);
        this.name = "ValidateTransactionSignatureError";
    }
}
async function validateTransactionSignature(connection, signature, recipient, amount, splToken, reference, finality) {
    var _a, _b;
    const response = await connection.getTransaction(signature, {
        commitment: finality
    });
    if (!response) throw new ValidateTransactionSignatureError("not found");
    if (!response.meta) throw new ValidateTransactionSignatureError("missing meta");
    if (response.meta.err) throw response.meta.err;
    let preAmount, postAmount;
    if (!splToken) {
        const accountIndex = response.transaction.message.accountKeys.findIndex((pubkey)=>pubkey.equals(recipient));
        if (accountIndex === -1) throw new ValidateTransactionSignatureError("recipient not found");
        preAmount = new (0, _bignumberJsDefault.default)(response.meta.preBalances[accountIndex]).div((0, _web3Js.LAMPORTS_PER_SOL));
        postAmount = new (0, _bignumberJsDefault.default)(response.meta.postBalances[accountIndex]).div((0, _web3Js.LAMPORTS_PER_SOL));
    } else {
        const recipientATA = await (0, _splToken.getAssociatedTokenAddress)(splToken, recipient);
        const accountIndex = response.transaction.message.accountKeys.findIndex((pubkey)=>pubkey.equals(recipientATA));
        if (accountIndex === -1) throw new ValidateTransactionSignatureError("recipient not found");
        const preBalance = (_a = response.meta.preTokenBalances) === null || _a === void 0 ? void 0 : _a.find((x)=>x.accountIndex === accountIndex);
        const postBalance = (_b = response.meta.postTokenBalances) === null || _b === void 0 ? void 0 : _b.find((x)=>x.accountIndex === accountIndex);
        preAmount = new (0, _bignumberJsDefault.default)((preBalance === null || preBalance === void 0 ? void 0 : preBalance.uiTokenAmount.uiAmountString) || 0);
        postAmount = new (0, _bignumberJsDefault.default)((postBalance === null || postBalance === void 0 ? void 0 : postBalance.uiTokenAmount.uiAmountString) || 0);
    }
    if (postAmount.minus(preAmount).lt(amount)) throw new ValidateTransactionSignatureError("amount not transferred");
    if (reference) {
        if (!Array.isArray(reference)) reference = [
            reference
        ];
        for (const pubkey of reference){
            if (!response.transaction.message.accountKeys.some((accountKey)=>accountKey.equals(pubkey))) throw new ValidateTransactionSignatureError("reference not found");
        }
    }
    return response;
}

},{"@solana/spl-token":"7lwom","@solana/web3.js":"5JBKN","bignumber.js":"57qkX","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lB7MY":[function(require,module,exports) {
const canPromise = require("da1f68cc1fc16077");
const QRCode = require("8c6cf49ef2287430");
const CanvasRenderer = require("8a60cf7722cc14ce");
const SvgRenderer = require("f6fcc816b915ba37");
function renderCanvas(renderFunc, canvas, text, opts, cb) {
    const args = [].slice.call(arguments, 1);
    const argsNum = args.length;
    const isLastArgCb = typeof args[argsNum - 1] === "function";
    if (!isLastArgCb && !canPromise()) throw new Error("Callback required as last argument");
    if (isLastArgCb) {
        if (argsNum < 2) throw new Error("Too few arguments provided");
        if (argsNum === 2) {
            cb = text;
            text = canvas;
            canvas = opts = undefined;
        } else if (argsNum === 3) {
            if (canvas.getContext && typeof cb === "undefined") {
                cb = opts;
                opts = undefined;
            } else {
                cb = opts;
                opts = text;
                text = canvas;
                canvas = undefined;
            }
        }
    } else {
        if (argsNum < 1) throw new Error("Too few arguments provided");
        if (argsNum === 1) {
            text = canvas;
            canvas = opts = undefined;
        } else if (argsNum === 2 && !canvas.getContext) {
            opts = text;
            text = canvas;
            canvas = undefined;
        }
        return new Promise(function(resolve, reject) {
            try {
                const data = QRCode.create(text, opts);
                resolve(renderFunc(data, canvas, opts));
            } catch (e) {
                reject(e);
            }
        });
    }
    try {
        const data = QRCode.create(text, opts);
        cb(null, renderFunc(data, canvas, opts));
    } catch (e) {
        cb(e);
    }
}
exports.create = QRCode.create;
exports.toCanvas = renderCanvas.bind(null, CanvasRenderer.render);
exports.toDataURL = renderCanvas.bind(null, CanvasRenderer.renderToDataURL);
// only svg for now.
exports.toString = renderCanvas.bind(null, function(data, _, opts) {
    return SvgRenderer.render(data, opts);
});

},{"da1f68cc1fc16077":"9FrZa","8c6cf49ef2287430":"20hbG","8a60cf7722cc14ce":"2oGFV","f6fcc816b915ba37":"7Akrj"}],"9FrZa":[function(require,module,exports) {
// can-promise has a crash in some versions of react native that dont have
// standard global objects
// https://github.com/soldair/node-qrcode/issues/157
module.exports = function() {
    return typeof Promise === "function" && Promise.prototype && Promise.prototype.then;
};

},{}],"20hbG":[function(require,module,exports) {
const Utils = require("4cf6a8173d9f3a2");
const ECLevel = require("2ad62f61c352884c");
const BitBuffer = require("87d5a6270eb1dc26");
const BitMatrix = require("91abc94f777368cc");
const AlignmentPattern = require("9737c3939ab85d95");
const FinderPattern = require("cee3d371e219e45e");
const MaskPattern = require("8700c8c682afabf3");
const ECCode = require("65ad903a6ba3e");
const ReedSolomonEncoder = require("1e8e447afb4d169c");
const Version = require("8a4a19af97836d80");
const FormatInfo = require("26720f9d94c9e268");
const Mode = require("7b6429a248ecc51f");
const Segments = require("1368d0fa14524351");
/**
 * QRCode for JavaScript
 *
 * modified by Ryan Day for nodejs support
 * Copyright (c) 2011 Ryan Day
 *
 * Licensed under the MIT license:
 *   http://www.opensource.org/licenses/mit-license.php
 *
//---------------------------------------------------------------------
// QRCode for JavaScript
//
// Copyright (c) 2009 Kazuhiko Arase
//
// URL: http://www.d-project.com/
//
// Licensed under the MIT license:
//   http://www.opensource.org/licenses/mit-license.php
//
// The word "QR Code" is registered trademark of
// DENSO WAVE INCORPORATED
//   http://www.denso-wave.com/qrcode/faqpatent-e.html
//
//---------------------------------------------------------------------
*/ /**
 * Add finder patterns bits to matrix
 *
 * @param  {BitMatrix} matrix  Modules matrix
 * @param  {Number}    version QR Code version
 */ function setupFinderPattern(matrix, version) {
    const size = matrix.size;
    const pos = FinderPattern.getPositions(version);
    for(let i = 0; i < pos.length; i++){
        const row = pos[i][0];
        const col = pos[i][1];
        for(let r = -1; r <= 7; r++){
            if (row + r <= -1 || size <= row + r) continue;
            for(let c = -1; c <= 7; c++){
                if (col + c <= -1 || size <= col + c) continue;
                if (r >= 0 && r <= 6 && (c === 0 || c === 6) || c >= 0 && c <= 6 && (r === 0 || r === 6) || r >= 2 && r <= 4 && c >= 2 && c <= 4) matrix.set(row + r, col + c, true, true);
                else matrix.set(row + r, col + c, false, true);
            }
        }
    }
}
/**
 * Add timing pattern bits to matrix
 *
 * Note: this function must be called before {@link setupAlignmentPattern}
 *
 * @param  {BitMatrix} matrix Modules matrix
 */ function setupTimingPattern(matrix) {
    const size = matrix.size;
    for(let r = 8; r < size - 8; r++){
        const value = r % 2 === 0;
        matrix.set(r, 6, value, true);
        matrix.set(6, r, value, true);
    }
}
/**
 * Add alignment patterns bits to matrix
 *
 * Note: this function must be called after {@link setupTimingPattern}
 *
 * @param  {BitMatrix} matrix  Modules matrix
 * @param  {Number}    version QR Code version
 */ function setupAlignmentPattern(matrix, version) {
    const pos = AlignmentPattern.getPositions(version);
    for(let i = 0; i < pos.length; i++){
        const row = pos[i][0];
        const col = pos[i][1];
        for(let r = -2; r <= 2; r++){
            for(let c = -2; c <= 2; c++)if (r === -2 || r === 2 || c === -2 || c === 2 || r === 0 && c === 0) matrix.set(row + r, col + c, true, true);
            else matrix.set(row + r, col + c, false, true);
        }
    }
}
/**
 * Add version info bits to matrix
 *
 * @param  {BitMatrix} matrix  Modules matrix
 * @param  {Number}    version QR Code version
 */ function setupVersionInfo(matrix, version) {
    const size = matrix.size;
    const bits = Version.getEncodedBits(version);
    let row, col, mod;
    for(let i = 0; i < 18; i++){
        row = Math.floor(i / 3);
        col = i % 3 + size - 8 - 3;
        mod = (bits >> i & 1) === 1;
        matrix.set(row, col, mod, true);
        matrix.set(col, row, mod, true);
    }
}
/**
 * Add format info bits to matrix
 *
 * @param  {BitMatrix} matrix               Modules matrix
 * @param  {ErrorCorrectionLevel}    errorCorrectionLevel Error correction level
 * @param  {Number}    maskPattern          Mask pattern reference value
 */ function setupFormatInfo(matrix, errorCorrectionLevel, maskPattern) {
    const size = matrix.size;
    const bits = FormatInfo.getEncodedBits(errorCorrectionLevel, maskPattern);
    let i, mod;
    for(i = 0; i < 15; i++){
        mod = (bits >> i & 1) === 1;
        // vertical
        if (i < 6) matrix.set(i, 8, mod, true);
        else if (i < 8) matrix.set(i + 1, 8, mod, true);
        else matrix.set(size - 15 + i, 8, mod, true);
        // horizontal
        if (i < 8) matrix.set(8, size - i - 1, mod, true);
        else if (i < 9) matrix.set(8, 15 - i - 1 + 1, mod, true);
        else matrix.set(8, 15 - i - 1, mod, true);
    }
    // fixed module
    matrix.set(size - 8, 8, 1, true);
}
/**
 * Add encoded data bits to matrix
 *
 * @param  {BitMatrix}  matrix Modules matrix
 * @param  {Uint8Array} data   Data codewords
 */ function setupData(matrix, data) {
    const size = matrix.size;
    let inc = -1;
    let row = size - 1;
    let bitIndex = 7;
    let byteIndex = 0;
    for(let col = size - 1; col > 0; col -= 2){
        if (col === 6) col--;
        while(true){
            for(let c = 0; c < 2; c++)if (!matrix.isReserved(row, col - c)) {
                let dark = false;
                if (byteIndex < data.length) dark = (data[byteIndex] >>> bitIndex & 1) === 1;
                matrix.set(row, col - c, dark);
                bitIndex--;
                if (bitIndex === -1) {
                    byteIndex++;
                    bitIndex = 7;
                }
            }
            row += inc;
            if (row < 0 || size <= row) {
                row -= inc;
                inc = -inc;
                break;
            }
        }
    }
}
/**
 * Create encoded codewords from data input
 *
 * @param  {Number}   version              QR Code version
 * @param  {ErrorCorrectionLevel}   errorCorrectionLevel Error correction level
 * @param  {ByteData} data                 Data input
 * @return {Uint8Array}                    Buffer containing encoded codewords
 */ function createData(version, errorCorrectionLevel, segments) {
    // Prepare data buffer
    const buffer = new BitBuffer();
    segments.forEach(function(data) {
        // prefix data with mode indicator (4 bits)
        buffer.put(data.mode.bit, 4);
        // Prefix data with character count indicator.
        // The character count indicator is a string of bits that represents the
        // number of characters that are being encoded.
        // The character count indicator must be placed after the mode indicator
        // and must be a certain number of bits long, depending on the QR version
        // and data mode
        // @see {@link Mode.getCharCountIndicator}.
        buffer.put(data.getLength(), Mode.getCharCountIndicator(data.mode, version));
        // add binary data sequence to buffer
        data.write(buffer);
    });
    // Calculate required number of bits
    const totalCodewords = Utils.getSymbolTotalCodewords(version);
    const ecTotalCodewords = ECCode.getTotalCodewordsCount(version, errorCorrectionLevel);
    const dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;
    // Add a terminator.
    // If the bit string is shorter than the total number of required bits,
    // a terminator of up to four 0s must be added to the right side of the string.
    // If the bit string is more than four bits shorter than the required number of bits,
    // add four 0s to the end.
    if (buffer.getLengthInBits() + 4 <= dataTotalCodewordsBits) buffer.put(0, 4);
    // If the bit string is fewer than four bits shorter, add only the number of 0s that
    // are needed to reach the required number of bits.
    // After adding the terminator, if the number of bits in the string is not a multiple of 8,
    // pad the string on the right with 0s to make the string's length a multiple of 8.
    while(buffer.getLengthInBits() % 8 !== 0)buffer.putBit(0);
    // Add pad bytes if the string is still shorter than the total number of required bits.
    // Extend the buffer to fill the data capacity of the symbol corresponding to
    // the Version and Error Correction Level by adding the Pad Codewords 11101100 (0xEC)
    // and 00010001 (0x11) alternately.
    const remainingByte = (dataTotalCodewordsBits - buffer.getLengthInBits()) / 8;
    for(let i = 0; i < remainingByte; i++)buffer.put(i % 2 ? 0x11 : 0xEC, 8);
    return createCodewords(buffer, version, errorCorrectionLevel);
}
/**
 * Encode input data with Reed-Solomon and return codewords with
 * relative error correction bits
 *
 * @param  {BitBuffer} bitBuffer            Data to encode
 * @param  {Number}    version              QR Code version
 * @param  {ErrorCorrectionLevel} errorCorrectionLevel Error correction level
 * @return {Uint8Array}                     Buffer containing encoded codewords
 */ function createCodewords(bitBuffer, version, errorCorrectionLevel) {
    // Total codewords for this QR code version (Data + Error correction)
    const totalCodewords = Utils.getSymbolTotalCodewords(version);
    // Total number of error correction codewords
    const ecTotalCodewords = ECCode.getTotalCodewordsCount(version, errorCorrectionLevel);
    // Total number of data codewords
    const dataTotalCodewords = totalCodewords - ecTotalCodewords;
    // Total number of blocks
    const ecTotalBlocks = ECCode.getBlocksCount(version, errorCorrectionLevel);
    // Calculate how many blocks each group should contain
    const blocksInGroup2 = totalCodewords % ecTotalBlocks;
    const blocksInGroup1 = ecTotalBlocks - blocksInGroup2;
    const totalCodewordsInGroup1 = Math.floor(totalCodewords / ecTotalBlocks);
    const dataCodewordsInGroup1 = Math.floor(dataTotalCodewords / ecTotalBlocks);
    const dataCodewordsInGroup2 = dataCodewordsInGroup1 + 1;
    // Number of EC codewords is the same for both groups
    const ecCount = totalCodewordsInGroup1 - dataCodewordsInGroup1;
    // Initialize a Reed-Solomon encoder with a generator polynomial of degree ecCount
    const rs = new ReedSolomonEncoder(ecCount);
    let offset = 0;
    const dcData = new Array(ecTotalBlocks);
    const ecData = new Array(ecTotalBlocks);
    let maxDataSize = 0;
    const buffer = new Uint8Array(bitBuffer.buffer);
    // Divide the buffer into the required number of blocks
    for(let b = 0; b < ecTotalBlocks; b++){
        const dataSize = b < blocksInGroup1 ? dataCodewordsInGroup1 : dataCodewordsInGroup2;
        // extract a block of data from buffer
        dcData[b] = buffer.slice(offset, offset + dataSize);
        // Calculate EC codewords for this data block
        ecData[b] = rs.encode(dcData[b]);
        offset += dataSize;
        maxDataSize = Math.max(maxDataSize, dataSize);
    }
    // Create final data
    // Interleave the data and error correction codewords from each block
    const data = new Uint8Array(totalCodewords);
    let index = 0;
    let i, r;
    // Add data codewords
    for(i = 0; i < maxDataSize; i++){
        for(r = 0; r < ecTotalBlocks; r++)if (i < dcData[r].length) data[index++] = dcData[r][i];
    }
    // Apped EC codewords
    for(i = 0; i < ecCount; i++)for(r = 0; r < ecTotalBlocks; r++)data[index++] = ecData[r][i];
    return data;
}
/**
 * Build QR Code symbol
 *
 * @param  {String} data                 Input string
 * @param  {Number} version              QR Code version
 * @param  {ErrorCorretionLevel} errorCorrectionLevel Error level
 * @param  {MaskPattern} maskPattern     Mask pattern
 * @return {Object}                      Object containing symbol data
 */ function createSymbol(data, version, errorCorrectionLevel, maskPattern) {
    let segments;
    if (Array.isArray(data)) segments = Segments.fromArray(data);
    else if (typeof data === "string") {
        let estimatedVersion = version;
        if (!estimatedVersion) {
            const rawSegments = Segments.rawSplit(data);
            // Estimate best version that can contain raw splitted segments
            estimatedVersion = Version.getBestVersionForData(rawSegments, errorCorrectionLevel);
        }
        // Build optimized segments
        // If estimated version is undefined, try with the highest version
        segments = Segments.fromString(data, estimatedVersion || 40);
    } else throw new Error("Invalid data");
    // Get the min version that can contain data
    const bestVersion = Version.getBestVersionForData(segments, errorCorrectionLevel);
    // If no version is found, data cannot be stored
    if (!bestVersion) throw new Error("The amount of data is too big to be stored in a QR Code");
    // If not specified, use min version as default
    if (!version) version = bestVersion;
    else if (version < bestVersion) throw new Error("\nThe chosen QR Code version cannot contain this amount of data.\nMinimum version required to store current data is: " + bestVersion + ".\n");
    const dataBits = createData(version, errorCorrectionLevel, segments);
    // Allocate matrix buffer
    const moduleCount = Utils.getSymbolSize(version);
    const modules = new BitMatrix(moduleCount);
    // Add function modules
    setupFinderPattern(modules, version);
    setupTimingPattern(modules);
    setupAlignmentPattern(modules, version);
    // Add temporary dummy bits for format info just to set them as reserved.
    // This is needed to prevent these bits from being masked by {@link MaskPattern.applyMask}
    // since the masking operation must be performed only on the encoding region.
    // These blocks will be replaced with correct values later in code.
    setupFormatInfo(modules, errorCorrectionLevel, 0);
    if (version >= 7) setupVersionInfo(modules, version);
    // Add data codewords
    setupData(modules, dataBits);
    if (isNaN(maskPattern)) // Find best mask pattern
    maskPattern = MaskPattern.getBestMask(modules, setupFormatInfo.bind(null, modules, errorCorrectionLevel));
    // Apply mask pattern
    MaskPattern.applyMask(maskPattern, modules);
    // Replace format info bits with correct values
    setupFormatInfo(modules, errorCorrectionLevel, maskPattern);
    return {
        modules: modules,
        version: version,
        errorCorrectionLevel: errorCorrectionLevel,
        maskPattern: maskPattern,
        segments: segments
    };
}
/**
 * QR Code
 *
 * @param {String | Array} data                 Input data
 * @param {Object} options                      Optional configurations
 * @param {Number} options.version              QR Code version
 * @param {String} options.errorCorrectionLevel Error correction level
 * @param {Function} options.toSJISFunc         Helper func to convert utf8 to sjis
 */ exports.create = function create(data, options) {
    if (typeof data === "undefined" || data === "") throw new Error("No input text");
    let errorCorrectionLevel = ECLevel.M;
    let version;
    let mask;
    if (typeof options !== "undefined") {
        // Use higher error correction level as default
        errorCorrectionLevel = ECLevel.from(options.errorCorrectionLevel, ECLevel.M);
        version = Version.from(options.version);
        mask = MaskPattern.from(options.maskPattern);
        if (options.toSJISFunc) Utils.setToSJISFunction(options.toSJISFunc);
    }
    return createSymbol(data, version, errorCorrectionLevel, mask);
};

},{"4cf6a8173d9f3a2":"iXLHI","2ad62f61c352884c":"kbPwo","87d5a6270eb1dc26":"kiPfj","91abc94f777368cc":"fTjkX","9737c3939ab85d95":"1o9KB","cee3d371e219e45e":"dc6Ma","8700c8c682afabf3":"fyimH","65ad903a6ba3e":"5yWYH","1e8e447afb4d169c":"47Qq0","8a4a19af97836d80":"a8ag2","26720f9d94c9e268":"iThdR","7b6429a248ecc51f":"f1e9A","1368d0fa14524351":"4tKki"}],"iXLHI":[function(require,module,exports) {
let toSJISFunction;
const CODEWORDS_COUNT = [
    0,
    26,
    44,
    70,
    100,
    134,
    172,
    196,
    242,
    292,
    346,
    404,
    466,
    532,
    581,
    655,
    733,
    815,
    901,
    991,
    1085,
    1156,
    1258,
    1364,
    1474,
    1588,
    1706,
    1828,
    1921,
    2051,
    2185,
    2323,
    2465,
    2611,
    2761,
    2876,
    3034,
    3196,
    3362,
    3532,
    3706
];
/**
 * Returns the QR Code size for the specified version
 *
 * @param  {Number} version QR Code version
 * @return {Number}         size of QR code
 */ exports.getSymbolSize = function getSymbolSize(version) {
    if (!version) throw new Error('"version" cannot be null or undefined');
    if (version < 1 || version > 40) throw new Error('"version" should be in range from 1 to 40');
    return version * 4 + 17;
};
/**
 * Returns the total number of codewords used to store data and EC information.
 *
 * @param  {Number} version QR Code version
 * @return {Number}         Data length in bits
 */ exports.getSymbolTotalCodewords = function getSymbolTotalCodewords(version) {
    return CODEWORDS_COUNT[version];
};
/**
 * Encode data with Bose-Chaudhuri-Hocquenghem
 *
 * @param  {Number} data Value to encode
 * @return {Number}      Encoded value
 */ exports.getBCHDigit = function(data) {
    let digit = 0;
    while(data !== 0){
        digit++;
        data >>>= 1;
    }
    return digit;
};
exports.setToSJISFunction = function setToSJISFunction(f) {
    if (typeof f !== "function") throw new Error('"toSJISFunc" is not a valid function.');
    toSJISFunction = f;
};
exports.isKanjiModeEnabled = function() {
    return typeof toSJISFunction !== "undefined";
};
exports.toSJIS = function toSJIS(kanji) {
    return toSJISFunction(kanji);
};

},{}],"kbPwo":[function(require,module,exports) {
exports.L = {
    bit: 1
};
exports.M = {
    bit: 0
};
exports.Q = {
    bit: 3
};
exports.H = {
    bit: 2
};
function fromString(string) {
    if (typeof string !== "string") throw new Error("Param is not a string");
    const lcStr = string.toLowerCase();
    switch(lcStr){
        case "l":
        case "low":
            return exports.L;
        case "m":
        case "medium":
            return exports.M;
        case "q":
        case "quartile":
            return exports.Q;
        case "h":
        case "high":
            return exports.H;
        default:
            throw new Error("Unknown EC Level: " + string);
    }
}
exports.isValid = function isValid(level) {
    return level && typeof level.bit !== "undefined" && level.bit >= 0 && level.bit < 4;
};
exports.from = function from(value, defaultValue) {
    if (exports.isValid(value)) return value;
    try {
        return fromString(value);
    } catch (e) {
        return defaultValue;
    }
};

},{}],"kiPfj":[function(require,module,exports) {
function BitBuffer() {
    this.buffer = [];
    this.length = 0;
}
BitBuffer.prototype = {
    get: function(index) {
        const bufIndex = Math.floor(index / 8);
        return (this.buffer[bufIndex] >>> 7 - index % 8 & 1) === 1;
    },
    put: function(num, length) {
        for(let i = 0; i < length; i++)this.putBit((num >>> length - i - 1 & 1) === 1);
    },
    getLengthInBits: function() {
        return this.length;
    },
    putBit: function(bit) {
        const bufIndex = Math.floor(this.length / 8);
        if (this.buffer.length <= bufIndex) this.buffer.push(0);
        if (bit) this.buffer[bufIndex] |= 0x80 >>> this.length % 8;
        this.length++;
    }
};
module.exports = BitBuffer;

},{}],"fTjkX":[function(require,module,exports) {
/**
 * Helper class to handle QR Code symbol modules
 *
 * @param {Number} size Symbol size
 */ function BitMatrix(size) {
    if (!size || size < 1) throw new Error("BitMatrix size must be defined and greater than 0");
    this.size = size;
    this.data = new Uint8Array(size * size);
    this.reservedBit = new Uint8Array(size * size);
}
/**
 * Set bit value at specified location
 * If reserved flag is set, this bit will be ignored during masking process
 *
 * @param {Number}  row
 * @param {Number}  col
 * @param {Boolean} value
 * @param {Boolean} reserved
 */ BitMatrix.prototype.set = function(row, col, value, reserved) {
    const index = row * this.size + col;
    this.data[index] = value;
    if (reserved) this.reservedBit[index] = true;
};
/**
 * Returns bit value at specified location
 *
 * @param  {Number}  row
 * @param  {Number}  col
 * @return {Boolean}
 */ BitMatrix.prototype.get = function(row, col) {
    return this.data[row * this.size + col];
};
/**
 * Applies xor operator at specified location
 * (used during masking process)
 *
 * @param {Number}  row
 * @param {Number}  col
 * @param {Boolean} value
 */ BitMatrix.prototype.xor = function(row, col, value) {
    this.data[row * this.size + col] ^= value;
};
/**
 * Check if bit at specified location is reserved
 *
 * @param {Number}   row
 * @param {Number}   col
 * @return {Boolean}
 */ BitMatrix.prototype.isReserved = function(row, col) {
    return this.reservedBit[row * this.size + col];
};
module.exports = BitMatrix;

},{}],"1o9KB":[function(require,module,exports) {
/**
 * Alignment pattern are fixed reference pattern in defined positions
 * in a matrix symbology, which enables the decode software to re-synchronise
 * the coordinate mapping of the image modules in the event of moderate amounts
 * of distortion of the image.
 *
 * Alignment patterns are present only in QR Code symbols of version 2 or larger
 * and their number depends on the symbol version.
 */ const getSymbolSize = require("3fa093180e62a22a").getSymbolSize;
/**
 * Calculate the row/column coordinates of the center module of each alignment pattern
 * for the specified QR Code version.
 *
 * The alignment patterns are positioned symmetrically on either side of the diagonal
 * running from the top left corner of the symbol to the bottom right corner.
 *
 * Since positions are simmetrical only half of the coordinates are returned.
 * Each item of the array will represent in turn the x and y coordinate.
 * @see {@link getPositions}
 *
 * @param  {Number} version QR Code version
 * @return {Array}          Array of coordinate
 */ exports.getRowColCoords = function getRowColCoords(version) {
    if (version === 1) return [];
    const posCount = Math.floor(version / 7) + 2;
    const size = getSymbolSize(version);
    const intervals = size === 145 ? 26 : Math.ceil((size - 13) / (2 * posCount - 2)) * 2;
    const positions = [
        size - 7
    ] // Last coord is always (size - 7)
    ;
    for(let i = 1; i < posCount - 1; i++)positions[i] = positions[i - 1] - intervals;
    positions.push(6) // First coord is always 6
    ;
    return positions.reverse();
};
/**
 * Returns an array containing the positions of each alignment pattern.
 * Each array's element represent the center point of the pattern as (x, y) coordinates
 *
 * Coordinates are calculated expanding the row/column coordinates returned by {@link getRowColCoords}
 * and filtering out the items that overlaps with finder pattern
 *
 * @example
 * For a Version 7 symbol {@link getRowColCoords} returns values 6, 22 and 38.
 * The alignment patterns, therefore, are to be centered on (row, column)
 * positions (6,22), (22,6), (22,22), (22,38), (38,22), (38,38).
 * Note that the coordinates (6,6), (6,38), (38,6) are occupied by finder patterns
 * and are not therefore used for alignment patterns.
 *
 * let pos = getPositions(7)
 * // [[6,22], [22,6], [22,22], [22,38], [38,22], [38,38]]
 *
 * @param  {Number} version QR Code version
 * @return {Array}          Array of coordinates
 */ exports.getPositions = function getPositions(version) {
    const coords = [];
    const pos = exports.getRowColCoords(version);
    const posLength = pos.length;
    for(let i = 0; i < posLength; i++)for(let j = 0; j < posLength; j++){
        // Skip if position is occupied by finder patterns
        if (i === 0 && j === 0 || // top-left
        i === 0 && j === posLength - 1 || // bottom-left
        i === posLength - 1 && j === 0) continue;
        coords.push([
            pos[i],
            pos[j]
        ]);
    }
    return coords;
};

},{"3fa093180e62a22a":"iXLHI"}],"dc6Ma":[function(require,module,exports) {
const getSymbolSize = require("6ec9ae5660047293").getSymbolSize;
const FINDER_PATTERN_SIZE = 7;
/**
 * Returns an array containing the positions of each finder pattern.
 * Each array's element represent the top-left point of the pattern as (x, y) coordinates
 *
 * @param  {Number} version QR Code version
 * @return {Array}          Array of coordinates
 */ exports.getPositions = function getPositions(version) {
    const size = getSymbolSize(version);
    return [
        // top-left
        [
            0,
            0
        ],
        // top-right
        [
            size - FINDER_PATTERN_SIZE,
            0
        ],
        // bottom-left
        [
            0,
            size - FINDER_PATTERN_SIZE
        ]
    ];
};

},{"6ec9ae5660047293":"iXLHI"}],"fyimH":[function(require,module,exports) {
/**
 * Data mask pattern reference
 * @type {Object}
 */ exports.Patterns = {
    PATTERN000: 0,
    PATTERN001: 1,
    PATTERN010: 2,
    PATTERN011: 3,
    PATTERN100: 4,
    PATTERN101: 5,
    PATTERN110: 6,
    PATTERN111: 7
};
/**
 * Weighted penalty scores for the undesirable features
 * @type {Object}
 */ const PenaltyScores = {
    N1: 3,
    N2: 3,
    N3: 40,
    N4: 10
};
/**
 * Check if mask pattern value is valid
 *
 * @param  {Number}  mask    Mask pattern
 * @return {Boolean}         true if valid, false otherwise
 */ exports.isValid = function isValid(mask) {
    return mask != null && mask !== "" && !isNaN(mask) && mask >= 0 && mask <= 7;
};
/**
 * Returns mask pattern from a value.
 * If value is not valid, returns undefined
 *
 * @param  {Number|String} value        Mask pattern value
 * @return {Number}                     Valid mask pattern or undefined
 */ exports.from = function from(value) {
    return exports.isValid(value) ? parseInt(value, 10) : undefined;
};
/**
* Find adjacent modules in row/column with the same color
* and assign a penalty value.
*
* Points: N1 + i
* i is the amount by which the number of adjacent modules of the same color exceeds 5
*/ exports.getPenaltyN1 = function getPenaltyN1(data) {
    const size = data.size;
    let points = 0;
    let sameCountCol = 0;
    let sameCountRow = 0;
    let lastCol = null;
    let lastRow = null;
    for(let row = 0; row < size; row++){
        sameCountCol = sameCountRow = 0;
        lastCol = lastRow = null;
        for(let col = 0; col < size; col++){
            let module = data.get(row, col);
            if (module === lastCol) sameCountCol++;
            else {
                if (sameCountCol >= 5) points += PenaltyScores.N1 + (sameCountCol - 5);
                lastCol = module;
                sameCountCol = 1;
            }
            module = data.get(col, row);
            if (module === lastRow) sameCountRow++;
            else {
                if (sameCountRow >= 5) points += PenaltyScores.N1 + (sameCountRow - 5);
                lastRow = module;
                sameCountRow = 1;
            }
        }
        if (sameCountCol >= 5) points += PenaltyScores.N1 + (sameCountCol - 5);
        if (sameCountRow >= 5) points += PenaltyScores.N1 + (sameCountRow - 5);
    }
    return points;
};
/**
 * Find 2x2 blocks with the same color and assign a penalty value
 *
 * Points: N2 * (m - 1) * (n - 1)
 */ exports.getPenaltyN2 = function getPenaltyN2(data) {
    const size = data.size;
    let points = 0;
    for(let row = 0; row < size - 1; row++)for(let col = 0; col < size - 1; col++){
        const last = data.get(row, col) + data.get(row, col + 1) + data.get(row + 1, col) + data.get(row + 1, col + 1);
        if (last === 4 || last === 0) points++;
    }
    return points * PenaltyScores.N2;
};
/**
 * Find 1:1:3:1:1 ratio (dark:light:dark:light:dark) pattern in row/column,
 * preceded or followed by light area 4 modules wide
 *
 * Points: N3 * number of pattern found
 */ exports.getPenaltyN3 = function getPenaltyN3(data) {
    const size = data.size;
    let points = 0;
    let bitsCol = 0;
    let bitsRow = 0;
    for(let row = 0; row < size; row++){
        bitsCol = bitsRow = 0;
        for(let col = 0; col < size; col++){
            bitsCol = bitsCol << 1 & 0x7FF | data.get(row, col);
            if (col >= 10 && (bitsCol === 0x5D0 || bitsCol === 0x05D)) points++;
            bitsRow = bitsRow << 1 & 0x7FF | data.get(col, row);
            if (col >= 10 && (bitsRow === 0x5D0 || bitsRow === 0x05D)) points++;
        }
    }
    return points * PenaltyScores.N3;
};
/**
 * Calculate proportion of dark modules in entire symbol
 *
 * Points: N4 * k
 *
 * k is the rating of the deviation of the proportion of dark modules
 * in the symbol from 50% in steps of 5%
 */ exports.getPenaltyN4 = function getPenaltyN4(data) {
    let darkCount = 0;
    const modulesCount = data.data.length;
    for(let i = 0; i < modulesCount; i++)darkCount += data.data[i];
    const k = Math.abs(Math.ceil(darkCount * 100 / modulesCount / 5) - 10);
    return k * PenaltyScores.N4;
};
/**
 * Return mask value at given position
 *
 * @param  {Number} maskPattern Pattern reference value
 * @param  {Number} i           Row
 * @param  {Number} j           Column
 * @return {Boolean}            Mask value
 */ function getMaskAt(maskPattern, i, j) {
    switch(maskPattern){
        case exports.Patterns.PATTERN000:
            return (i + j) % 2 === 0;
        case exports.Patterns.PATTERN001:
            return i % 2 === 0;
        case exports.Patterns.PATTERN010:
            return j % 3 === 0;
        case exports.Patterns.PATTERN011:
            return (i + j) % 3 === 0;
        case exports.Patterns.PATTERN100:
            return (Math.floor(i / 2) + Math.floor(j / 3)) % 2 === 0;
        case exports.Patterns.PATTERN101:
            return i * j % 2 + i * j % 3 === 0;
        case exports.Patterns.PATTERN110:
            return (i * j % 2 + i * j % 3) % 2 === 0;
        case exports.Patterns.PATTERN111:
            return (i * j % 3 + (i + j) % 2) % 2 === 0;
        default:
            throw new Error("bad maskPattern:" + maskPattern);
    }
}
/**
 * Apply a mask pattern to a BitMatrix
 *
 * @param  {Number}    pattern Pattern reference number
 * @param  {BitMatrix} data    BitMatrix data
 */ exports.applyMask = function applyMask(pattern, data) {
    const size = data.size;
    for(let col = 0; col < size; col++)for(let row = 0; row < size; row++){
        if (data.isReserved(row, col)) continue;
        data.xor(row, col, getMaskAt(pattern, row, col));
    }
};
/**
 * Returns the best mask pattern for data
 *
 * @param  {BitMatrix} data
 * @return {Number} Mask pattern reference number
 */ exports.getBestMask = function getBestMask(data, setupFormatFunc) {
    const numPatterns = Object.keys(exports.Patterns).length;
    let bestPattern = 0;
    let lowerPenalty = Infinity;
    for(let p = 0; p < numPatterns; p++){
        setupFormatFunc(p);
        exports.applyMask(p, data);
        // Calculate penalty
        const penalty = exports.getPenaltyN1(data) + exports.getPenaltyN2(data) + exports.getPenaltyN3(data) + exports.getPenaltyN4(data);
        // Undo previously applied mask
        exports.applyMask(p, data);
        if (penalty < lowerPenalty) {
            lowerPenalty = penalty;
            bestPattern = p;
        }
    }
    return bestPattern;
};

},{}],"5yWYH":[function(require,module,exports) {
const ECLevel = require("7baaa530584d1bc4");
const EC_BLOCKS_TABLE = [
    // L  M  Q  H
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    2,
    2,
    1,
    2,
    2,
    4,
    1,
    2,
    4,
    4,
    2,
    4,
    4,
    4,
    2,
    4,
    6,
    5,
    2,
    4,
    6,
    6,
    2,
    5,
    8,
    8,
    4,
    5,
    8,
    8,
    4,
    5,
    8,
    11,
    4,
    8,
    10,
    11,
    4,
    9,
    12,
    16,
    4,
    9,
    16,
    16,
    6,
    10,
    12,
    18,
    6,
    10,
    17,
    16,
    6,
    11,
    16,
    19,
    6,
    13,
    18,
    21,
    7,
    14,
    21,
    25,
    8,
    16,
    20,
    25,
    8,
    17,
    23,
    25,
    9,
    17,
    23,
    34,
    9,
    18,
    25,
    30,
    10,
    20,
    27,
    32,
    12,
    21,
    29,
    35,
    12,
    23,
    34,
    37,
    12,
    25,
    34,
    40,
    13,
    26,
    35,
    42,
    14,
    28,
    38,
    45,
    15,
    29,
    40,
    48,
    16,
    31,
    43,
    51,
    17,
    33,
    45,
    54,
    18,
    35,
    48,
    57,
    19,
    37,
    51,
    60,
    19,
    38,
    53,
    63,
    20,
    40,
    56,
    66,
    21,
    43,
    59,
    70,
    22,
    45,
    62,
    74,
    24,
    47,
    65,
    77,
    25,
    49,
    68,
    81
];
const EC_CODEWORDS_TABLE = [
    // L  M  Q  H
    7,
    10,
    13,
    17,
    10,
    16,
    22,
    28,
    15,
    26,
    36,
    44,
    20,
    36,
    52,
    64,
    26,
    48,
    72,
    88,
    36,
    64,
    96,
    112,
    40,
    72,
    108,
    130,
    48,
    88,
    132,
    156,
    60,
    110,
    160,
    192,
    72,
    130,
    192,
    224,
    80,
    150,
    224,
    264,
    96,
    176,
    260,
    308,
    104,
    198,
    288,
    352,
    120,
    216,
    320,
    384,
    132,
    240,
    360,
    432,
    144,
    280,
    408,
    480,
    168,
    308,
    448,
    532,
    180,
    338,
    504,
    588,
    196,
    364,
    546,
    650,
    224,
    416,
    600,
    700,
    224,
    442,
    644,
    750,
    252,
    476,
    690,
    816,
    270,
    504,
    750,
    900,
    300,
    560,
    810,
    960,
    312,
    588,
    870,
    1050,
    336,
    644,
    952,
    1110,
    360,
    700,
    1020,
    1200,
    390,
    728,
    1050,
    1260,
    420,
    784,
    1140,
    1350,
    450,
    812,
    1200,
    1440,
    480,
    868,
    1290,
    1530,
    510,
    924,
    1350,
    1620,
    540,
    980,
    1440,
    1710,
    570,
    1036,
    1530,
    1800,
    570,
    1064,
    1590,
    1890,
    600,
    1120,
    1680,
    1980,
    630,
    1204,
    1770,
    2100,
    660,
    1260,
    1860,
    2220,
    720,
    1316,
    1950,
    2310,
    750,
    1372,
    2040,
    2430
];
/**
 * Returns the number of error correction block that the QR Code should contain
 * for the specified version and error correction level.
 *
 * @param  {Number} version              QR Code version
 * @param  {Number} errorCorrectionLevel Error correction level
 * @return {Number}                      Number of error correction blocks
 */ exports.getBlocksCount = function getBlocksCount(version, errorCorrectionLevel) {
    switch(errorCorrectionLevel){
        case ECLevel.L:
            return EC_BLOCKS_TABLE[(version - 1) * 4 + 0];
        case ECLevel.M:
            return EC_BLOCKS_TABLE[(version - 1) * 4 + 1];
        case ECLevel.Q:
            return EC_BLOCKS_TABLE[(version - 1) * 4 + 2];
        case ECLevel.H:
            return EC_BLOCKS_TABLE[(version - 1) * 4 + 3];
        default:
            return undefined;
    }
};
/**
 * Returns the number of error correction codewords to use for the specified
 * version and error correction level.
 *
 * @param  {Number} version              QR Code version
 * @param  {Number} errorCorrectionLevel Error correction level
 * @return {Number}                      Number of error correction codewords
 */ exports.getTotalCodewordsCount = function getTotalCodewordsCount(version, errorCorrectionLevel) {
    switch(errorCorrectionLevel){
        case ECLevel.L:
            return EC_CODEWORDS_TABLE[(version - 1) * 4 + 0];
        case ECLevel.M:
            return EC_CODEWORDS_TABLE[(version - 1) * 4 + 1];
        case ECLevel.Q:
            return EC_CODEWORDS_TABLE[(version - 1) * 4 + 2];
        case ECLevel.H:
            return EC_CODEWORDS_TABLE[(version - 1) * 4 + 3];
        default:
            return undefined;
    }
};

},{"7baaa530584d1bc4":"kbPwo"}],"47Qq0":[function(require,module,exports) {
const Polynomial = require("742a7ee6d6a2d145");
function ReedSolomonEncoder(degree) {
    this.genPoly = undefined;
    this.degree = degree;
    if (this.degree) this.initialize(this.degree);
}
/**
 * Initialize the encoder.
 * The input param should correspond to the number of error correction codewords.
 *
 * @param  {Number} degree
 */ ReedSolomonEncoder.prototype.initialize = function initialize(degree) {
    // create an irreducible generator polynomial
    this.degree = degree;
    this.genPoly = Polynomial.generateECPolynomial(this.degree);
};
/**
 * Encodes a chunk of data
 *
 * @param  {Uint8Array} data Buffer containing input data
 * @return {Uint8Array}      Buffer containing encoded data
 */ ReedSolomonEncoder.prototype.encode = function encode(data) {
    if (!this.genPoly) throw new Error("Encoder not initialized");
    // Calculate EC for this data block
    // extends data size to data+genPoly size
    const paddedData = new Uint8Array(data.length + this.degree);
    paddedData.set(data);
    // The error correction codewords are the remainder after dividing the data codewords
    // by a generator polynomial
    const remainder = Polynomial.mod(paddedData, this.genPoly);
    // return EC data blocks (last n byte, where n is the degree of genPoly)
    // If coefficients number in remainder are less than genPoly degree,
    // pad with 0s to the left to reach the needed number of coefficients
    const start = this.degree - remainder.length;
    if (start > 0) {
        const buff = new Uint8Array(this.degree);
        buff.set(remainder, start);
        return buff;
    }
    return remainder;
};
module.exports = ReedSolomonEncoder;

},{"742a7ee6d6a2d145":"dxhHI"}],"dxhHI":[function(require,module,exports) {
const GF = require("780c74029318268c");
/**
 * Multiplies two polynomials inside Galois Field
 *
 * @param  {Uint8Array} p1 Polynomial
 * @param  {Uint8Array} p2 Polynomial
 * @return {Uint8Array}    Product of p1 and p2
 */ exports.mul = function mul(p1, p2) {
    const coeff = new Uint8Array(p1.length + p2.length - 1);
    for(let i = 0; i < p1.length; i++)for(let j = 0; j < p2.length; j++)coeff[i + j] ^= GF.mul(p1[i], p2[j]);
    return coeff;
};
/**
 * Calculate the remainder of polynomials division
 *
 * @param  {Uint8Array} divident Polynomial
 * @param  {Uint8Array} divisor  Polynomial
 * @return {Uint8Array}          Remainder
 */ exports.mod = function mod(divident, divisor) {
    let result = new Uint8Array(divident);
    while(result.length - divisor.length >= 0){
        const coeff = result[0];
        for(let i = 0; i < divisor.length; i++)result[i] ^= GF.mul(divisor[i], coeff);
        // remove all zeros from buffer head
        let offset = 0;
        while(offset < result.length && result[offset] === 0)offset++;
        result = result.slice(offset);
    }
    return result;
};
/**
 * Generate an irreducible generator polynomial of specified degree
 * (used by Reed-Solomon encoder)
 *
 * @param  {Number} degree Degree of the generator polynomial
 * @return {Uint8Array}    Buffer containing polynomial coefficients
 */ exports.generateECPolynomial = function generateECPolynomial(degree) {
    let poly = new Uint8Array([
        1
    ]);
    for(let i = 0; i < degree; i++)poly = exports.mul(poly, new Uint8Array([
        1,
        GF.exp(i)
    ]));
    return poly;
};

},{"780c74029318268c":"2JC5s"}],"2JC5s":[function(require,module,exports) {
const EXP_TABLE = new Uint8Array(512);
const LOG_TABLE = new Uint8Array(256) /**
 * Precompute the log and anti-log tables for faster computation later
 *
 * For each possible value in the galois field 2^8, we will pre-compute
 * the logarithm and anti-logarithm (exponential) of this value
 *
 * ref {@link https://en.wikiversity.org/wiki/Reed%E2%80%93Solomon_codes_for_coders#Introduction_to_mathematical_fields}
 */ ;
(function initTables() {
    let x = 1;
    for(let i = 0; i < 255; i++){
        EXP_TABLE[i] = x;
        LOG_TABLE[x] = i;
        x <<= 1 // multiply by 2
        ;
        // The QR code specification says to use byte-wise modulo 100011101 arithmetic.
        // This means that when a number is 256 or larger, it should be XORed with 0x11D.
        if (x & 0x100) x ^= 0x11D;
    }
    // Optimization: double the size of the anti-log table so that we don't need to mod 255 to
    // stay inside the bounds (because we will mainly use this table for the multiplication of
    // two GF numbers, no more).
    // @see {@link mul}
    for(let i = 255; i < 512; i++)EXP_TABLE[i] = EXP_TABLE[i - 255];
})();
/**
 * Returns log value of n inside Galois Field
 *
 * @param  {Number} n
 * @return {Number}
 */ exports.log = function log(n) {
    if (n < 1) throw new Error("log(" + n + ")");
    return LOG_TABLE[n];
};
/**
 * Returns anti-log value of n inside Galois Field
 *
 * @param  {Number} n
 * @return {Number}
 */ exports.exp = function exp(n) {
    return EXP_TABLE[n];
};
/**
 * Multiplies two number inside Galois Field
 *
 * @param  {Number} x
 * @param  {Number} y
 * @return {Number}
 */ exports.mul = function mul(x, y) {
    if (x === 0 || y === 0) return 0;
    // should be EXP_TABLE[(LOG_TABLE[x] + LOG_TABLE[y]) % 255] if EXP_TABLE wasn't oversized
    // @see {@link initTables}
    return EXP_TABLE[LOG_TABLE[x] + LOG_TABLE[y]];
};

},{}],"a8ag2":[function(require,module,exports) {
const Utils = require("f67b02cdf61cb7c6");
const ECCode = require("777da0d92c463f2e");
const ECLevel = require("acd5b4fcd696edf3");
const Mode = require("5303c314c4a688d7");
const VersionCheck = require("663d0e03da8b2897");
// Generator polynomial used to encode version information
const G18 = 7973;
const G18_BCH = Utils.getBCHDigit(G18);
function getBestVersionForDataLength(mode, length, errorCorrectionLevel) {
    for(let currentVersion = 1; currentVersion <= 40; currentVersion++){
        if (length <= exports.getCapacity(currentVersion, errorCorrectionLevel, mode)) return currentVersion;
    }
    return undefined;
}
function getReservedBitsCount(mode, version) {
    // Character count indicator + mode indicator bits
    return Mode.getCharCountIndicator(mode, version) + 4;
}
function getTotalBitsFromDataArray(segments, version) {
    let totalBits = 0;
    segments.forEach(function(data) {
        const reservedBits = getReservedBitsCount(data.mode, version);
        totalBits += reservedBits + data.getBitsLength();
    });
    return totalBits;
}
function getBestVersionForMixedData(segments, errorCorrectionLevel) {
    for(let currentVersion = 1; currentVersion <= 40; currentVersion++){
        const length = getTotalBitsFromDataArray(segments, currentVersion);
        if (length <= exports.getCapacity(currentVersion, errorCorrectionLevel, Mode.MIXED)) return currentVersion;
    }
    return undefined;
}
/**
 * Returns version number from a value.
 * If value is not a valid version, returns defaultValue
 *
 * @param  {Number|String} value        QR Code version
 * @param  {Number}        defaultValue Fallback value
 * @return {Number}                     QR Code version number
 */ exports.from = function from(value, defaultValue) {
    if (VersionCheck.isValid(value)) return parseInt(value, 10);
    return defaultValue;
};
/**
 * Returns how much data can be stored with the specified QR code version
 * and error correction level
 *
 * @param  {Number} version              QR Code version (1-40)
 * @param  {Number} errorCorrectionLevel Error correction level
 * @param  {Mode}   mode                 Data mode
 * @return {Number}                      Quantity of storable data
 */ exports.getCapacity = function getCapacity(version, errorCorrectionLevel, mode) {
    if (!VersionCheck.isValid(version)) throw new Error("Invalid QR Code version");
    // Use Byte mode as default
    if (typeof mode === "undefined") mode = Mode.BYTE;
    // Total codewords for this QR code version (Data + Error correction)
    const totalCodewords = Utils.getSymbolTotalCodewords(version);
    // Total number of error correction codewords
    const ecTotalCodewords = ECCode.getTotalCodewordsCount(version, errorCorrectionLevel);
    // Total number of data codewords
    const dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;
    if (mode === Mode.MIXED) return dataTotalCodewordsBits;
    const usableBits = dataTotalCodewordsBits - getReservedBitsCount(mode, version);
    // Return max number of storable codewords
    switch(mode){
        case Mode.NUMERIC:
            return Math.floor(usableBits / 10 * 3);
        case Mode.ALPHANUMERIC:
            return Math.floor(usableBits / 11 * 2);
        case Mode.KANJI:
            return Math.floor(usableBits / 13);
        case Mode.BYTE:
        default:
            return Math.floor(usableBits / 8);
    }
};
/**
 * Returns the minimum version needed to contain the amount of data
 *
 * @param  {Segment} data                    Segment of data
 * @param  {Number} [errorCorrectionLevel=H] Error correction level
 * @param  {Mode} mode                       Data mode
 * @return {Number}                          QR Code version
 */ exports.getBestVersionForData = function getBestVersionForData(data, errorCorrectionLevel) {
    let seg;
    const ecl = ECLevel.from(errorCorrectionLevel, ECLevel.M);
    if (Array.isArray(data)) {
        if (data.length > 1) return getBestVersionForMixedData(data, ecl);
        if (data.length === 0) return 1;
        seg = data[0];
    } else seg = data;
    return getBestVersionForDataLength(seg.mode, seg.getLength(), ecl);
};
/**
 * Returns version information with relative error correction bits
 *
 * The version information is included in QR Code symbols of version 7 or larger.
 * It consists of an 18-bit sequence containing 6 data bits,
 * with 12 error correction bits calculated using the (18, 6) Golay code.
 *
 * @param  {Number} version QR Code version
 * @return {Number}         Encoded version info bits
 */ exports.getEncodedBits = function getEncodedBits(version) {
    if (!VersionCheck.isValid(version) || version < 7) throw new Error("Invalid QR Code version");
    let d = version << 12;
    while(Utils.getBCHDigit(d) - G18_BCH >= 0)d ^= G18 << Utils.getBCHDigit(d) - G18_BCH;
    return version << 12 | d;
};

},{"f67b02cdf61cb7c6":"iXLHI","777da0d92c463f2e":"5yWYH","acd5b4fcd696edf3":"kbPwo","5303c314c4a688d7":"f1e9A","663d0e03da8b2897":"enfTX"}],"f1e9A":[function(require,module,exports) {
const VersionCheck = require("488660fac9162579");
const Regex = require("a23fd227d32f3622");
/**
 * Numeric mode encodes data from the decimal digit set (0 - 9)
 * (byte values 30HEX to 39HEX).
 * Normally, 3 data characters are represented by 10 bits.
 *
 * @type {Object}
 */ exports.NUMERIC = {
    id: "Numeric",
    bit: 1,
    ccBits: [
        10,
        12,
        14
    ]
};
/**
 * Alphanumeric mode encodes data from a set of 45 characters,
 * i.e. 10 numeric digits (0 - 9),
 *      26 alphabetic characters (A - Z),
 *   and 9 symbols (SP, $, %, *, +, -, ., /, :).
 * Normally, two input characters are represented by 11 bits.
 *
 * @type {Object}
 */ exports.ALPHANUMERIC = {
    id: "Alphanumeric",
    bit: 2,
    ccBits: [
        9,
        11,
        13
    ]
};
/**
 * In byte mode, data is encoded at 8 bits per character.
 *
 * @type {Object}
 */ exports.BYTE = {
    id: "Byte",
    bit: 4,
    ccBits: [
        8,
        16,
        16
    ]
};
/**
 * The Kanji mode efficiently encodes Kanji characters in accordance with
 * the Shift JIS system based on JIS X 0208.
 * The Shift JIS values are shifted from the JIS X 0208 values.
 * JIS X 0208 gives details of the shift coded representation.
 * Each two-byte character value is compacted to a 13-bit binary codeword.
 *
 * @type {Object}
 */ exports.KANJI = {
    id: "Kanji",
    bit: 8,
    ccBits: [
        8,
        10,
        12
    ]
};
/**
 * Mixed mode will contain a sequences of data in a combination of any of
 * the modes described above
 *
 * @type {Object}
 */ exports.MIXED = {
    bit: -1
};
/**
 * Returns the number of bits needed to store the data length
 * according to QR Code specifications.
 *
 * @param  {Mode}   mode    Data mode
 * @param  {Number} version QR Code version
 * @return {Number}         Number of bits
 */ exports.getCharCountIndicator = function getCharCountIndicator(mode, version) {
    if (!mode.ccBits) throw new Error("Invalid mode: " + mode);
    if (!VersionCheck.isValid(version)) throw new Error("Invalid version: " + version);
    if (version >= 1 && version < 10) return mode.ccBits[0];
    else if (version < 27) return mode.ccBits[1];
    return mode.ccBits[2];
};
/**
 * Returns the most efficient mode to store the specified data
 *
 * @param  {String} dataStr Input data string
 * @return {Mode}           Best mode
 */ exports.getBestModeForData = function getBestModeForData(dataStr) {
    if (Regex.testNumeric(dataStr)) return exports.NUMERIC;
    else if (Regex.testAlphanumeric(dataStr)) return exports.ALPHANUMERIC;
    else if (Regex.testKanji(dataStr)) return exports.KANJI;
    else return exports.BYTE;
};
/**
 * Return mode name as string
 *
 * @param {Mode} mode Mode object
 * @returns {String}  Mode name
 */ exports.toString = function toString(mode) {
    if (mode && mode.id) return mode.id;
    throw new Error("Invalid mode");
};
/**
 * Check if input param is a valid mode object
 *
 * @param   {Mode}    mode Mode object
 * @returns {Boolean} True if valid mode, false otherwise
 */ exports.isValid = function isValid(mode) {
    return mode && mode.bit && mode.ccBits;
};
/**
 * Get mode object from its name
 *
 * @param   {String} string Mode name
 * @returns {Mode}          Mode object
 */ function fromString(string) {
    if (typeof string !== "string") throw new Error("Param is not a string");
    const lcStr = string.toLowerCase();
    switch(lcStr){
        case "numeric":
            return exports.NUMERIC;
        case "alphanumeric":
            return exports.ALPHANUMERIC;
        case "kanji":
            return exports.KANJI;
        case "byte":
            return exports.BYTE;
        default:
            throw new Error("Unknown mode: " + string);
    }
}
/**
 * Returns mode from a value.
 * If value is not a valid mode, returns defaultValue
 *
 * @param  {Mode|String} value        Encoding mode
 * @param  {Mode}        defaultValue Fallback value
 * @return {Mode}                     Encoding mode
 */ exports.from = function from(value, defaultValue) {
    if (exports.isValid(value)) return value;
    try {
        return fromString(value);
    } catch (e) {
        return defaultValue;
    }
};

},{"488660fac9162579":"enfTX","a23fd227d32f3622":"3Bqru"}],"enfTX":[function(require,module,exports) {
/**
 * Check if QR Code version is valid
 *
 * @param  {Number}  version QR Code version
 * @return {Boolean}         true if valid version, false otherwise
 */ exports.isValid = function isValid(version) {
    return !isNaN(version) && version >= 1 && version <= 40;
};

},{}],"3Bqru":[function(require,module,exports) {
const numeric = "[0-9]+";
const alphanumeric = "[A-Z $%*+\\-./:]+";
let kanji = "(?:[u3000-u303F]|[u3040-u309F]|[u30A0-u30FF]|[uFF00-uFFEF]|[u4E00-u9FAF]|[u2605-u2606]|[u2190-u2195]|u203B|[u2010u2015u2018u2019u2025u2026u201Cu201Du2225u2260]|[u0391-u0451]|[u00A7u00A8u00B1u00B4u00D7u00F7])+";
kanji = kanji.replace(/u/g, "\\u");
const byte = "(?:(?![A-Z0-9 $%*+\\-./:]|" + kanji + ")(?:.|[\r\n]))+";
exports.KANJI = new RegExp(kanji, "g");
exports.BYTE_KANJI = new RegExp("[^A-Z0-9 $%*+\\-./:]+", "g");
exports.BYTE = new RegExp(byte, "g");
exports.NUMERIC = new RegExp(numeric, "g");
exports.ALPHANUMERIC = new RegExp(alphanumeric, "g");
const TEST_KANJI = new RegExp("^" + kanji + "$");
const TEST_NUMERIC = new RegExp("^" + numeric + "$");
const TEST_ALPHANUMERIC = new RegExp("^[A-Z0-9 $%*+\\-./:]+$");
exports.testKanji = function testKanji(str) {
    return TEST_KANJI.test(str);
};
exports.testNumeric = function testNumeric(str) {
    return TEST_NUMERIC.test(str);
};
exports.testAlphanumeric = function testAlphanumeric(str) {
    return TEST_ALPHANUMERIC.test(str);
};

},{}],"iThdR":[function(require,module,exports) {
const Utils = require("eeca831a42e85d6c");
const G15 = 1335;
const G15_MASK = 21522;
const G15_BCH = Utils.getBCHDigit(G15);
/**
 * Returns format information with relative error correction bits
 *
 * The format information is a 15-bit sequence containing 5 data bits,
 * with 10 error correction bits calculated using the (15, 5) BCH code.
 *
 * @param  {Number} errorCorrectionLevel Error correction level
 * @param  {Number} mask                 Mask pattern
 * @return {Number}                      Encoded format information bits
 */ exports.getEncodedBits = function getEncodedBits(errorCorrectionLevel, mask) {
    const data = errorCorrectionLevel.bit << 3 | mask;
    let d = data << 10;
    while(Utils.getBCHDigit(d) - G15_BCH >= 0)d ^= G15 << Utils.getBCHDigit(d) - G15_BCH;
    // xor final data with mask pattern in order to ensure that
    // no combination of Error Correction Level and data mask pattern
    // will result in an all-zero data string
    return (data << 10 | d) ^ G15_MASK;
};

},{"eeca831a42e85d6c":"iXLHI"}],"4tKki":[function(require,module,exports) {
const Mode = require("45f6d4bff9d2fc72");
const NumericData = require("73109cbf4f3c309d");
const AlphanumericData = require("5320016e34c30467");
const ByteData = require("fd16f8f25b581951");
const KanjiData = require("8a7b84039f1cf0d2");
const Regex = require("79379a3a8f3c26bb");
const Utils = require("66903ca51bd2ea1d");
const dijkstra = require("3b9f47d541e7d71f");
/**
 * Returns UTF8 byte length
 *
 * @param  {String} str Input string
 * @return {Number}     Number of byte
 */ function getStringByteLength(str) {
    return unescape(encodeURIComponent(str)).length;
}
/**
 * Get a list of segments of the specified mode
 * from a string
 *
 * @param  {Mode}   mode Segment mode
 * @param  {String} str  String to process
 * @return {Array}       Array of object with segments data
 */ function getSegments(regex, mode, str) {
    const segments = [];
    let result;
    while((result = regex.exec(str)) !== null)segments.push({
        data: result[0],
        index: result.index,
        mode: mode,
        length: result[0].length
    });
    return segments;
}
/**
 * Extracts a series of segments with the appropriate
 * modes from a string
 *
 * @param  {String} dataStr Input string
 * @return {Array}          Array of object with segments data
 */ function getSegmentsFromString(dataStr) {
    const numSegs = getSegments(Regex.NUMERIC, Mode.NUMERIC, dataStr);
    const alphaNumSegs = getSegments(Regex.ALPHANUMERIC, Mode.ALPHANUMERIC, dataStr);
    let byteSegs;
    let kanjiSegs;
    if (Utils.isKanjiModeEnabled()) {
        byteSegs = getSegments(Regex.BYTE, Mode.BYTE, dataStr);
        kanjiSegs = getSegments(Regex.KANJI, Mode.KANJI, dataStr);
    } else {
        byteSegs = getSegments(Regex.BYTE_KANJI, Mode.BYTE, dataStr);
        kanjiSegs = [];
    }
    const segs = numSegs.concat(alphaNumSegs, byteSegs, kanjiSegs);
    return segs.sort(function(s1, s2) {
        return s1.index - s2.index;
    }).map(function(obj) {
        return {
            data: obj.data,
            mode: obj.mode,
            length: obj.length
        };
    });
}
/**
 * Returns how many bits are needed to encode a string of
 * specified length with the specified mode
 *
 * @param  {Number} length String length
 * @param  {Mode} mode     Segment mode
 * @return {Number}        Bit length
 */ function getSegmentBitsLength(length, mode) {
    switch(mode){
        case Mode.NUMERIC:
            return NumericData.getBitsLength(length);
        case Mode.ALPHANUMERIC:
            return AlphanumericData.getBitsLength(length);
        case Mode.KANJI:
            return KanjiData.getBitsLength(length);
        case Mode.BYTE:
            return ByteData.getBitsLength(length);
    }
}
/**
 * Merges adjacent segments which have the same mode
 *
 * @param  {Array} segs Array of object with segments data
 * @return {Array}      Array of object with segments data
 */ function mergeSegments(segs) {
    return segs.reduce(function(acc, curr) {
        const prevSeg = acc.length - 1 >= 0 ? acc[acc.length - 1] : null;
        if (prevSeg && prevSeg.mode === curr.mode) {
            acc[acc.length - 1].data += curr.data;
            return acc;
        }
        acc.push(curr);
        return acc;
    }, []);
}
/**
 * Generates a list of all possible nodes combination which
 * will be used to build a segments graph.
 *
 * Nodes are divided by groups. Each group will contain a list of all the modes
 * in which is possible to encode the given text.
 *
 * For example the text '12345' can be encoded as Numeric, Alphanumeric or Byte.
 * The group for '12345' will contain then 3 objects, one for each
 * possible encoding mode.
 *
 * Each node represents a possible segment.
 *
 * @param  {Array} segs Array of object with segments data
 * @return {Array}      Array of object with segments data
 */ function buildNodes(segs) {
    const nodes = [];
    for(let i = 0; i < segs.length; i++){
        const seg = segs[i];
        switch(seg.mode){
            case Mode.NUMERIC:
                nodes.push([
                    seg,
                    {
                        data: seg.data,
                        mode: Mode.ALPHANUMERIC,
                        length: seg.length
                    },
                    {
                        data: seg.data,
                        mode: Mode.BYTE,
                        length: seg.length
                    }
                ]);
                break;
            case Mode.ALPHANUMERIC:
                nodes.push([
                    seg,
                    {
                        data: seg.data,
                        mode: Mode.BYTE,
                        length: seg.length
                    }
                ]);
                break;
            case Mode.KANJI:
                nodes.push([
                    seg,
                    {
                        data: seg.data,
                        mode: Mode.BYTE,
                        length: getStringByteLength(seg.data)
                    }
                ]);
                break;
            case Mode.BYTE:
                nodes.push([
                    {
                        data: seg.data,
                        mode: Mode.BYTE,
                        length: getStringByteLength(seg.data)
                    }
                ]);
        }
    }
    return nodes;
}
/**
 * Builds a graph from a list of nodes.
 * All segments in each node group will be connected with all the segments of
 * the next group and so on.
 *
 * At each connection will be assigned a weight depending on the
 * segment's byte length.
 *
 * @param  {Array} nodes    Array of object with segments data
 * @param  {Number} version QR Code version
 * @return {Object}         Graph of all possible segments
 */ function buildGraph(nodes, version) {
    const table = {};
    const graph = {
        start: {}
    };
    let prevNodeIds = [
        "start"
    ];
    for(let i = 0; i < nodes.length; i++){
        const nodeGroup = nodes[i];
        const currentNodeIds = [];
        for(let j = 0; j < nodeGroup.length; j++){
            const node = nodeGroup[j];
            const key = "" + i + j;
            currentNodeIds.push(key);
            table[key] = {
                node: node,
                lastCount: 0
            };
            graph[key] = {};
            for(let n = 0; n < prevNodeIds.length; n++){
                const prevNodeId = prevNodeIds[n];
                if (table[prevNodeId] && table[prevNodeId].node.mode === node.mode) {
                    graph[prevNodeId][key] = getSegmentBitsLength(table[prevNodeId].lastCount + node.length, node.mode) - getSegmentBitsLength(table[prevNodeId].lastCount, node.mode);
                    table[prevNodeId].lastCount += node.length;
                } else {
                    if (table[prevNodeId]) table[prevNodeId].lastCount = node.length;
                    graph[prevNodeId][key] = getSegmentBitsLength(node.length, node.mode) + 4 + Mode.getCharCountIndicator(node.mode, version) // switch cost
                    ;
                }
            }
        }
        prevNodeIds = currentNodeIds;
    }
    for(let n = 0; n < prevNodeIds.length; n++)graph[prevNodeIds[n]].end = 0;
    return {
        map: graph,
        table: table
    };
}
/**
 * Builds a segment from a specified data and mode.
 * If a mode is not specified, the more suitable will be used.
 *
 * @param  {String} data             Input data
 * @param  {Mode | String} modesHint Data mode
 * @return {Segment}                 Segment
 */ function buildSingleSegment(data, modesHint) {
    let mode;
    const bestMode = Mode.getBestModeForData(data);
    mode = Mode.from(modesHint, bestMode);
    // Make sure data can be encoded
    if (mode !== Mode.BYTE && mode.bit < bestMode.bit) throw new Error('"' + data + '"' + " cannot be encoded with mode " + Mode.toString(mode) + ".\n Suggested mode is: " + Mode.toString(bestMode));
    // Use Mode.BYTE if Kanji support is disabled
    if (mode === Mode.KANJI && !Utils.isKanjiModeEnabled()) mode = Mode.BYTE;
    switch(mode){
        case Mode.NUMERIC:
            return new NumericData(data);
        case Mode.ALPHANUMERIC:
            return new AlphanumericData(data);
        case Mode.KANJI:
            return new KanjiData(data);
        case Mode.BYTE:
            return new ByteData(data);
    }
}
/**
 * Builds a list of segments from an array.
 * Array can contain Strings or Objects with segment's info.
 *
 * For each item which is a string, will be generated a segment with the given
 * string and the more appropriate encoding mode.
 *
 * For each item which is an object, will be generated a segment with the given
 * data and mode.
 * Objects must contain at least the property "data".
 * If property "mode" is not present, the more suitable mode will be used.
 *
 * @param  {Array} array Array of objects with segments data
 * @return {Array}       Array of Segments
 */ exports.fromArray = function fromArray(array) {
    return array.reduce(function(acc, seg) {
        if (typeof seg === "string") acc.push(buildSingleSegment(seg, null));
        else if (seg.data) acc.push(buildSingleSegment(seg.data, seg.mode));
        return acc;
    }, []);
};
/**
 * Builds an optimized sequence of segments from a string,
 * which will produce the shortest possible bitstream.
 *
 * @param  {String} data    Input string
 * @param  {Number} version QR Code version
 * @return {Array}          Array of segments
 */ exports.fromString = function fromString(data, version) {
    const segs = getSegmentsFromString(data, Utils.isKanjiModeEnabled());
    const nodes = buildNodes(segs);
    const graph = buildGraph(nodes, version);
    const path = dijkstra.find_path(graph.map, "start", "end");
    const optimizedSegs = [];
    for(let i = 1; i < path.length - 1; i++)optimizedSegs.push(graph.table[path[i]].node);
    return exports.fromArray(mergeSegments(optimizedSegs));
};
/**
 * Splits a string in various segments with the modes which
 * best represent their content.
 * The produced segments are far from being optimized.
 * The output of this function is only used to estimate a QR Code version
 * which may contain the data.
 *
 * @param  {string} data Input string
 * @return {Array}       Array of segments
 */ exports.rawSplit = function rawSplit(data) {
    return exports.fromArray(getSegmentsFromString(data, Utils.isKanjiModeEnabled()));
};

},{"45f6d4bff9d2fc72":"f1e9A","73109cbf4f3c309d":"c44F8","5320016e34c30467":"cdBOf","fd16f8f25b581951":"ediQ9","8a7b84039f1cf0d2":"gphIw","79379a3a8f3c26bb":"3Bqru","66903ca51bd2ea1d":"iXLHI","3b9f47d541e7d71f":"lDJz9"}],"c44F8":[function(require,module,exports) {
const Mode = require("29134b0b0820b091");
function NumericData(data) {
    this.mode = Mode.NUMERIC;
    this.data = data.toString();
}
NumericData.getBitsLength = function getBitsLength(length) {
    return 10 * Math.floor(length / 3) + (length % 3 ? length % 3 * 3 + 1 : 0);
};
NumericData.prototype.getLength = function getLength() {
    return this.data.length;
};
NumericData.prototype.getBitsLength = function getBitsLength() {
    return NumericData.getBitsLength(this.data.length);
};
NumericData.prototype.write = function write(bitBuffer) {
    let i, group, value;
    // The input data string is divided into groups of three digits,
    // and each group is converted to its 10-bit binary equivalent.
    for(i = 0; i + 3 <= this.data.length; i += 3){
        group = this.data.substr(i, 3);
        value = parseInt(group, 10);
        bitBuffer.put(value, 10);
    }
    // If the number of input digits is not an exact multiple of three,
    // the final one or two digits are converted to 4 or 7 bits respectively.
    const remainingNum = this.data.length - i;
    if (remainingNum > 0) {
        group = this.data.substr(i);
        value = parseInt(group, 10);
        bitBuffer.put(value, remainingNum * 3 + 1);
    }
};
module.exports = NumericData;

},{"29134b0b0820b091":"f1e9A"}],"cdBOf":[function(require,module,exports) {
const Mode = require("9c7c9b869570f846");
/**
 * Array of characters available in alphanumeric mode
 *
 * As per QR Code specification, to each character
 * is assigned a value from 0 to 44 which in this case coincides
 * with the array index
 *
 * @type {Array}
 */ const ALPHA_NUM_CHARS = [
    "0",
    "1",
    "2",
    "3",
    "4",
    "5",
    "6",
    "7",
    "8",
    "9",
    "A",
    "B",
    "C",
    "D",
    "E",
    "F",
    "G",
    "H",
    "I",
    "J",
    "K",
    "L",
    "M",
    "N",
    "O",
    "P",
    "Q",
    "R",
    "S",
    "T",
    "U",
    "V",
    "W",
    "X",
    "Y",
    "Z",
    " ",
    "$",
    "%",
    "*",
    "+",
    "-",
    ".",
    "/",
    ":"
];
function AlphanumericData(data) {
    this.mode = Mode.ALPHANUMERIC;
    this.data = data;
}
AlphanumericData.getBitsLength = function getBitsLength(length) {
    return 11 * Math.floor(length / 2) + 6 * (length % 2);
};
AlphanumericData.prototype.getLength = function getLength() {
    return this.data.length;
};
AlphanumericData.prototype.getBitsLength = function getBitsLength() {
    return AlphanumericData.getBitsLength(this.data.length);
};
AlphanumericData.prototype.write = function write(bitBuffer) {
    let i;
    // Input data characters are divided into groups of two characters
    // and encoded as 11-bit binary codes.
    for(i = 0; i + 2 <= this.data.length; i += 2){
        // The character value of the first character is multiplied by 45
        let value = ALPHA_NUM_CHARS.indexOf(this.data[i]) * 45;
        // The character value of the second digit is added to the product
        value += ALPHA_NUM_CHARS.indexOf(this.data[i + 1]);
        // The sum is then stored as 11-bit binary number
        bitBuffer.put(value, 11);
    }
    // If the number of input data characters is not a multiple of two,
    // the character value of the final character is encoded as a 6-bit binary number.
    if (this.data.length % 2) bitBuffer.put(ALPHA_NUM_CHARS.indexOf(this.data[i]), 6);
};
module.exports = AlphanumericData;

},{"9c7c9b869570f846":"f1e9A"}],"ediQ9":[function(require,module,exports) {
const Mode = require("a20a51f6cd184253");
function ByteData(data) {
    this.mode = Mode.BYTE;
    if (typeof data === "string") this.data = new TextEncoder().encode(data);
    else this.data = new Uint8Array(data);
}
ByteData.getBitsLength = function getBitsLength(length) {
    return length * 8;
};
ByteData.prototype.getLength = function getLength() {
    return this.data.length;
};
ByteData.prototype.getBitsLength = function getBitsLength() {
    return ByteData.getBitsLength(this.data.length);
};
ByteData.prototype.write = function(bitBuffer) {
    for(let i = 0, l = this.data.length; i < l; i++)bitBuffer.put(this.data[i], 8);
};
module.exports = ByteData;

},{"a20a51f6cd184253":"f1e9A"}],"gphIw":[function(require,module,exports) {
const Mode = require("b935cfd1cd03a1f6");
const Utils = require("ca4944585cc8d12d");
function KanjiData(data) {
    this.mode = Mode.KANJI;
    this.data = data;
}
KanjiData.getBitsLength = function getBitsLength(length) {
    return length * 13;
};
KanjiData.prototype.getLength = function getLength() {
    return this.data.length;
};
KanjiData.prototype.getBitsLength = function getBitsLength() {
    return KanjiData.getBitsLength(this.data.length);
};
KanjiData.prototype.write = function(bitBuffer) {
    let i;
    // In the Shift JIS system, Kanji characters are represented by a two byte combination.
    // These byte values are shifted from the JIS X 0208 values.
    // JIS X 0208 gives details of the shift coded representation.
    for(i = 0; i < this.data.length; i++){
        let value = Utils.toSJIS(this.data[i]);
        // For characters with Shift JIS values from 0x8140 to 0x9FFC:
        if (value >= 0x8140 && value <= 0x9FFC) // Subtract 0x8140 from Shift JIS value
        value -= 0x8140;
        else if (value >= 0xE040 && value <= 0xEBBF) // Subtract 0xC140 from Shift JIS value
        value -= 0xC140;
        else throw new Error("Invalid SJIS character: " + this.data[i] + "\n" + "Make sure your charset is UTF-8");
        // Multiply most significant byte of result by 0xC0
        // and add least significant byte to product
        value = (value >>> 8 & 0xff) * 0xC0 + (value & 0xff);
        // Convert result to a 13-bit binary string
        bitBuffer.put(value, 13);
    }
};
module.exports = KanjiData;

},{"b935cfd1cd03a1f6":"f1e9A","ca4944585cc8d12d":"iXLHI"}],"lDJz9":[function(require,module,exports) {
"use strict";
/******************************************************************************
 * Created 2008-08-19.
 *
 * Dijkstra path-finding functions. Adapted from the Dijkstar Python project.
 *
 * Copyright (C) 2008
 *   Wyatt Baldwin <self@wyattbaldwin.com>
 *   All rights reserved
 *
 * Licensed under the MIT license.
 *
 *   http://www.opensource.org/licenses/mit-license.php
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *****************************************************************************/ var dijkstra = {
    single_source_shortest_paths: function(graph, s, d) {
        // Predecessor map for each node that has been encountered.
        // node ID => predecessor node ID
        var predecessors = {};
        // Costs of shortest paths from s to all nodes encountered.
        // node ID => cost
        var costs = {};
        costs[s] = 0;
        // Costs of shortest paths from s to all nodes encountered; differs from
        // `costs` in that it provides easy access to the node that currently has
        // the known shortest path from s.
        // XXX: Do we actually need both `costs` and `open`?
        var open = dijkstra.PriorityQueue.make();
        open.push(s, 0);
        var closest, u, v, cost_of_s_to_u, adjacent_nodes, cost_of_e, cost_of_s_to_u_plus_cost_of_e, cost_of_s_to_v, first_visit;
        while(!open.empty()){
            // In the nodes remaining in graph that have a known cost from s,
            // find the node, u, that currently has the shortest path from s.
            closest = open.pop();
            u = closest.value;
            cost_of_s_to_u = closest.cost;
            // Get nodes adjacent to u...
            adjacent_nodes = graph[u] || {};
            // ...and explore the edges that connect u to those nodes, updating
            // the cost of the shortest paths to any or all of those nodes as
            // necessary. v is the node across the current edge from u.
            for(v in adjacent_nodes)if (adjacent_nodes.hasOwnProperty(v)) {
                // Get the cost of the edge running from u to v.
                cost_of_e = adjacent_nodes[v];
                // Cost of s to u plus the cost of u to v across e--this is *a*
                // cost from s to v that may or may not be less than the current
                // known cost to v.
                cost_of_s_to_u_plus_cost_of_e = cost_of_s_to_u + cost_of_e;
                // If we haven't visited v yet OR if the current known cost from s to
                // v is greater than the new cost we just found (cost of s to u plus
                // cost of u to v across e), update v's cost in the cost list and
                // update v's predecessor in the predecessor list (it's now u).
                cost_of_s_to_v = costs[v];
                first_visit = typeof costs[v] === "undefined";
                if (first_visit || cost_of_s_to_v > cost_of_s_to_u_plus_cost_of_e) {
                    costs[v] = cost_of_s_to_u_plus_cost_of_e;
                    open.push(v, cost_of_s_to_u_plus_cost_of_e);
                    predecessors[v] = u;
                }
            }
        }
        if (typeof d !== "undefined" && typeof costs[d] === "undefined") {
            var msg = [
                "Could not find a path from ",
                s,
                " to ",
                d,
                "."
            ].join("");
            throw new Error(msg);
        }
        return predecessors;
    },
    extract_shortest_path_from_predecessor_list: function(predecessors, d) {
        var nodes = [];
        var u = d;
        var predecessor;
        while(u){
            nodes.push(u);
            predecessor = predecessors[u];
            u = predecessors[u];
        }
        nodes.reverse();
        return nodes;
    },
    find_path: function(graph, s, d) {
        var predecessors = dijkstra.single_source_shortest_paths(graph, s, d);
        return dijkstra.extract_shortest_path_from_predecessor_list(predecessors, d);
    },
    /**
   * A very naive priority queue implementation.
   */ PriorityQueue: {
        make: function(opts) {
            var T = dijkstra.PriorityQueue, t = {}, key;
            opts = opts || {};
            for(key in T)if (T.hasOwnProperty(key)) t[key] = T[key];
            t.queue = [];
            t.sorter = opts.sorter || T.default_sorter;
            return t;
        },
        default_sorter: function(a, b) {
            return a.cost - b.cost;
        },
        /**
     * Add a new item to the queue and ensure the highest priority element
     * is at the front of the queue.
     */ push: function(value, cost) {
            var item = {
                value: value,
                cost: cost
            };
            this.queue.push(item);
            this.queue.sort(this.sorter);
        },
        /**
     * Return the highest priority element in the queue.
     */ pop: function() {
            return this.queue.shift();
        },
        empty: function() {
            return this.queue.length === 0;
        }
    }
};
module.exports = dijkstra;

},{}],"2oGFV":[function(require,module,exports) {
const Utils = require("5b3f7c513802d6c7");
function clearCanvas(ctx, canvas, size) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    if (!canvas.style) canvas.style = {};
    canvas.height = size;
    canvas.width = size;
    canvas.style.height = size + "px";
    canvas.style.width = size + "px";
}
function getCanvasElement() {
    try {
        return document.createElement("canvas");
    } catch (e) {
        throw new Error("You need to specify a canvas element");
    }
}
exports.render = function render(qrData, canvas, options) {
    let opts = options;
    let canvasEl = canvas;
    if (typeof opts === "undefined" && (!canvas || !canvas.getContext)) {
        opts = canvas;
        canvas = undefined;
    }
    if (!canvas) canvasEl = getCanvasElement();
    opts = Utils.getOptions(opts);
    const size = Utils.getImageWidth(qrData.modules.size, opts);
    const ctx = canvasEl.getContext("2d");
    const image = ctx.createImageData(size, size);
    Utils.qrToImageData(image.data, qrData, opts);
    clearCanvas(ctx, canvasEl, size);
    ctx.putImageData(image, 0, 0);
    return canvasEl;
};
exports.renderToDataURL = function renderToDataURL(qrData, canvas, options) {
    let opts = options;
    if (typeof opts === "undefined" && (!canvas || !canvas.getContext)) {
        opts = canvas;
        canvas = undefined;
    }
    if (!opts) opts = {};
    const canvasEl = exports.render(qrData, canvas, opts);
    const type = opts.type || "image/png";
    const rendererOpts = opts.rendererOpts || {};
    return canvasEl.toDataURL(type, rendererOpts.quality);
};

},{"5b3f7c513802d6c7":"6rMWz"}],"6rMWz":[function(require,module,exports) {
function hex2rgba(hex) {
    if (typeof hex === "number") hex = hex.toString();
    if (typeof hex !== "string") throw new Error("Color should be defined as hex string");
    let hexCode = hex.slice().replace("#", "").split("");
    if (hexCode.length < 3 || hexCode.length === 5 || hexCode.length > 8) throw new Error("Invalid hex color: " + hex);
    // Convert from short to long form (fff -> ffffff)
    if (hexCode.length === 3 || hexCode.length === 4) hexCode = Array.prototype.concat.apply([], hexCode.map(function(c) {
        return [
            c,
            c
        ];
    }));
    // Add default alpha value
    if (hexCode.length === 6) hexCode.push("F", "F");
    const hexValue = parseInt(hexCode.join(""), 16);
    return {
        r: hexValue >> 24 & 255,
        g: hexValue >> 16 & 255,
        b: hexValue >> 8 & 255,
        a: hexValue & 255,
        hex: "#" + hexCode.slice(0, 6).join("")
    };
}
exports.getOptions = function getOptions(options) {
    if (!options) options = {};
    if (!options.color) options.color = {};
    const margin = typeof options.margin === "undefined" || options.margin === null || options.margin < 0 ? 4 : options.margin;
    const width = options.width && options.width >= 21 ? options.width : undefined;
    const scale = options.scale || 4;
    return {
        width: width,
        scale: width ? 4 : scale,
        margin: margin,
        color: {
            dark: hex2rgba(options.color.dark || "#000000ff"),
            light: hex2rgba(options.color.light || "#ffffffff")
        },
        type: options.type,
        rendererOpts: options.rendererOpts || {}
    };
};
exports.getScale = function getScale(qrSize, opts) {
    return opts.width && opts.width >= qrSize + opts.margin * 2 ? opts.width / (qrSize + opts.margin * 2) : opts.scale;
};
exports.getImageWidth = function getImageWidth(qrSize, opts) {
    const scale = exports.getScale(qrSize, opts);
    return Math.floor((qrSize + opts.margin * 2) * scale);
};
exports.qrToImageData = function qrToImageData(imgData, qr, opts) {
    const size = qr.modules.size;
    const data = qr.modules.data;
    const scale = exports.getScale(size, opts);
    const symbolSize = Math.floor((size + opts.margin * 2) * scale);
    const scaledMargin = opts.margin * scale;
    const palette = [
        opts.color.light,
        opts.color.dark
    ];
    for(let i = 0; i < symbolSize; i++)for(let j = 0; j < symbolSize; j++){
        let posDst = (i * symbolSize + j) * 4;
        let pxColor = opts.color.light;
        if (i >= scaledMargin && j >= scaledMargin && i < symbolSize - scaledMargin && j < symbolSize - scaledMargin) {
            const iSrc = Math.floor((i - scaledMargin) / scale);
            const jSrc = Math.floor((j - scaledMargin) / scale);
            pxColor = palette[data[iSrc * size + jSrc] ? 1 : 0];
        }
        imgData[posDst++] = pxColor.r;
        imgData[posDst++] = pxColor.g;
        imgData[posDst++] = pxColor.b;
        imgData[posDst] = pxColor.a;
    }
};

},{}],"7Akrj":[function(require,module,exports) {
const Utils = require("c36bbcf663291acc");
function getColorAttrib(color, attrib) {
    const alpha = color.a / 255;
    const str = attrib + '="' + color.hex + '"';
    return alpha < 1 ? str + " " + attrib + '-opacity="' + alpha.toFixed(2).slice(1) + '"' : str;
}
function svgCmd(cmd, x, y) {
    let str = cmd + x;
    if (typeof y !== "undefined") str += " " + y;
    return str;
}
function qrToPath(data, size, margin) {
    let path = "";
    let moveBy = 0;
    let newRow = false;
    let lineLength = 0;
    for(let i = 0; i < data.length; i++){
        const col = Math.floor(i % size);
        const row = Math.floor(i / size);
        if (!col && !newRow) newRow = true;
        if (data[i]) {
            lineLength++;
            if (!(i > 0 && col > 0 && data[i - 1])) {
                path += newRow ? svgCmd("M", col + margin, 0.5 + row + margin) : svgCmd("m", moveBy, 0);
                moveBy = 0;
                newRow = false;
            }
            if (!(col + 1 < size && data[i + 1])) {
                path += svgCmd("h", lineLength);
                lineLength = 0;
            }
        } else moveBy++;
    }
    return path;
}
exports.render = function render(qrData, options, cb) {
    const opts = Utils.getOptions(options);
    const size = qrData.modules.size;
    const data = qrData.modules.data;
    const qrcodesize = size + opts.margin * 2;
    const bg = !opts.color.light.a ? "" : "<path " + getColorAttrib(opts.color.light, "fill") + ' d="M0 0h' + qrcodesize + "v" + qrcodesize + 'H0z"/>';
    const path = "<path " + getColorAttrib(opts.color.dark, "stroke") + ' d="' + qrToPath(data, size, opts.margin) + '"/>';
    const viewBox = 'viewBox="0 0 ' + qrcodesize + " " + qrcodesize + '"';
    const width = !opts.width ? "" : 'width="' + opts.width + '" height="' + opts.width + '" ';
    const svgTag = '<svg xmlns="http://www.w3.org/2000/svg" ' + width + viewBox + ' shape-rendering="crispEdges">' + bg + path + "</svg>\n";
    if (typeof cb === "function") cb(null, svgTag);
    return svgTag;
};

},{"c36bbcf663291acc":"6rMWz"}]},["km5uZ","bB7Pu"], "bB7Pu", "parcelRequirec533")

//# sourceMappingURL=index.3d214d75.js.map
